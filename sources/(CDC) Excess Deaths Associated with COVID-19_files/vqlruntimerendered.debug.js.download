/*! BEGIN RuntimeRendered */

(function() {
  'dont use strict';
  var $asm = {};
  global.tab = global.tab || {};
  ss.initAssembly($asm, 'vqlruntimerendered');
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.InternalTotalNode
  var $tab_$InternalTotalNode = ss.mkType($asm, 'tab.$InternalTotalNode', function() {
    this.$label = null;
    this.$isEmpty = false;
    this.$isStretched = false;
    this.$enclosedIndex = 0;
    this.$level = 0;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TickPlacement.TickPlacementType
  var $tab_$TickPlacement$TickPlacementType = ss.mkEnum($asm, 'tab.$TickPlacement$TickPlacementType', { $unknown: 0, $linear: 1, $dateTime: 2, $manual: 3 });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.ArrowKeyNavigationUtil
  var $tab_ArrowKeyNavigationUtil = global.tab.ArrowKeyNavigationUtil = ss.mkType($asm, 'tab.ArrowKeyNavigationUtil', function() {
  }, null, {
    handleArrowKeyEvent: function ArrowKeyNavigationUtil$HandleArrowKeyEvent(id, keyValue, headerHolderViewModels, sceneMarginLocation) {
      var indices = $tab_ArrowKeyNavigationUtil.$getHeaderHolderAndNodeAndEnclosedIndicesForNodeWithIdIfPresent(headerHolderViewModels, id);
      if (ss.isNullOrUndefined(indices)) {
        return;
      }
      var headerHolderIndex = indices.item1;
      var nodeIndex = indices.item2;
      var enclosedIndex = indices.item3;
      switch (sceneMarginLocation) {
        case 3:
        case 2: {
          $tab_ArrowKeyNavigationUtil.$handleHorizontalSceneMargins(headerHolderViewModels, keyValue, headerHolderIndex, nodeIndex, enclosedIndex);
          break;
        }
        case 0:
        case 1: {
          $tab_ArrowKeyNavigationUtil.$handleVerticalSceneMargins(headerHolderViewModels, keyValue, headerHolderIndex, nodeIndex, enclosedIndex);
          break;
        }
        default: {
          return;
        }
      }
    },
    $handleHorizontalSceneMargins: function ArrowKeyNavigationUtil$HandleHorizontalSceneMargins(headerHolderViewModels, keyValue, currHeaderHolderIndex, currNodeIndex, enclosedIndex) {
      switch (keyValue) {
        case 'ArrowDown': {
          $tab_ArrowKeyNavigationUtil.$goToNextSibling(headerHolderViewModels, currHeaderHolderIndex, currNodeIndex);
          break;
        }
        case 'ArrowUp': {
          $tab_ArrowKeyNavigationUtil.$goToPreviousSibling(headerHolderViewModels, currHeaderHolderIndex, currNodeIndex);
          break;
        }
        case 'ArrowRight': {
          $tab_ArrowKeyNavigationUtil.$goToFirstNodeOfNextHeaderHolderWithEnclosedIndex(headerHolderViewModels, currHeaderHolderIndex, currNodeIndex);
          break;
        }
        case 'ArrowLeft': {
          $tab_ArrowKeyNavigationUtil.$goToEnclosedIndexInPreviousHeaderHolder(headerHolderViewModels, currHeaderHolderIndex, enclosedIndex);
          break;
        }
        default: {
          return;
        }
      }
    },
    $handleVerticalSceneMargins: function ArrowKeyNavigationUtil$HandleVerticalSceneMargins(headerHolderViewModels, keyValue, currHeaderHolderIndex, currNodeIndex, enclosedIndex) {
      switch (keyValue) {
        case 'ArrowDown': {
          $tab_ArrowKeyNavigationUtil.$goToFirstNodeOfNextHeaderHolderWithEnclosedIndex(headerHolderViewModels, currHeaderHolderIndex, currNodeIndex);
          break;
        }
        case 'ArrowUp': {
          $tab_ArrowKeyNavigationUtil.$goToEnclosedIndexInPreviousHeaderHolder(headerHolderViewModels, currHeaderHolderIndex, enclosedIndex);
          break;
        }
        case 'ArrowRight': {
          $tab_ArrowKeyNavigationUtil.$goToNextSibling(headerHolderViewModels, currHeaderHolderIndex, currNodeIndex);
          break;
        }
        case 'ArrowLeft': {
          $tab_ArrowKeyNavigationUtil.$goToPreviousSibling(headerHolderViewModels, currHeaderHolderIndex, currNodeIndex);
          break;
        }
      }
    },
    $goToFirstNodeOfNextHeaderHolderWithEnclosedIndex: function ArrowKeyNavigationUtil$GoToFirstNodeOfNextHeaderHolderWithEnclosedIndex(headerHolderViewModels, currHeaderHolderIndex, currNodeIndex) {
      var newHeaderHolderIndex = currHeaderHolderIndex + 1;
      if (headerHolderViewModels.length <= newHeaderHolderIndex) {
        return;
      }
      var nodeIndex = $tab_ArrowKeyNavigationUtil.$findFirstNodeIndexWithEnclosedIndex(headerHolderViewModels, newHeaderHolderIndex, currNodeIndex);
      $tab_ArrowKeyNavigationUtil.$findAndFocusIfPossible(headerHolderViewModels, newHeaderHolderIndex, nodeIndex);
    },
    $goToEnclosedIndexInPreviousHeaderHolder: function ArrowKeyNavigationUtil$GoToEnclosedIndexInPreviousHeaderHolder(headerHolderViewModels, headerHolderIndex, enclosedIndex) {
      $tab_ArrowKeyNavigationUtil.$findAndFocusIfPossible(headerHolderViewModels, headerHolderIndex - 1, enclosedIndex);
    },
    $goToNextSibling: function ArrowKeyNavigationUtil$GoToNextSibling(headerHolderViewModels, headerHolderIndex, nodeIndex) {
      $tab_ArrowKeyNavigationUtil.$findAndFocusIfPossible(headerHolderViewModels, headerHolderIndex, nodeIndex + 1);
    },
    $goToPreviousSibling: function ArrowKeyNavigationUtil$GoToPreviousSibling(headerHolderViewModels, headerHolderIndex, nodeIndex) {
      $tab_ArrowKeyNavigationUtil.$findAndFocusIfPossible(headerHolderViewModels, headerHolderIndex, nodeIndex - 1);
    },
    $getHeaderHolderAndNodeAndEnclosedIndicesForNodeWithIdIfPresent: function ArrowKeyNavigationUtil$GetHeaderHolderAndNodeAndEnclosedIndicesForNodeWithIdIfPresent(headerHolderViewModels, id) {
      for (var i = 0; i < headerHolderViewModels.length; i++) {
        var nodeIndexAndEnclosedIndex = headerHolderViewModels[i].getIndexAndEnclosedIndexForNodeWithIdIfPresent(id);
        if (ss.isNullOrUndefined(nodeIndexAndEnclosedIndex)) {
          continue;
        }
        return { item1: i, item2: nodeIndexAndEnclosedIndex.item1, item3: nodeIndexAndEnclosedIndex.item2 };
      }
      return null;
    },
    $findFirstNodeIndexWithEnclosedIndex: function ArrowKeyNavigationUtil$FindFirstNodeIndexWithEnclosedIndex(headerHolderViewModels, headerHolderIndex, enclosedIndex) {
      var headerHolder = headerHolderViewModels[headerHolderIndex];
      return headerHolder.findFirstNodeIndexWithEnclosedIndex(enclosedIndex);
    },
    $findAndFocusIfPossible: function ArrowKeyNavigationUtil$FindAndFocusIfPossible(headerHolderViewModels, headerHolderIndex, nodeIndex) {
      if (headerHolderIndex < 0 || headerHolderIndex > headerHolderViewModels.length - 1) {
        return;
      }
      headerHolderViewModels[headerHolderIndex].findAndFocusIfPossible(nodeIndex);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.ArrowKeyNavKeyboardShortcut
  var $tab_ArrowKeyNavKeyboardShortcut = global.tab.ArrowKeyNavKeyboardShortcut = ss.mkType($asm, 'tab.ArrowKeyNavKeyboardShortcut', function(elem, arrowKeyEventHandler) {
    this.$elem = null;
    this.$arrowKeyEventHandler = null;
    KeyboardShortcuts.BaseKeyboardShortcut.call(this);
    this.$elem = elem;
    this.$arrowKeyEventHandler = arrowKeyEventHandler;
  }, {
    getKeyComboOrKeyCombos: function ArrowKeyNavKeyboardShortcut$GetKeyComboOrKeyCombos() {
      return new KeyboardShortcuts.KeyCombos(new KeyboardShortcuts.KeyCombo('ArrowUp', null), new KeyboardShortcuts.KeyCombo('ArrowDown', null), new KeyboardShortcuts.KeyCombo('ArrowLeft', null), new KeyboardShortcuts.KeyCombo('ArrowRight', null));
    },
    getElement: function ArrowKeyNavKeyboardShortcut$GetElement() {
      return this.$elem;
    },
    isAllowed: function ArrowKeyNavKeyboardShortcut$IsAllowed(e) {
      return ss.isValue(e.target);
    },
    executeShortcut: function ArrowKeyNavKeyboardShortcut$ExecuteShortcut(e) {
      var target = e.target;
      this.$arrowKeyEventHandler(target.id, KeyboardShortcuts.KeyboardUtilities.NormalizeKey(e.key));
    },
    getTelemetryKey: function ArrowKeyNavKeyboardShortcut$GetTelemetryKey() {
      return 'Arrow key navigation';
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisBorderInput
  var $tab_AxisBorderInput = global.tab.AxisBorderInput = ss.mkType($asm, 'tab.AxisBorderInput', function(top, left, borderAttributes) {
    this.$top = 0;
    this.$left = 0;
    this.$borderAttributes = null;
    this.$top = top;
    this.$left = left;
    this.$borderAttributes = borderAttributes;
  }, {
    get_left: function AxisBorderInput$get_Left() {
      return this.$left;
    },
    get_top: function AxisBorderInput$get_Top() {
      return this.$top;
    },
    get_borderAttributes: function AxisBorderInput$get_BorderAttributes() {
      return this.$borderAttributes;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisComponent
  var $tab_AxisComponent = global.tab.AxisComponent = ss.mkType($asm, 'tab.AxisComponent', function(props) {
    this.$sortIndicator = null;
    this.$boundAxis = null;
    this.$axisDiv = null;
    spiff.PureRenderComponent.call(this, props);
    this.state = { isHovered: false, showSortIndicator: false };
    this.$boundAxis = ss.mkdel(this, function(d) {
      if (ss.isValue(d)) {
        this.$axisDiv = d;
      }
    });
    this.$sortIndicator = new $tab_AxisSortIndicator(props);
  }, {
    render: function AxisComponent$Render() {
      return spiff.DOMElements.div({ className: 'tab-vizAxisWrapper', style: this.$getAxisStyle(), onMouseOver: ss.mkdel(this, function(evt) {
        this.$hoverChanged(true);
      }), onMouseLeave: ss.mkdel(this, function(evt1) {
        this.$hoverChanged(false);
      }), ref: this.$boundAxis }, ((this.props.axisTitle.availableSpaceForTitle > 0) ? ss.mkdel(this, function() {
        return React.createElement($tab_AxisTitleComponent, this.props.axisTitle);
      })() : null), (this.state.showSortIndicator ? ss.mkdel(this, function() {
        return this.$createSortIndicatorDiv();
      })() : null), React.createElement($tab_TickMarkComponent, this.props.ticks), (ss.isValue(this.props.tickLabels) ? ss.mkdel(this, function() {
        return React.createElement($tab_TickLabelComponent, this.props.tickLabels);
      })() : null));
    },
    $getAxisStyle: function AxisComponent$GetAxisStyle() {
      var style = { top: this.props.top + 'px', left: this.props.left + 'px' };
      if (tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        style.width = this.props.alongAxisPixelSize + 'px';
        style.height = this.props.pixelSize + 'px';
      }
      else {
        style.width = this.props.pixelSize + 'px';
        style.height = this.props.alongAxisPixelSize + 'px';
      }
      if (this.props.isSelected) {
        style.backgroundColor = this.props.axisStyle.selectedFillColor;
        style.color = this.props.axisStyle.selectedTextColor;
      }
      else {
        style.backgroundColor = this.props.axisStyle.fillColor;
        style.color = this.props.axisStyle.textColor;
      }
      return style;
    },
    $hoverChanged: function AxisComponent$HoverChanged(isHovered) {
      this.$sortIndicator.set_isHoverIndicator(isHovered);
      this.setState({ isHovered: isHovered });
    },
    componentDidUpdate: function AxisComponent$ComponentDidUpdate() {
      if (ss.isNullOrUndefined(this.$axisDiv)) {
        return;
      }
      var endOfTitle = this.$getEndOfTitlePosition(this.$axisDiv);
      this.$sortIndicator.updateIndicatorPosition(endOfTitle);
      this.setState({ showSortIndicator: this.$sortIndicator.shouldShowSortIndicator() });
    },
    $getAxisTitleElement: function AxisComponent$GetAxisTitleElement(axisDiv) {
      var matchingElements = axisDiv.getElementsByClassName('tab-vizAxisTitle');
      if (matchingElements.length === 0) {
        return null;
      }
      return matchingElements.item(0);
    },
    $getEndOfTitlePosition: function AxisComponent$GetEndOfTitlePosition(axisDiv) {
      if (BrowserSupport.BrowserSupport.IsIE()) {
        return this.$getEndOfTitlePositionForIE(axisDiv);
      }
      var title = this.$getAxisTitleElement(axisDiv);
      var titleContainer = (ss.isNullOrUndefined(title) ? null : title.parentElement);
      if (ss.isNullOrUndefined(titleContainer)) {
        return null;
      }
      var perpendicularOffset = this.props.axisTitle.titlePadding + Math.ceil((titleContainer.offsetHeight - $tab_AxisSortIndicator.sortIndicatorSize) / 2);
      var endOfTitle = title.offsetLeft + title.offsetWidth;
      if (tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        endOfTitle += titleContainer.offsetLeft;
        return { x: endOfTitle, y: perpendicularOffset };
      }
      else {
        endOfTitle += titleContainer.offsetTop;
        return { x: perpendicularOffset, y: endOfTitle };
      }
    },
    $createSortIndicatorDiv: function AxisComponent$CreateSortIndicatorDiv() {
      return spiff.DOMElements.div({ className: this.$sortIndicator.getSortIndicatorClassName(), style: this.$sortIndicator.getSortIndicatorCss(), title: this.props.sortIndicatorTooltip, onMouseOver: ss.mkdel(this, function(evt) {
        this.props.sortIndicatorHoverCallback(true);
      }), onMouseLeave: ss.mkdel(this, function(evt1) {
        this.props.sortIndicatorHoverCallback(false);
      }), onClick: ss.mkdel(this, function(evt2) {
        this.$sortIndicatorClicked(evt2);
      }) });
    },
    $sortIndicatorClicked: function AxisComponent$SortIndicatorClicked(evt) {
      this.props.invokeSortCommand({ x: evt.pageX, y: evt.pageY }, this.props.sceneMarginLocation);
    },
    $getEndOfTitlePositionForIE: function AxisComponent$GetEndOfTitlePositionForIE(axisDiv) {
      var title = this.$getAxisTitleElement(axisDiv);
      var titleContainer = (ss.isNullOrUndefined(title) ? null : title.parentElement);
      if (ss.isNullOrUndefined(titleContainer)) {
        return null;
      }
      var perpendicularPadding = this.props.axisTitle.titlePadding;
      if (tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        perpendicularPadding += Math.ceil((titleContainer.offsetHeight - $tab_AxisSortIndicator.sortIndicatorSize) / 2);
        var endOfTitle = titleContainer.offsetLeft + title.offsetLeft + title.offsetWidth;
        return { x: endOfTitle, y: perpendicularPadding };
      }
      else {
        perpendicularPadding += Math.ceil((titleContainer.offsetWidth - $tab_AxisSortIndicator.sortIndicatorSize) / 2);
        var endOfTitle1 = titleContainer.offsetTop + title.offsetTop + title.offsetHeight;
        return { x: perpendicularPadding, y: endOfTitle1 };
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisHolderComponent
  var $tab_AxisHolderComponent = global.tab.AxisHolderComponent = ss.mkType($asm, 'tab.AxisHolderComponent', function(props) {
    spiff.PureRenderComponent.call(this, props);
  }, {
    render: function AxisHolderComponent$Render() {
      return this.$renderAxes();
    },
    $renderAxes: function AxisHolderComponent$RenderAxes() {
      var axes = _.map(this.props.axes, function(axisItem) {
        return React.createElement($tab_AxisComponent, axisItem);
      });
      var dividerElements = this.$makeDividerElements();
      return spiff.DOMElements.div({ className: 'tab-vizAxisHolderWrapper', style: this.$getAxisDimension(), 'aria-hidden': 'true', tabIndex: -1 }, axes, dividerElements);
    },
    $makeDividerElements: function AxisHolderComponent$MakeDividerElements() {
      var dividers = [];
      for (var $t1 = 0; $t1 < this.props.borderRenderingInput.length; $t1++) {
        var axisNode = this.props.borderRenderingInput[$t1];
        if (ss.isValue(axisNode.get_borderAttributes())) {
          dividers.push($tab_BorderRenderer.drawLine({ x: axisNode.get_left(), y: axisNode.get_top() }, this.props.pixelSize, axisNode.get_borderAttributes(), !tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)));
        }
      }
      return dividers;
    },
    $getAxisDimension: function AxisHolderComponent$GetAxisDimension() {
      if (tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        var axisDimension = { width: this.props.alongAxisTotalPixelSize + 'px', height: this.props.pixelSize + 'px' };
        if (this.props.sceneMarginLocation === 1) {
          axisDimension.marginTop = 1 + 'px';
        }
        return axisDimension;
      }
      else {
        return { width: this.props.pixelSize + 'px', height: this.props.alongAxisTotalPixelSize + 'px' };
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisHolderViewModel
  var $tab_AxisHolderViewModel = global.tab.AxisHolderViewModel = ss.mkType($asm, 'tab.AxisHolderViewModel', function(sceneMarginModel, marginRow, sceneMarginSelection, borderDataModel) {
    this.$axisTable = null;
    this.$isFolded = false;
    this.$axisPropsBuilder = null;
    this.$borderStartLevels = null;
    this.$borderDataModel = null;
    ss.makeGenericType($tab_BaseHolderViewModel$1, [Object]).call(this, sceneMarginModel, marginRow, sceneMarginSelection);
    this.$isFolded = sceneMarginModel.get_sceneMarginLayout().ElementType[this.marginRow] === 1;
    this.$axisPropsBuilder = new $tab_AxisPropsBuilder(sceneMarginModel, this.orientedSize, this.alongAxisPixelSize);
    this.$borderStartLevels = this.$calcBorderStartLevels(sceneMarginModel.get_nodeData());
    this.$borderDataModel = borderDataModel;
    this.$axisTable = sceneMarginModel.get_axisTable();
  }, {
    set_sortIndicatorHoverCallback: function AxisHolderViewModel$set_SortIndicatorHoverCallback(value) {
      this.$axisPropsBuilder.set_sortIndicatorHoverCallback(value);
    },
    set_invokeSortCommand: function AxisHolderViewModel$set_InvokeSortCommand(value) {
      this.$axisPropsBuilder.set_invokeSortCommand(value);
    },
    createInitialProps: function AxisHolderViewModel$CreateInitialProps() {
      return { alongAxisTotalPixelSize: this.orientedSize.get_along(), pixelSize: this.orientedSize.get_perpendicular(), sceneMarginLocation: this.location };
    },
    createUpdatedProps: function AxisHolderViewModel$CreateUpdatedProps() {
      var props = { sceneMarginViewportSize: this.get_sceneMarginViewportSize() };
      var axes = [];
      var resizers = [];
      var $t1 = this.$getIndicesOfAxesInThisHolder();
      for (var $t2 = 0; $t2 < $t1.length; $t2++) {
        var axisIndex = $t1[$t2];
        axes.push(this.$computeAxisProps(axisIndex));
        resizers.push(this.$computeAxisResizerProps(axisIndex));
      }
      props.axes = axes;
      props.axisResizers = resizers;
      props.borderRenderingInput = this.$calculateBorderInputs();
      return props;
    },
    $calcBorderStartLevels: function AxisHolderViewModel$CalcBorderStartLevels(nodes) {
      var startLevels = [];
      for (var i = 0; i < nodes.Level.length; ++i) {
        if (nodes.Level[i] === this.level) {
          startLevels.push(nodes.BorderStartLevel[i]);
        }
      }
      return Array.prototype.slice.call(startLevels);
    },
    $getIndicesOfAxesInThisHolder: function AxisHolderViewModel$GetIndicesOfAxesInThisHolder() {
      var result = [];
      for (var i = 0; i < this.$axisTable.FoldState.length; i++) {
        var nodeFoldState = this.$axisTable.FoldState[i];
        var isNodeFolded = nodeFoldState !== 0;
        if (isNodeFolded === this.$isFolded) {
          result.push(i);
        }
      }
      return result;
    },
    $computeBorderInput: function AxisHolderViewModel$ComputeBorderInput(axisIndex) {
      var orientedAlongOffset = this.makeOrientedSize(this.alongAxisPixelOffset[axisIndex], 0);
      return new $tab_AxisBorderInput(orientedAlongOffset.get_height(), orientedAlongOffset.get_width(), this.$borderDataModel.getAxisAndNonBottomHeaderDividers(this.$borderStartLevels[axisIndex]));
    },
    $calculateBorderInputs: function AxisHolderViewModel$CalculateBorderInputs() {
      var borderInput = [];
      for (var i = 0; i < this.$axisTable.FoldState.length; i++) {
        var nodeFoldState = this.$axisTable.FoldState[i];
        var isNodeFolded = nodeFoldState !== 0;
        if (this.$isFolded && isNodeFolded !== this.$isFolded || !this.$isFolded && isNodeFolded === this.$isFolded) {
          borderInput.push(this.$computeBorderInput(i));
        }
      }
      return borderInput;
    },
    $computeAxisProps: function AxisHolderViewModel$ComputeAxisProps(axisIndex) {
      var orientedAlongOffset = this.makeOrientedSize(this.alongAxisPixelOffset[axisIndex], 0);
      return this.$axisPropsBuilder.buildAxisProps(axisIndex, this.orientedSize.get_perpendicular(), orientedAlongOffset.get_height(), orientedAlongOffset.get_width(), this.isHolderSelected(axisIndex));
    },
    $computeAxisResizerProps: function AxisHolderViewModel$ComputeAxisResizerProps(axisIndex) {
      return this.$axisPropsBuilder.buildAxisResizerProps(axisIndex, this.get_sceneMarginViewportSize());
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisPropsBuilder
  var $tab_AxisPropsBuilder = global.tab.AxisPropsBuilder = ss.mkType($asm, 'tab.AxisPropsBuilder', function(sceneMarginModel, orientedSize, alongAxisPixelSizes) {
    this.$axisTable = null;
    this.$sceneMarginLocation = 0;
    this.$titleStyles = null;
    this.$titleFontMetrics = null;
    this.$isHorizontal = false;
    this.$orientedSize = null;
    this.$tickProducerOutput = null;
    this.$paneExtents = null;
    this.$columnCount = 0;
    this.$axisStyles = null;
    this.$labelSkipTable = null;
    this.$alongAxisPixelSizes = null;
    this.$sendAxisResizeCommand = null;
    this.$1$SortIndicatorHoverCallbackField = null;
    this.$1$InvokeSortCommandField = null;
    this.$axisTable = sceneMarginModel.get_axisTable();
    this.$axisStyles = sceneMarginModel.get_axisOutput().Style;
    this.$sceneMarginLocation = sceneMarginModel.get_sceneMarginLocation();
    this.$titleStyles = sceneMarginModel.get_axisOutput().TitleStyle;
    this.$titleFontMetrics = sceneMarginModel.get_axisOutput().TitleFontMetrics;
    this.$isHorizontal = sceneMarginModel.isHorizontal();
    this.$orientedSize = orientedSize;
    this.$tickProducerOutput = sceneMarginModel.get_tickPlacement();
    this.$paneExtents = sceneMarginModel.get_paneExtents();
    this.$columnCount = sceneMarginModel.get_columnCount();
    this.$labelSkipTable = sceneMarginModel.get_labelSkipTable();
    this.$alongAxisPixelSizes = alongAxisPixelSizes;
    this.$sendAxisResizeCommand = ss.mkdel(sceneMarginModel, sceneMarginModel.sendAxisResizeCommand);
  }, {
    get_sortIndicatorHoverCallback: function AxisPropsBuilder$get_SortIndicatorHoverCallback() {
      return this.$1$SortIndicatorHoverCallbackField;
    },
    set_sortIndicatorHoverCallback: function AxisPropsBuilder$set_SortIndicatorHoverCallback(value) {
      this.$1$SortIndicatorHoverCallbackField = value;
    },
    get_invokeSortCommand: function AxisPropsBuilder$get_InvokeSortCommand() {
      return this.$1$InvokeSortCommandField;
    },
    set_invokeSortCommand: function AxisPropsBuilder$set_InvokeSortCommand(value) {
      this.$1$InvokeSortCommandField = value;
    },
    buildAxisProps: function AxisPropsBuilder$BuildAxisProps(index, pixelSize, top, left, isSelected) {
      var alongAxisPixelSize = this.$alongAxisPixelSizes[index];
      var isReversed = this.$axisTable.IsReversed[index];
      var tickPlacementIndex = (this.$isHorizontal ? index : (index + this.$columnCount));
      var regionRect = (this.$isHorizontal ? { x: 0, y: 0, w: alongAxisPixelSize, h: this.$orientedSize.get_perpendicular() } : { x: 0, y: 0, w: this.$orientedSize.get_perpendicular(), h: alongAxisPixelSize });
      var allLabelPositions = this.$getTickPlacementList(tickPlacementIndex, regionRect, isReversed, false, true);
      var labelProps = null;
      if (ss.isValue(allLabelPositions) && allLabelPositions.length > 0) {
        labelProps = this.$getTickLabelProps(index, tickPlacementIndex, allLabelPositions, isSelected);
      }
      var tickProps = this.$getMarkElementProps(allLabelPositions, index, tickPlacementIndex, regionRect, isReversed);
      var titleProps = this.$getAxisTitleProps(index, tickPlacementIndex, isSelected, labelProps);
      return { top: top, left: left, isSelected: isSelected, alongAxisPixelSize: alongAxisPixelSize, pixelSize: pixelSize, key: this.$sceneMarginLocation + index, sceneMarginLocation: this.$sceneMarginLocation, tickLabels: labelProps, ticks: tickProps, axisTitle: titleProps, axisStyle: $tab_DatastoreHeaderAdapter.buildStyleProps(this.$axisStyles, this.$axisTable.PerFieldStyleIndex[index]), sortIndicatorClassName: this.$getSortIndicatorClassName(index), canShowHoverSortIndicator: this.$getCanShowHoverSortIndicator(index), sortIndicatorTooltip: this.$getSortIndicatorTooltip(index), sortIndicatorHoverCallback: this.get_sortIndicatorHoverCallback(), invokeSortCommand: this.get_invokeSortCommand() };
    },
    buildAxisResizerProps: function AxisPropsBuilder$BuildAxisResizerProps(index, sceneMarginViewportSize) {
      var $t1 = new $tab_AxisResizerProps();
      $t1.sceneMarginLocation = this.$sceneMarginLocation;
      $t1.sendAxisResizeCommand = this.$sendAxisResizeCommand;
      $t1.sceneMarginViewportSize = sceneMarginViewportSize;
      $t1.foldState = this.$axisTable.FoldState[index];
      return $t1;
    },
    $getTickPlacementList: function AxisPropsBuilder$GetTickPlacementList(tickPlacementIndex, regionRect, isReversed, getMinorTicks, useExactTickPositions) {
      var showTicks = false;
      if (getMinorTicks) {
        showTicks = this.$tickProducerOutput.PerHeaderMajorTickPlacement.ShowMinorTicks[tickPlacementIndex];
      }
      else {
        showTicks = this.$tickProducerOutput.PerHeaderMajorTickPlacement.ShowMajorTicks[tickPlacementIndex];
      }
      if (showTicks) {
        var config = new $tab_TickPlacementConfig(isReversed, this.$isHorizontal, getMinorTicks);
        return $tab_TickPlacement.getTickPlacement(this.$tickProducerOutput, regionRect, tickPlacementIndex, config, useExactTickPositions);
      }
      return null;
    },
    $areTicksTooDense: function AxisPropsBuilder$AreTicksTooDense(count, index) {
      return ss.idiv(this.$alongAxisPixelSizes[index], count) < 2;
    },
    $getTickLabelProps: function AxisPropsBuilder$GetTickLabelProps(index, tickPlacementIndex, allLabelPositions, isSelected) {
      var alongAxisPixelSize = this.$alongAxisPixelSizes[index];
      var tickLabelVisibleRange = this.$getTickLabelVisibleRangeForAxisIndex(index);
      var labelSkipResult = $tab_LabelSkipResult.generateFromLabelSkipTable(this.$labelSkipTable, tickPlacementIndex);
      var tickLabelStyle = $tab_TickPlacement.getTickLabelStyle(this.$tickProducerOutput, tickPlacementIndex);
      if (isSelected && ss.isValue(tickLabelStyle)) {
        tickLabelStyle.text_style_color = this.$axisStyles.SelectedTextColor[tickPlacementIndex];
      }
      var tickLabelsAndIsFirstTickOutsideViewPort = $tab_TickPlacement.getTickLabelsAndIsFirstTickOutsideViewPort(this.$tickProducerOutput, alongAxisPixelSize, tickPlacementIndex, tickLabelVisibleRange, labelSkipResult);
      var tickLabelPositions = $tab_TickPlacement.getTickLabelPositions(allLabelPositions, labelSkipResult, tickLabelsAndIsFirstTickOutsideViewPort.isFirstTickOutsideViewPort);
      var labelWidths = [];
      for (var $t1 = 0; $t1 < tickLabelsAndIsFirstTickOutsideViewPort.tickLabels.length; $t1++) {
        var tickLabel = tickLabelsAndIsFirstTickOutsideViewPort.tickLabels[$t1];
        var width = Math.ceil(tab.RuntimeTextMeasurementHooks.measureTextWidth$1(tickLabelStyle, tickLabel));
        labelWidths.push(width);
      }
      var labelHeight = this.$getMeasuredLabelFontHeight(tickPlacementIndex);
      var $t2 = new $tab_TickLabelProps();
      $t2.tickLabelPositions = tickLabelPositions;
      $t2.visibleTickLabels = tickLabelsAndIsFirstTickOutsideViewPort.tickLabels;
      $t2.alongAxisPixelSize = alongAxisPixelSize;
      $t2.pixelSize = this.$orientedSize.get_perpendicular();
      $t2.sceneMarginLocation = this.$sceneMarginLocation;
      $t2.majorTickSize = this.$tickProducerOutput.TickLengthMajorPixels;
      $t2.tickLabelStyle = tickLabelStyle;
      $t2.measuredLabelWidths = labelWidths;
      $t2.measuredLabelHeight = labelHeight;
      return $t2;
    },
    $getTickLabelVisibleRangeForAxisIndex: function AxisPropsBuilder$GetTickLabelVisibleRangeForAxisIndex(axisIndex) {
      if (this.$isHorizontal) {
        var paneIndex = _.indexOf(this.$paneExtents.pane_col, axisIndex);
        return new $tab_MinMaxPair(this.$paneExtents.XRangeMin[paneIndex], this.$paneExtents.XRangeMax[paneIndex]);
      }
      else {
        var paneIndex1 = _.indexOf(this.$paneExtents.pane_row, axisIndex);
        return new $tab_MinMaxPair(this.$paneExtents.YRangeMin[paneIndex1], this.$paneExtents.YRangeMax[paneIndex1]);
      }
    },
    $getMarkElementProps: function AxisPropsBuilder$GetMarkElementProps(allLabelPositions, index, tickPlacementIndex, regionRect, isReversed) {
      var majorPlacements = ((ss.isValue(allLabelPositions) && allLabelPositions.length > 0 && this.$areTicksTooDense(allLabelPositions.length, index)) ? this.$getTickPlacementList(tickPlacementIndex, regionRect, isReversed, false, false) : allLabelPositions);
      var minorPlacements = this.$getTickPlacementList(tickPlacementIndex, regionRect, isReversed, true, false);
      return { majorTicks: $tab_TickPlacement.getTicksForMultiPanes(majorPlacements, index), minorTicks: $tab_TickPlacement.getTicksForMultiPanes(minorPlacements, index), majorTickSize: this.$tickProducerOutput.TickLengthMajorPixels, minorTickSize: this.$tickProducerOutput.TickLengthMinorPixels, alongAxisPixelSize: this.$alongAxisPixelSizes[index], pixelSize: this.$orientedSize.get_perpendicular(), sceneMarginLocation: this.$sceneMarginLocation, tickMarkColor: tab.ColorModel.fromArgbInt(this.$axisStyles.TickColor[this.$axisTable.PerFieldStyleIndex[index]]) };
    },
    $getAxisTitleProps: function AxisPropsBuilder$GetAxisTitleProps(axisTableIndex, tickPlacementIndex, isSelected, labelProps) {
      var totalAvailableSpaceForTitle = this.$computeAvailablePerpendicularSpaceForTitleWithoutPadding(labelProps);
      var perpendicularSizeOfSingleLineTitle = this.$getMeasuredTitleFontHeight(axisTableIndex);
      var remainingPerpendicularSpace = totalAvailableSpaceForTitle - perpendicularSizeOfSingleLineTitle;
      var excessPerpendicularSpace = Math.max(0, remainingPerpendicularSpace);
      var usableTitlePadding = Math.min(this.$axisTable.TitlePadding[axisTableIndex], excessPerpendicularSpace);
      var availableSpaceForTitle = ((totalAvailableSpaceForTitle > perpendicularSizeOfSingleLineTitle) ? (totalAvailableSpaceForTitle - usableTitlePadding) : 0);
      var numLinesLimit = Math.floor(availableSpaceForTitle / perpendicularSizeOfSingleLineTitle);
      return { title: (ss.isNullOrUndefined(this.$axisTable.AxisTitle) ? '' : this.$axisTable.AxisTitle[axisTableIndex]), subtitle: this.$getAxisSubtitle(axisTableIndex, tickPlacementIndex), titleStyle: this.$getTitleStyle(axisTableIndex, isSelected), alongAxisPixelSize: this.$alongAxisPixelSizes[axisTableIndex], pixelSize: this.$orientedSize.get_perpendicular(), sceneMarginLocation: this.$sceneMarginLocation, titlePadding: usableTitlePadding, availableSpaceForTitle: availableSpaceForTitle, numLinesLimit: numLinesLimit };
    },
    $getAxisSubtitle: function AxisPropsBuilder$GetAxisSubtitle(axisTableIndex, tickPlacementIndex) {
      if (this.$axisTable.UseAutoSubtitle[axisTableIndex]) {
        return (ss.isNullOrUndefined(this.$tickProducerOutput.PerHeaderMajorTickPlacement.DateTimeSubtitle) ? '' : this.$tickProducerOutput.PerHeaderMajorTickPlacement.DateTimeSubtitle[tickPlacementIndex]);
      }
      else {
        return (ss.isNullOrUndefined(this.$axisTable.AxisSubtitle) ? '' : this.$axisTable.AxisSubtitle[axisTableIndex]);
      }
    },
    $getShowSortIndicator: function AxisPropsBuilder$GetShowSortIndicator(axisTableIndex) {
      if (ss.isNullOrUndefined(this.$axisTable.HasSortIndicator)) {
        return false;
      }
      return this.$axisTable.HasSortIndicator[axisTableIndex];
    },
    $getSortIndicatorDirection: function AxisPropsBuilder$GetSortIndicatorDirection(axisTableIndex) {
      if (ss.isNullOrUndefined(this.$axisTable.SortDirection)) {
        return 'asc';
      }
      return ((this.$axisTable.SortDirection[axisTableIndex] === 0) ? 'asc' : 'desc');
    },
    $getSortIndicatorClassName: function AxisPropsBuilder$GetSortIndicatorClassName(axisTableIndex) {
      if (!this.$getShowSortIndicator(axisTableIndex)) {
        return '';
      }
      var sortDirection = this.$getSortIndicatorDirection(axisTableIndex);
      return ((sortDirection === 'asc') ? 'sortIndLeft' : 'sortIndRight');
    },
    $getCanShowHoverSortIndicator: function AxisPropsBuilder$GetCanShowHoverSortIndicator(axisTableIndex) {
      if (ss.isNullOrUndefined(this.$axisTable.CanShowHoverSortIndicator)) {
        return false;
      }
      return this.$axisTable.CanShowHoverSortIndicator[axisTableIndex];
    },
    $getSortIndicatorTooltip: function AxisPropsBuilder$GetSortIndicatorTooltip(axisTableIndex) {
      if (ss.isNullOrUndefined(this.$axisTable.SortIndicatorTooltip)) {
        return '';
      }
      return this.$axisTable.SortIndicatorTooltip[axisTableIndex];
    },
    $getTitleStyle: function AxisPropsBuilder$GetTitleStyle(axisTableIndex, isSelected) {
      var styleIndex = this.$axisTable.TitleStyleIndex[axisTableIndex];
      var titleStyleTuple = this.$titleStyles[styleIndex];
      var result = tab.TupleDatastoreConversions.textStyleFromTuple(titleStyleTuple);
      if (isSelected && ss.isValue(result) && ss.isValue(this.$axisStyles.SelectedTextColor)) {
        result.text_style_color = this.$axisStyles.SelectedTextColor[styleIndex];
      }
      return result;
    },
    $computeAvailablePerpendicularSpaceForTitleWithoutPadding: function AxisPropsBuilder$ComputeAvailablePerpendicularSpaceForTitleWithoutPadding(labelProps) {
      if (ss.isNullOrUndefined(labelProps)) {
        return this.$orientedSize.get_perpendicular();
      }
      var labelSizePerpendicularToAxis = this.$computeMaxPerpendicularLabelSize(labelProps);
      return this.$orientedSize.get_perpendicular() - labelSizePerpendicularToAxis - labelProps.majorTickSize;
    },
    $computeMaxPerpendicularLabelSize: function AxisPropsBuilder$ComputeMaxPerpendicularLabelSize(labelProps) {
      var isLabelHorizontal = labelProps.tickLabelStyle.text_orientation === 0;
      var isLabelPerpendicularToAxis = !!(this.$isHorizontal ^ isLabelHorizontal);
      if (isLabelPerpendicularToAxis) {
        return _.reduce(labelProps.measuredLabelWidths, function(maxWidth, labelWidth) {
          return Math.max(maxWidth, labelWidth);
        }, 0);
      }
      return labelProps.measuredLabelHeight;
    },
    $getMeasuredLabelFontHeight: function AxisPropsBuilder$GetMeasuredLabelFontHeight(tickPlacementIndex) {
      if (ss.isNullOrUndefined(this.$tickProducerOutput.PerHeaderMajorTickPlacement) || ss.isNullOrUndefined(this.$tickProducerOutput.PerHeaderMajorTickPlacement.LabelStyleIndex) || ss.isNullOrUndefined(this.$tickProducerOutput.FontMetrics)) {
        return 0;
      }
      var styleIndex = this.$tickProducerOutput.PerHeaderMajorTickPlacement.LabelStyleIndex[tickPlacementIndex];
      var labelFontMetricsTuple = this.$tickProducerOutput.FontMetrics[styleIndex];
      return Math.ceil(ss.unbox(ss.cast(labelFontMetricsTuple[0], Number)));
    },
    $getMeasuredTitleFontHeight: function AxisPropsBuilder$GetMeasuredTitleFontHeight(axisTableIndex) {
      if (ss.isNullOrUndefined(this.$axisTable.TitleStyleIndex) || ss.isNullOrUndefined(this.$titleFontMetrics)) {
        return 0;
      }
      var styleIndex = this.$axisTable.TitleStyleIndex[axisTableIndex];
      var titleFontMeticsTuple = this.$titleFontMetrics[styleIndex];
      return Math.ceil(ss.unbox(ss.cast(titleFontMeticsTuple[0], Number)));
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisResizerComponent
  var $tab_AxisResizerComponent = global.tab.AxisResizerComponent = ss.mkType($asm, 'tab.AxisResizerComponent', function(props) {
    this.$boundAttachDragSource = null;
    this.$boundElementRef = null;
    this.$resizerObject = null;
    this.$offsetBase = 0;
    this.$isHorizontal = false;
    spiff.PureRenderComponent.call(this, props);
    this.$isHorizontal = tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation);
    this.$boundAttachDragSource = spiff.ReactRefs.attachDragSource(ss.mkdel(this, function() {
      return this;
    }));
    this.$boundElementRef = ss.mkdel(this, function(e) {
      this.$boundAttachDragSource(e);
      this.$resizerObject = $(e);
    });
  }, {
    render: function AxisResizerComponent$Render() {
      var resizerOrigin = this.$getResizerOrigin();
      var resizerLineStyle = this.$getResizerLineStyle(this.$getResizerLineSize(), this.$getResizerLineOrigin(resizerOrigin));
      var resizerLine = spiff.DOMElements.div({ className: 'tab-vizResizerLine', style: resizerLineStyle }, '');
      var resizerStyle = this.$getResizerStyle(this.$getResizerSize(), resizerOrigin);
      return spiff.DOMElements.div({ className: 'tab-vizAxisResizer', style: resizerStyle, ref: this.$boundElementRef }, resizerLine);
    },
    get_resizerObject: function AxisResizerComponent$get_ResizerObject() {
      return this.$resizerObject;
    },
    $shouldResizerBeBelowComponent: function AxisResizerComponent$ShouldResizerBeBelowComponent() {
      return this.props.sceneMarginLocation === 0 || this.props.sceneMarginLocation === 3;
    },
    $getResizerLineSize: function AxisResizerComponent$GetResizerLineSize() {
      var pixelSize = (this.$isHorizontal ? this.props.sceneMarginViewportSize.w : this.props.sceneMarginViewportSize.h);
      return { w: (!this.$isHorizontal ? 1 : pixelSize), h: (!this.$isHorizontal ? pixelSize : 1) };
    },
    $getResizerLineOrigin: function AxisResizerComponent$GetResizerLineOrigin(resizerOrigin) {
      var resizerWidth = 2;
      if (!this.$isHorizontal) {
        return { x: resizerOrigin.x + resizerWidth, y: 0 };
      }
      else {
        return { x: 0, y: resizerOrigin.y + resizerWidth };
      }
    },
    $getResizerSize: function AxisResizerComponent$GetResizerSize() {
      var resizerWidth = 2 * 2;
      var pixelSize = (this.$isHorizontal ? this.props.sceneMarginViewportSize.w : this.props.sceneMarginViewportSize.h);
      return { w: (!this.$isHorizontal ? resizerWidth : pixelSize), h: (!this.$isHorizontal ? pixelSize : resizerWidth) };
    },
    $getResizerOrigin: function AxisResizerComponent$GetResizerOrigin() {
      var resizerWidth = 2;
      var pixelSize = (!this.$isHorizontal ? this.props.sceneMarginViewportSize.w : this.props.sceneMarginViewportSize.h);
      var left = 0;
      var top = 0;
      if (!this.$isHorizontal) {
        left += (this.$shouldResizerBeBelowComponent() ? pixelSize : 0);
        return { x: left - resizerWidth, y: top };
      }
      else {
        top += (this.$shouldResizerBeBelowComponent() ? pixelSize : 0);
        return { x: left, y: top - resizerWidth };
      }
    },
    $getResizerStyle: function AxisResizerComponent$GetResizerStyle(size, origin) {
      var style = { width: size.w, height: size.h, left: origin.x, top: origin.y, backgroundColor: 'transparent', position: 'absolute', cursor: (!this.$isHorizontal ? 'ew-resize' : 'ns-resize') };
      return style;
    },
    $getResizerLineStyle: function AxisResizerComponent$GetResizerLineStyle(size, origin) {
      var style = { left: origin.x, top: origin.y, opacity: 0, border: 'none' };
      if (!this.$isHorizontal) {
        style.width = '0px';
        style.height = size.h;
        style.borderRight = '1px dotted';
      }
      else {
        style.width = size.w;
        style.height = '0px';
        style.borderBottom = '1px dotted';
      }
      return style;
    },
    $createDragInstance: function AxisResizerComponent$CreateDragInstance(e) {
      return new spiff.MoveDragInstance($(e), ss.mkdel(this, this.onMove), ss.mkdel(this, this.onDrop), null);
    },
    acceptsDragType: function AxisResizerComponent$AcceptsDragType() {
      return 1;
    },
    startDrag: function AxisResizerComponent$StartDrag(e) {
      if (!this.$isHorizontal) {
        this.$offsetBase = tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').offset().left);
        this.updateResizerXPosition(this.$calculateXOffset(e.pageX), e.pageX);
      }
      else {
        this.$offsetBase = tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').offset().top);
        this.updateResizerYPosition(this.$calculateYOffset(e.pageY), e.pageY);
      }
      return this.$createDragInstance(e.target);
    },
    onMove: function AxisResizerComponent$OnMove(e) {
      this.$resizerObject.children('.' + 'tab-vizResizerLine').css('opacity', 1);
      if (!this.$isHorizontal) {
        this.updateResizerXPosition(this.$calculateXOffset(e.pageX), e.pageX);
      }
      else {
        this.updateResizerYPosition(this.$calculateYOffset(e.pageY), e.pageY);
      }
    },
    onDrop: function AxisResizerComponent$OnDrop(e) {
      this.$resizerObject.children('.' + 'tab-vizResizerLine').css('opacity', 0);
      var sizeDifference = (!this.$isHorizontal ? this.calculateXSizeDifference(e.pageX) : this.calculateYSizeDifference(e.pageY));
      if ($tab_ResizerConstants.isSizeDifferenceOverThreshold(sizeDifference)) {
        this.props.sendAxisResizeCommand(this.props.foldState === 1, sizeDifference);
      }
    },
    updateResizerYPosition: function AxisResizerComponent$UpdateResizerYPosition(currentOffset, pageY) {
      var isReduced = currentOffset < 0;
      var dragY = pageY - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').height()), 2);
      if (Math.abs(currentOffset) <= 2) {
        var minOffset = (isReduced ? -2 : 2);
        dragY = this.$offsetBase + minOffset;
      }
      if (Math.abs(currentOffset) >= 100) {
        var maxOffset = (isReduced ? -100 : 100);
        dragY = this.$offsetBase + maxOffset;
      }
      var offset = this.$resizerObject.children('.' + 'tab-vizResizerLine').offset();
      this.$resizerObject.children('.' + 'tab-vizResizerLine').offset({ left: offset.left, top: dragY });
    },
    updateResizerXPosition: function AxisResizerComponent$UpdateResizerXPosition(currentOffset, pageX) {
      var isReduced = currentOffset < 0;
      var dragX = pageX - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').width()), 2);
      if (Math.abs(currentOffset) <= 2) {
        var minOffset = (isReduced ? -2 : 2);
        dragX = this.$offsetBase + minOffset;
      }
      if (Math.abs(currentOffset) >= 100) {
        var maxOffset = (isReduced ? -100 : 100);
        dragX = this.$offsetBase + maxOffset;
      }
      var offset = this.$resizerObject.children('.' + 'tab-vizResizerLine').offset();
      this.$resizerObject.children('.' + 'tab-vizResizerLine').offset({ left: dragX, top: offset.top });
    },
    $calculateYOffset: function AxisResizerComponent$CalculateYOffset(pageY) {
      var dragY = pageY;
      return dragY - this.$offsetBase;
    },
    $calculateXOffset: function AxisResizerComponent$CalculateXOffset(pageX) {
      var dragX = pageX;
      return dragX - this.$offsetBase;
    },
    calculateYSizeDifference: function AxisResizerComponent$CalculateYSizeDifference(pageY) {
      var dragY = pageY - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').height()), 2);
      var dragDifference = dragY - this.$offsetBase;
      var isReduced = (this.$shouldResizerBeBelowComponent() ? (dragDifference < 0) : (dragDifference >= 0));
      var difference = Math.min(Math.max(Math.abs(dragDifference), 2), 100);
      return (isReduced ? -difference : difference);
    },
    calculateXSizeDifference: function AxisResizerComponent$CalculateXSizeDifference(pageX) {
      var dragX = pageX - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').width()), 2);
      var dragDifference = dragX - this.$offsetBase;
      var isReduced = (this.$shouldResizerBeBelowComponent() ? (dragDifference < 0) : (dragDifference >= 0));
      var difference = Math.min(Math.max(Math.abs(dragDifference), 2), 100);
      return (isReduced ? -difference : difference);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisResizerProps
  var $tab_AxisResizerProps = global.tab.AxisResizerProps = ss.mkType($asm, 'tab.AxisResizerProps', function() {
    this.sceneMarginLocation = 0;
    this.sendAxisResizeCommand = null;
    this.sceneMarginViewportSize = null;
    this.foldState = 0;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisSortIndicator
  var $tab_AxisSortIndicator = global.tab.AxisSortIndicator = ss.mkType($asm, 'tab.AxisSortIndicator', function(axisProps) {
    this.$paddingBetweenTitleAndIndicator = 4;
    this.$persistentSortIndicatorClass = null;
    this.$isAxisHorizontal = false;
    this.$perpendicularSizeOfTitle = 0;
    this.$alongAxisPixelSize = 0;
    this.$pixelSizePerpendicularToAxis = 0;
    this.$axisLocation = 0;
    this.$canShowHoverIndicator = false;
    this.$position = null;
    this.$isHoverIndicator = false;
    this.$isHoverIndicator = false;
    this.$position = null;
    this.$canShowHoverIndicator = axisProps.canShowHoverSortIndicator;
    this.$persistentSortIndicatorClass = axisProps.sortIndicatorClassName;
    this.$isAxisHorizontal = tab.SceneMarginModel.isHorizontal(axisProps.sceneMarginLocation);
    this.$alongAxisPixelSize = axisProps.alongAxisPixelSize;
    this.$pixelSizePerpendicularToAxis = axisProps.pixelSize;
    this.$axisLocation = axisProps.sceneMarginLocation;
    this.$perpendicularSizeOfTitle = axisProps.axisTitle.availableSpaceForTitle;
  }, {
    set_isHoverIndicator: function AxisSortIndicator$set_IsHoverIndicator(value) {
      this.$isHoverIndicator = value;
    },
    updateIndicatorPosition: function AxisSortIndicator$UpdateIndicatorPosition(endOfTitle) {
      if (ss.isNullOrUndefined(endOfTitle)) {
        this.$position = this.$placeHoverIndicatorWhereThereIsRoom();
      }
      else {
        this.$position = this.$placeSortIndicator(endOfTitle);
      }
    },
    shouldShowSortIndicator: function AxisSortIndicator$ShouldShowSortIndicator() {
      if (ss.isNullOrUndefined(this.$position)) {
        return false;
      }
      if (this.$isHoverIndicator) {
        return this.$canShowHoverIndicator;
      }
      return this.$canShowPersistentSortIndicator();
    },
    getSortIndicatorClassName: function AxisSortIndicator$GetSortIndicatorClassName() {
      if (this.$isHoverIndicator) {
        return this.$getHoverSortIndicatorClassName();
      }
      return this.$persistentSortIndicatorClass;
    },
    getSortIndicatorCss: function AxisSortIndicator$GetSortIndicatorCss() {
      var style = { position: 'absolute' };
      var perpendicularOffsetFromEdge = this.$position.perpendicular + 'px';
      switch (this.$axisLocation) {
        case 3: {
          style.left = perpendicularOffsetFromEdge;
          break;
        }
        case 2: {
          style.right = perpendicularOffsetFromEdge;
          break;
        }
        case 1: {
          style.bottom = perpendicularOffsetFromEdge;
          break;
        }
        case 0: {
          style.top = perpendicularOffsetFromEdge;
          break;
        }
      }
      var alongAxisPosition = this.$position.along + 'px';
      if (this.$isAxisHorizontal) {
        style.transform = 'rotate(90deg)';
        style.left = alongAxisPosition;
      }
      else {
        style.bottom = alongAxisPosition;
      }
      return style;
    },
    $canShowPersistentSortIndicator: function AxisSortIndicator$CanShowPersistentSortIndicator() {
      if (this.$persistentSortIndicatorClass === '') {
        return false;
      }
      return this.$canFitPersistentSortIndicator();
    },
    $canFitPersistentSortIndicator: function AxisSortIndicator$CanFitPersistentSortIndicator() {
      if (this.$perpendicularSizeOfTitle < $tab_AxisSortIndicator.sortIndicatorSize) {
        return false;
      }
      var indicatorFarEdge = this.$position.along + $tab_AxisSortIndicator.sortIndicatorSize;
      return indicatorFarEdge < this.$alongAxisPixelSize;
    },
    $getHoverSortIndicatorClassName: function AxisSortIndicator$GetHoverSortIndicatorClassName() {
      if (this.$persistentSortIndicatorClass === 'sortIndLeft') {
        return 'sortIndSolidLeft';
      }
      else if (this.$persistentSortIndicatorClass === 'sortIndRight') {
        return 'sortIndSolidRight';
      }
      return 'sortIndSolidRight';
    },
    $placeSortIndicator: function AxisSortIndicator$PlaceSortIndicator(endOfTitle) {
      if (this.$doesIndicatorFitAlongAxis(endOfTitle)) {
        return this.$placeSortIndicatorAlongAxis(endOfTitle);
      }
      return this.$placeHoverIndicatorWhereThereIsRoom();
    },
    $doesIndicatorFitAlongAxis: function AxisSortIndicator$DoesIndicatorFitAlongAxis(endOfTitle) {
      if (this.$isAxisHorizontal) {
        var farEdgeOfIndicator = endOfTitle.x + this.$paddingBetweenTitleAndIndicator + $tab_AxisSortIndicator.sortIndicatorSize;
        return farEdgeOfIndicator <= this.$alongAxisPixelSize;
      }
      else {
        var farEdgeOfIndicator1 = endOfTitle.y + this.$paddingBetweenTitleAndIndicator + $tab_AxisSortIndicator.sortIndicatorSize;
        return farEdgeOfIndicator1 <= this.$alongAxisPixelSize;
      }
    },
    $placeSortIndicatorAlongAxis: function AxisSortIndicator$PlaceSortIndicatorAlongAxis(endOfTitle) {
      if (this.$isAxisHorizontal) {
        var $t1 = new $tab_IndicatorPosition();
        $t1.along = endOfTitle.x + this.$paddingBetweenTitleAndIndicator;
        $t1.perpendicular = endOfTitle.y;
        return $t1;
      }
      var $t2 = new $tab_IndicatorPosition();
      $t2.along = endOfTitle.y + this.$paddingBetweenTitleAndIndicator;
      $t2.perpendicular = endOfTitle.x;
      return $t2;
    },
    $placeHoverIndicatorWhereThereIsRoom: function AxisSortIndicator$PlaceHoverIndicatorWhereThereIsRoom() {
      if (this.$isHoverIndicator) {
        var indicatorCenter = ss.idiv($tab_AxisSortIndicator.sortIndicatorSize, 2);
        var $t1 = new $tab_IndicatorPosition();
        $t1.along = ss.idiv(this.$alongAxisPixelSize, 2) - indicatorCenter;
        $t1.perpendicular = ss.idiv(this.$pixelSizePerpendicularToAxis, 2) - indicatorCenter;
        return $t1;
      }
      return null;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.AxisTitleComponent
  var $tab_AxisTitleComponent = global.tab.AxisTitleComponent = ss.mkType($asm, 'tab.AxisTitleComponent', function(props) {
    spiff.PureRenderComponent.call(this, props);
  }, {
    render: function AxisTitleComponent$Render() {
      return spiff.DOMElements.div({ className: this.$getTitleContainerClass(), style: this.$getTitleContainerStyle() }, this.$getTitleDiv());
    },
    $getTitleDiv: function AxisTitleComponent$GetTitleDiv() {
      return spiff.DOMElements.div({ className: 'tab-vizAxisTitle', style: this.$getTitleStyle() }, this.$getTitle());
    },
    $getTitle: function AxisTitleComponent$GetTitle() {
      if (!ss.isNullOrEmptyString(this.props.subtitle)) {
        return ss.formatString('{0} [{1}]', this.props.title, this.props.subtitle);
      }
      return this.props.title;
    },
    $getTitleStyle: function AxisTitleComponent$GetTitleStyle() {
      if (BrowserSupport.BrowserSupport.IsIE()) {
        return this.$getTitleStyleForIE();
      }
      var style = this.props.titleStyle;
      var titleStyle = $tab_TextStyleHelper.getCssFromTextStyle(style);
      titleStyle.color = tab.ColorModel.fromArgbInt(style.text_style_color).toRgbHex();
      titleStyle.textDecorationLine = ((tab.EnumConversions.textDecorationFromInt(style.text_decoration) === 'text-decoration-underline') ? 'underline' : 'none');
      titleStyle.maxWidth = this.props.alongAxisPixelSize + 'px';
      titleStyle.maxHeight = this.props.availableSpaceForTitle + 'px';
      if (this.props.numLinesLimit <= 1) {
        titleStyle.textOverflow = 'ellipsis';
        titleStyle.whiteSpace = 'nowrap';
      }
      return titleStyle;
    },
    $getTitleContainerClass: function AxisTitleComponent$GetTitleContainerClass() {
      if (this.props.numLinesLimit <= 1 || BrowserSupport.BrowserSupport.IsIE()) {
        return $tab_AxisTitleComponent.singleLineAxisTitleContainerClass;
      }
      return $tab_AxisTitleComponent.multiLineAxisTitleContainerClass;
    },
    $getTitleContainerStyle: function AxisTitleComponent$GetTitleContainerStyle() {
      if (BrowserSupport.BrowserSupport.IsIE()) {
        return this.$getTitleContainerStyleForIE();
      }
      var style = { width: this.props.alongAxisPixelSize + 'px', maxHeight: this.props.availableSpaceForTitle + 'px' };
      this.$positionTitleContainerWithinAxis(style);
      if (this.props.numLinesLimit > 1) {
        style.WebkitLineClamp = this.props.numLinesLimit.toString();
      }
      return style;
    },
    $positionTitleContainerWithinAxis: function AxisTitleComponent$PositionTitleContainerWithinAxis(style) {
      this.$rotateAndAlignContainerForVerticalAxes(style);
      var offsetFromEdge = this.props.titlePadding + 'px';
      switch (this.props.sceneMarginLocation) {
        case 3: {
          style.left = offsetFromEdge;
          break;
        }
        case 2: {
          style.right = offsetFromEdge;
          break;
        }
        case 1: {
          style.bottom = offsetFromEdge;
          break;
        }
        case 0: {
          style.top = offsetFromEdge;
          break;
        }
      }
    },
    $rotateAndAlignContainerForVerticalAxes: function AxisTitleComponent$RotateAndAlignContainerForVerticalAxes(style) {
      if (this.props.sceneMarginLocation === 3) {
        style.transform = 'translate(-50%, -50%) rotate(-90deg) translate(-50%, 50%)';
      }
      else if (this.props.sceneMarginLocation === 2) {
        style.transform = 'translate(50%, -50%) rotate(-90deg) translate(-50%, -50%)';
      }
    },
    $getTitleStyleForIE: function AxisTitleComponent$GetTitleStyleForIE() {
      var style = this.props.titleStyle;
      var titleStyle = $tab_TextStyleHelper.getCssFromTextStyle(style);
      titleStyle.color = tab.ColorModel.fromArgbInt(style.text_style_color).toRgbHex();
      titleStyle.textDecorationLine = ((tab.EnumConversions.textDecorationFromInt(style.text_decoration) === 'text-decoration-underline') ? 'underline' : 'none');
      if (tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        titleStyle.maxWidth = this.props.alongAxisPixelSize + 'px';
      }
      else {
        titleStyle.transform = 'rotate(-90deg)';
        titleStyle.maxHeight = this.props.alongAxisPixelSize + 'px';
      }
      titleStyle.textOverflow = 'ellipsis';
      titleStyle.whiteSpace = 'nowrap';
      return titleStyle;
    },
    $getTitleContainerStyleForIE: function AxisTitleComponent$GetTitleContainerStyleForIE() {
      var style = {};
      if (tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        style.width = this.props.alongAxisPixelSize + 'px';
        style.maxHeight = this.props.availableSpaceForTitle + 'px';
      }
      else {
        style.height = this.props.alongAxisPixelSize + 'px';
        style.maxWidth = this.props.availableSpaceForTitle + 'px';
        style.flexDirection = 'column';
      }
      var offsetFromEdge = this.props.titlePadding + 'px';
      switch (this.props.sceneMarginLocation) {
        case 3: {
          style.left = offsetFromEdge;
          break;
        }
        case 2: {
          style.right = offsetFromEdge;
          break;
        }
        case 1: {
          style.bottom = offsetFromEdge;
          break;
        }
        case 0: {
          style.top = offsetFromEdge;
          break;
        }
      }
      return style;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.BaseHolderViewModel<TProps>
  var $tab_BaseHolderViewModel$1 = global.tab.BaseHolderViewModel$1 = ss.mkType($asm, 'tab.BaseHolderViewModel$1', function(TProps) {
    var $type = ss.registerGenericClassInstance($tab_BaseHolderViewModel$1, [TProps], function(sceneMarginModel, marginRow, sceneMarginSelection) {
      this.location = 0;
      this.marginRow = 0;
      this.level = 0;
      this.sceneMarginSelection = null;
      this.pixelOffset = 0;
      this.pixelSize = 0;
      this.stretchedPixelSize = 0;
      this.alongAxisPixelOffset = null;
      this.alongAxisPixelSize = null;
      this.$sceneMarginLayout = null;
      this.orientedSize = null;
      this.$sceneMarginViewportSize = { w: 0, h: 0 };
      this.$page = 0;
      this.$sceneMarginModel = null;
      ss.makeGenericType(spiff.BaseReactViewModel$1, [TProps]).call(this);
      this.$sceneMarginModel = sceneMarginModel;
      this.location = sceneMarginModel.get_sceneMarginLocation();
      this.marginRow = marginRow;
      this.$sceneMarginLayout = sceneMarginModel.get_sceneMarginLayout();
      this.level = this.$sceneMarginLayout.HeaderDepth[this.marginRow];
      this.pixelOffset = this.$sceneMarginLayout.PixelOffset[this.marginRow];
      this.pixelSize = this.$sceneMarginLayout.PixelSize[this.marginRow];
      this.stretchedPixelSize = this.$sceneMarginLayout.StretchedPixelSize[this.marginRow];
      this.sceneMarginSelection = sceneMarginSelection;
      this.$observeSceneMarginChange();
      this.$observeSelectionChange();
      var layoutTable = sceneMarginModel.get_layoutTable();
      var levelToFilterOn = this.$getLevelToFilterOn();
      this.alongAxisPixelOffset = _.filter(layoutTable.AlongDirectionPixelOffset, function(val, index) {
        return layoutTable.Level[index] === levelToFilterOn;
      });
      this.alongAxisPixelSize = _.filter(layoutTable.AlongDirectionPixelSize, function(val1, index1) {
        return layoutTable.Level[index1] === levelToFilterOn;
      });
      var $t1 = new $tab_OrientedSize(this.isHorizontal());
      $t1.set_along(this.$getHolderAlongSize());
      $t1.set_perpendicular(this.pixelSize);
      this.orientedSize = $t1;
    }, {
      get_sceneMarginViewportSize: function BaseHolderViewModel$get_SceneMarginViewportSize() {
        return this.$sceneMarginViewportSize;
      },
      set_sceneMarginViewportSize: function BaseHolderViewModel$set_SceneMarginViewportSize(value) {
        if (!tab.SizeUtil.equals(this.$sceneMarginViewportSize, value)) {
          this.$sceneMarginViewportSize = value;
          this.incrementProps();
        }
      },
      get_page: function BaseHolderViewModel$get_Page() {
        return this.$page;
      },
      set_page: function BaseHolderViewModel$set_Page(value) {
        if (this.$page !== value) {
          this.$page = value;
          this.incrementProps();
        }
      },
      isHorizontal: function BaseHolderViewModel$IsHorizontal() {
        return this.$sceneMarginModel.isHorizontal();
      },
      $observeSceneMarginChange: function BaseHolderViewModel$ObserveSceneMarginChange() {
        var changeHandler = ss.mkdel(this, this.incrementProps);
        this.$sceneMarginModel.add_newSceneMargin(changeHandler);
        this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
          this.$sceneMarginModel.remove_newSceneMargin(changeHandler);
        })));
      },
      $observeSelectionChange: function BaseHolderViewModel$ObserveSelectionChange() {
        var selectionChanged = ss.mkdel(this, this.incrementProps);
        this.sceneMarginSelection.get_selectionModel().add_newSelection(selectionChanged);
        this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
          this.sceneMarginSelection.get_selectionModel().remove_newSelection(selectionChanged);
        })));
      },
      observeBrushingChange: function BaseHolderViewModel$ObserveBrushingChange() {
        var brushingChanged = ss.mkdel(this, this.incrementProps);
        this.sceneMarginSelection.get_brushingModel().add_newSelection(brushingChanged);
        this.disposables.add$1(new tab.CallOnDispose(ss.mkdel(this, function() {
          this.sceneMarginSelection.get_brushingModel().remove_newSelection(brushingChanged);
        })));
      },
      isHolderSelected: function BaseHolderViewModel$IsHolderSelected(index) {
        return this.sceneMarginSelection.isNodeSelected(this.level, index);
      },
      makeOrientedSize: function BaseHolderViewModel$MakeOrientedSize(along, perpendicular) {
        return $tab_OrientedSize.makeOrientedSize(along, perpendicular, this.isHorizontal());
      },
      $getLevelToFilterOn: function BaseHolderViewModel$GetLevelToFilterOn() {
        if (this.location === 1) {
          if (this.$sceneMarginLayout.ElementType[this.marginRow] === 2) {
            return this.level - 1;
          }
        }
        return this.level;
      },
      $getHolderAlongSize: function BaseHolderViewModel$GetHolderAlongSize() {
        var indexToLastPixelOffset = this.alongAxisPixelOffset.length - 1;
        var indexToLastPixelSize = this.alongAxisPixelSize.length - 1;
        if (indexToLastPixelOffset < 0 || indexToLastPixelSize < 0) {
          return 0;
        }
        var pixelRangeMax = this.alongAxisPixelOffset[indexToLastPixelOffset] + this.alongAxisPixelSize[indexToLastPixelSize];
        var pixelRangeMin = this.alongAxisPixelOffset[0];
        return pixelRangeMax - pixelRangeMin;
      }
    }, null, function() {
      return ss.makeGenericType(spiff.BaseReactViewModel$1, [TProps]);
    }, function() {
      return [tab.IViewModel, ss.IDisposable, ss.makeGenericType(spiff.IPropsProvider$1, [TProps])];
    });
    return $type;
  });
  ss.initGenericClass($tab_BaseHolderViewModel$1, 1);
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.BaseSceneMarginElement
  var $tab_BaseSceneMarginElement = global.tab.BaseSceneMarginElement = ss.mkType($asm, 'tab.BaseSceneMarginElement', function(domNode, domNodeForInteraction, viewModel) {
    this.$docSize = { w: 0, h: 0 };
    this.actualViewSize = { w: 0, h: 0 };
    this.scrollPos = { x: 0, y: 0 };
    this.reactView = null;
    this.reactViewForInteraction = null;
    this.domNode = null;
    this.domNodeForInteraction = null;
    this.viewModel = null;
    this.$1$LoadCompleteField = null;
    this.domNode = domNode;
    this.domNodeForInteraction = domNodeForInteraction;
    this.viewModel = viewModel;
  }, {
    add_loadComplete: function BaseSceneMarginElement$add_LoadComplete(value) {
      this.$1$LoadCompleteField = ss.delegateCombine(this.$1$LoadCompleteField, value);
    },
    remove_loadComplete: function BaseSceneMarginElement$remove_LoadComplete(value) {
      this.$1$LoadCompleteField = ss.delegateRemove(this.$1$LoadCompleteField, value);
    },
    get_viewModel: function BaseSceneMarginElement$get_ViewModel() {
      return this.viewModel;
    },
    get_canScrollX: function BaseSceneMarginElement$get_CanScrollX() {
      return true;
    },
    get_canScrollY: function BaseSceneMarginElement$get_CanScrollY() {
      return true;
    },
    get_docSize: function BaseSceneMarginElement$get_DocSize() {
      return this.$docSize;
    },
    get_actualViewSize: function BaseSceneMarginElement$get_ActualViewSize() {
      return this.actualViewSize;
    },
    set_actualViewSize: function BaseSceneMarginElement$set_ActualViewSize(value) {
      this.actualViewSize = value;
      this.resize();
    },
    get_effectiveViewSize: function BaseSceneMarginElement$get_EffectiveViewSize() {
      return this.actualViewSize;
    },
    get_hasContent: function BaseSceneMarginElement$get_HasContent() {
      return true;
    },
    get_scrollPos: function BaseSceneMarginElement$get_ScrollPos() {
      return this.scrollPos;
    },
    set_scrollPos: function BaseSceneMarginElement$set_ScrollPos(value) {
      this.scrollPos = value;
      this.updateScrollPos();
    },
    setXPos: function BaseSceneMarginElement$SetXPos(xPos) {
      var pos = this.get_scrollPos();
      this.set_scrollPos({ x: xPos, y: pos.y });
      this.reactView.get_rootElement().children().scrollLeft(xPos);
      if (ss.isValue(this.reactViewForInteraction)) {
        this.reactViewForInteraction.get_rootElement().children().scrollLeft(xPos);
      }
    },
    setYPos: function BaseSceneMarginElement$SetYPos(yPos) {
      var pos = this.get_scrollPos();
      this.set_scrollPos({ x: pos.x, y: yPos });
      this.reactView.get_rootElement().children().scrollTop(yPos);
      if (ss.isValue(this.reactViewForInteraction)) {
        this.reactViewForInteraction.get_rootElement().children().scrollTop(yPos);
      }
    },
    destroy: function BaseSceneMarginElement$Destroy() {
      this.reactView.dispose();
      if (ss.isValue(this.reactViewForInteraction)) {
        this.reactViewForInteraction.dispose();
      }
    },
    refreshImages: function BaseSceneMarginElement$RefreshImages(tileCacheUrl) {
      tab.Log.get(this).warn('Base scene margin element has no images to refresh', []);
    },
    reset: function BaseSceneMarginElement$Reset(newGeometry, newTileSize) {
      this.$docSize = newTileSize;
    },
    resize: null,
    updateScrollPos: null
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.BorderAttributes
  var $tab_BorderAttributes = global.tab.BorderAttributes = ss.mkType($asm, 'tab.BorderAttributes', function() {
    this.borderWidth = 0;
    this.borderStyle = 0;
    this.color = 0;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.BorderComponent
  var $tab_BorderComponent = global.tab.BorderComponent = ss.mkType($asm, 'tab.BorderComponent', function(props) {
    spiff.PureRenderComponent.call(this, props);
  }, {
    render: function BorderComponent$Render() {
      var borderLine = spiff.DOMElements.line(this.$getLineSvgProps());
      return spiff.DOMElements.svg({ className: 'tab-vizBorder', style: this.$getSvgCssStyles() }, borderLine);
    },
    $getSvgCssStyles: function BorderComponent$GetSvgCssStyles() {
      return { position: 'absolute', top: this.props.originPosition.y + 'px', left: this.props.originPosition.x + 'px', width: (this.props.isHorizontalLine ? this.props.length : $tab_BorderComponent.$svgWidth) + 'px', height: (this.props.isHorizontalLine ? $tab_BorderComponent.$svgWidth : this.props.length) + 'px', backgroundColor: 'transparent', pointerEvents: 'none' };
    },
    $getLineSvgProps: function BorderComponent$GetLineSvgProps() {
      var strokeWidth = this.$calcStrokeWidth(this.props.borderAttributes);
      var svgProps = { stroke: tab.ColorModel.fromArgbInt(this.props.borderAttributes.color).toRgbHex(), strokeWidth: strokeWidth, strokeDasharray: $tab_BorderComponent.$getDasharray(this.props.borderAttributes.borderStyle, strokeWidth), x1: 0, y1: 0, x2: (this.props.isHorizontalLine ? this.props.length : 0), y2: (this.props.isHorizontalLine ? 0 : (0 + this.props.length)), shapeRendering: $tab_BorderComponent.$crispEdges };
      return svgProps;
    },
    $calcStrokeWidth: function BorderComponent$CalcStrokeWidth(borderAttributes) {
      return ss.trunc(borderAttributes.borderWidth);
    }
  }, {
    $getDasharray: function BorderComponent$GetDasharray(borderStyle, strokeWidth) {
      switch (borderStyle) {
        case 0: {
          return null;
        }
        case 1: {
          return '';
        }
        case 2: {
          return $tab_BorderComponent.$getDashedPattern(strokeWidth);
        }
        case 3: {
          return strokeWidth + '';
        }
        default: {
          throw new ss.ArgumentOutOfRangeException();
        }
      }
    },
    $getDashedPattern: function BorderComponent$GetDashedPattern(strokeWidth) {
      var strokeGap = strokeWidth + 1;
      var strokeLength = strokeGap * 2;
      return ss.formatString('{0} {1}', strokeLength, strokeGap);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.BorderDataModel
  var $tab_BorderDataModel = global.tab.BorderDataModel = ss.mkType($asm, 'tab.BorderDataModel', function(defaultBorder, totalBorder, grandTotalBorder, customDivider, targetDepth, location) {
    this.$defaultBorder = null;
    this.$totalBorder = null;
    this.$grandTotalBorder = null;
    this.$customDivider = null;
    this.$hasCustomDividers = false;
    this.$hasDefaultBorders = false;
    this.$targetDepth = 0;
    this.$location = 0;
    this.$defaultBorder = defaultBorder;
    this.$totalBorder = totalBorder;
    this.$grandTotalBorder = grandTotalBorder;
    this.$customDivider = customDivider;
    this.$targetDepth = targetDepth;
    this.$hasCustomDividers = this.$customDivider.borderStyle !== 0;
    this.$hasDefaultBorders = this.$defaultBorder.borderStyle !== 0;
    this.$location = location;
  }, {
    getAxisDividerAttributes: function BorderDataModel$GetAxisDividerAttributes(nodeLevel) {
      if (ss.isNullOrUndefined(this.get_$divider()) && ss.isNullOrUndefined(this.get_$defaultBorder())) {
        return null;
      }
      if (nodeLevel <= this.$targetDepth && ss.isValue(this.get_$divider())) {
        return this.get_$divider();
      }
      return this.get_$defaultBorder();
    },
    getSceneMarginDividerAttributes: function BorderDataModel$GetSceneMarginDividerAttributes(nodeLevel, borderStartLevel) {
      return ((this.$location === 1) ? this.getBottomHeaderDividerAttributes(nodeLevel, borderStartLevel) : this.getAxisAndNonBottomHeaderDividers(borderStartLevel));
    },
    getBottomHeaderDividerAttributes: function BorderDataModel$GetBottomHeaderDividerAttributes(nodeLevel, borderStartLevel) {
      if (ss.isValue(this.get_$divider()) && borderStartLevel < this.$targetDepth) {
        return this.get_$divider();
      }
      if (ss.isValue(this.get_$defaultBorder()) && borderStartLevel < nodeLevel) {
        return this.get_$defaultBorder();
      }
      return null;
    },
    getAxisAndNonBottomHeaderDividers: function BorderDataModel$GetAxisAndNonBottomHeaderDividers(borderStartLevel) {
      if (borderStartLevel < this.$targetDepth && ss.isValue(this.get_$divider())) {
        return this.get_$divider();
      }
      return this.get_$defaultBorder();
    },
    get_totalBorder: function BorderDataModel$get_TotalBorder() {
      return this.$totalBorder;
    },
    get_grandTotalBorder: function BorderDataModel$get_GrandTotalBorder() {
      return this.$grandTotalBorder;
    },
    get_$divider: function BorderDataModel$get_Divider() {
      return (this.$hasCustomDividers ? this.$customDivider : this.get_$defaultBorder());
    },
    get_$defaultBorder: function BorderDataModel$get_DefaultBorder() {
      return (!this.$hasDefaultBorders ? null : this.$defaultBorder);
    },
    get_sideBorder: function BorderDataModel$get_SideBorder() {
      return this.get_$divider();
    },
    get_alongAxisBorder: function BorderDataModel$get_AlongAxisBorder() {
      return (!this.$hasDefaultBorders ? null : this.get_$defaultBorder());
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.BorderRenderer
  var $tab_BorderRenderer = global.tab.BorderRenderer = ss.mkType($asm, 'tab.BorderRenderer', null, null, {
    drawLine: function BorderRenderer$DrawLine(originPosition, length, borderAttributes, horizontal) {
      var borderProps = $tab_BorderRenderer.$getBorderProps(originPosition, length, borderAttributes, horizontal);
      return React.createElement($tab_BorderComponent, borderProps);
    },
    $getBorderProps: function BorderRenderer$GetBorderProps(originPosition, length, borderAttributes, isHorizontal) {
      var borderProps = { borderAttributes: borderAttributes, originPosition: originPosition, length: length, isHorizontalLine: isHorizontal };
      return borderProps;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.BorderStyle
  var $tab_BorderStyle = global.tab.BorderStyle = ss.mkEnum($asm, 'tab.BorderStyle', { linePatternNone: 0, linePatternSolid: 1, linePatternDashed: 2, linePatternDotted: 3 });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.CellResizerComponent
  var $tab_CellResizerComponent = global.tab.CellResizerComponent = ss.mkType($asm, 'tab.CellResizerComponent', function(props) {
    this.$boundAttachDragSource = null;
    this.$boundElementRef = null;
    this.$resizerObject = null;
    this.$offsetBase = 0;
    spiff.PureRenderComponent.call(this, props);
    this.$boundAttachDragSource = spiff.ReactRefs.attachDragSource(ss.mkdel(this, function() {
      return this;
    }));
    this.$boundElementRef = ss.mkdel(this, function(e) {
      this.$boundAttachDragSource(e);
      this.$resizerObject = $(e);
    });
  }, {
    render: function CellResizerComponent$Render() {
      var resizerOrigin = this.$getResizerOrigin();
      var resizerLineStyle = this.$getResizerLineStyle(this.$getResizerLineSize(), this.$getResizerLineOrigin(resizerOrigin));
      var resizerLine = spiff.DOMElements.div({ className: 'tab-vizResizerLine', style: resizerLineStyle }, '');
      var resizerStyle = this.$getResizerStyle(this.$getResizerSize(), resizerOrigin);
      return spiff.DOMElements.div({ className: 'tab-vizCellResizer', style: resizerStyle, ref: this.$boundElementRef }, resizerLine);
    },
    get_resizerObject: function CellResizerComponent$get_ResizerObject() {
      return this.$resizerObject;
    },
    $getResizerLineSize: function CellResizerComponent$GetResizerLineSize() {
      return { w: (this.props.isHorizontal ? 1 : this.props.width), h: (this.props.isHorizontal ? this.props.height : 1) };
    },
    $getResizerLineOrigin: function CellResizerComponent$GetResizerLineOrigin(resizerOrigin) {
      if (this.props.isHorizontal) {
        return { x: resizerOrigin.x + 2, y: resizerOrigin.y };
      }
      else {
        return { x: resizerOrigin.x, y: resizerOrigin.y + 2 };
      }
    },
    $getResizerSize: function CellResizerComponent$GetResizerSize() {
      var resizerWidth = (this.props.isLastHeaderElement ? 2 : (2 * 2));
      return { w: (this.props.isHorizontal ? resizerWidth : this.props.width), h: (this.props.isHorizontal ? this.props.height : resizerWidth) };
    },
    $getResizerOrigin: function CellResizerComponent$GetResizerOrigin() {
      var resizerWidth = 2;
      var left = this.props.left;
      var top = this.props.top;
      if (this.props.isHorizontal) {
        return { x: left + this.props.width - 2, y: top };
      }
      else {
        return { x: left, y: top + this.props.height - 2 };
      }
    },
    $getResizerStyle: function CellResizerComponent$GetResizerStyle(size, origin) {
      return { width: size.w + 'px', height: size.h + 'px', left: origin.x + 'px', top: origin.y + 'px', backgroundColor: 'transparent', position: 'absolute', cursor: (this.props.isHorizontal ? 'ew-resize' : 'ns-resize') };
    },
    $getResizerLineStyle: function CellResizerComponent$GetResizerLineStyle(size, origin) {
      var style = { left: (this.props.isHorizontal ? 2 : 0) + 'px', top: (this.props.isHorizontal ? 0 : 2) + 'px', opacity: 0, border: 'none' };
      if (this.props.isHorizontal) {
        style.width = '0px';
        style.height = size.h;
        style.borderRight = '1px dotted';
      }
      else {
        style.width = size.w;
        style.height = '0px';
        style.borderBottom = '1px dotted';
      }
      return style;
    },
    $createDragInstance: function CellResizerComponent$CreateDragInstance(e) {
      return new spiff.MoveDragInstance($(e), ss.mkdel(this, this.onMove), ss.mkdel(this, this.onDrop), null);
    },
    acceptsDragType: function CellResizerComponent$AcceptsDragType() {
      return 1;
    },
    startDrag: function CellResizerComponent$StartDrag(e) {
      if (this.props.isHorizontal) {
        this.$offsetBase = tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').offset().left);
        this.updateResizerXPosition(this.$calculateXOffset(e.pageX), e.pageX);
      }
      else {
        this.$offsetBase = tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').offset().top);
        this.updateResizerYPosition(this.$calculateYOffset(e.pageY), e.pageY);
      }
      return this.$createDragInstance(e.target);
    },
    onMove: function CellResizerComponent$OnMove(e) {
      this.$resizerObject.children('.' + 'tab-vizResizerLine').css('opacity', 1);
      if (this.props.isHorizontal) {
        this.updateResizerXPosition(this.$calculateXOffset(e.pageX), e.pageX);
      }
      else {
        this.updateResizerYPosition(this.$calculateYOffset(e.pageY), e.pageY);
      }
    },
    onDrop: function CellResizerComponent$OnDrop(e) {
      this.$resizerObject.children('.' + 'tab-vizResizerLine').css('opacity', 0);
      var sizeDifference = (this.props.isHorizontal ? this.calculateXSizeDifference(e.pageX) : this.calculateYSizeDifference(e.pageY));
      if ($tab_ResizerConstants.isSizeDifferenceOverThreshold(sizeDifference)) {
        var newSize = sizeDifference + (this.props.isHorizontal ? this.props.width : this.props.height);
        var newInnermostHeaderCellSize = ss.idiv(newSize, Math.max(1, this.props.numLeaves));
        this.props.sendCellResizeCommand(0, false, newInnermostHeaderCellSize);
      }
    },
    updateResizerYPosition: function CellResizerComponent$UpdateResizerYPosition(currentOffset, pageY) {
      var isReduced = currentOffset < 0;
      var dragY = pageY - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').height()), 2);
      if (Math.abs(currentOffset) <= 2) {
        var minOffset = (isReduced ? -2 : 2);
        dragY = this.$offsetBase + minOffset;
      }
      if (Math.abs(currentOffset) >= 100) {
        var maxOffset = (isReduced ? -100 : 100);
        dragY = this.$offsetBase + maxOffset;
      }
      var offset = this.$resizerObject.children('.' + 'tab-vizResizerLine').offset();
      this.$resizerObject.children('.' + 'tab-vizResizerLine').offset({ left: offset.left, top: dragY });
    },
    updateResizerXPosition: function CellResizerComponent$UpdateResizerXPosition(currentOffset, pageX) {
      var isReduced = currentOffset < 0;
      var dragX = pageX - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').width()), 2);
      if (Math.abs(currentOffset) <= 2) {
        var minOffset = (isReduced ? -2 : 2);
        dragX = this.$offsetBase + minOffset;
      }
      if (Math.abs(currentOffset) >= 100) {
        var maxOffset = (isReduced ? -100 : 100);
        dragX = this.$offsetBase + maxOffset;
      }
      var offset = this.$resizerObject.children('.' + 'tab-vizResizerLine').offset();
      this.$resizerObject.children('.' + 'tab-vizResizerLine').offset({ left: dragX, top: offset.top });
    },
    $calculateYOffset: function CellResizerComponent$CalculateYOffset(pageY) {
      var dragY = pageY;
      return dragY - this.$offsetBase;
    },
    $calculateXOffset: function CellResizerComponent$CalculateXOffset(pageX) {
      var dragX = pageX;
      return dragX - this.$offsetBase;
    },
    calculateYSizeDifference: function CellResizerComponent$CalculateYSizeDifference(pageY) {
      var dragY = pageY - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').height()), 2);
      var dragDifference = dragY - this.$offsetBase;
      var isReduced = dragDifference < 0;
      var difference = Math.min(Math.max(Math.abs(dragDifference), 2), 100);
      return (isReduced ? -difference : difference);
    },
    calculateXSizeDifference: function CellResizerComponent$CalculateXSizeDifference(pageX) {
      var dragX = pageX - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').width()), 2);
      var dragDifference = dragX - this.$offsetBase;
      var isReduced = dragDifference < 0;
      var difference = Math.min(Math.max(Math.abs(dragDifference), 2), 100);
      return (isReduced ? -difference : difference);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.CellResizerProps
  var $tab_CellResizerProps = global.tab.CellResizerProps = ss.mkType($asm, 'tab.CellResizerProps', function() {
    this.left = 0;
    this.top = 0;
    this.width = 0;
    this.height = 0;
    this.isHorizontal = false;
    this.isLastHeaderElement = false;
    this.numLeaves = 0;
    this.sendCellResizeCommand = null;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.DatastoreHeaderAdapter
  var $tab_DatastoreHeaderAdapter = global.tab.DatastoreHeaderAdapter = ss.mkType($asm, 'tab.DatastoreHeaderAdapter', function() {
  }, null, {
    buildStyleProps: function DatastoreHeaderAdapter$BuildStyleProps(style, index) {
      return { totalFillColor: tab.ColorModel.fromArgbInt(style.TotalFillColor[index]), selectedTextColor: tab.ColorModel.fromArgbInt(style.SelectedTextColor[index]), selectedFillColor: tab.ColorModel.fromArgbInt(style.SelectedFillColor[index]), subtotalFillColor: tab.ColorModel.fromArgbInt(style.SubtotalFillColor[index]), brushedColor: tab.ColorModel.fromArgbInt(style.BrushedColor[index]), hoverColor: tab.ColorModel.fromArgbInt(style.HoverColor[index]), tickColor: tab.ColorModel.fromArgbInt(style.TickColor[index]), fillColor: tab.ColorModel.fromArgbInt(style.FillColor[index]), bandSize: style.BandSize[index], bandLevel: style.BandLevel[index], bandColor: tab.ColorModel.fromArgbInt(style.BandColor[index]), isXAxis: style.IsXAxis[index], selectedTickColor: tab.ColorModel.fromArgbInt(style.SelectedTickColor[index]), fieldName: style.FieldName[index] };
    },
    buildHeaderNodeStyle: function DatastoreHeaderAdapter$BuildHeaderNodeStyle(headerStyleAndShading, headerLevelStyleDataTableIndex, horiz) {
      if (headerLevelStyleDataTableIndex < 0) {
        return {};
      }
      var levelShading = (horiz ? headerStyleAndShading.XLevelShading : headerStyleAndShading.YLevelShading);
      var perLevelHeaderStyles = (horiz ? headerStyleAndShading.XPerLevelHeaderStyles : headerStyleAndShading.YPerLevelHeaderStyles);
      var labelStyleIndex = perLevelHeaderStyles.LabelStyleIndex[headerLevelStyleDataTableIndex];
      var fontMetricsTuple = headerStyleAndShading.FontMetrics[labelStyleIndex];
      var fontHeight = ss.unbox(ss.cast(fontMetricsTuple[0], Number));
      var labelStyles = headerStyleAndShading.LabelStyles;
      var labelStyle = $tab_DatastoreHeaderAdapter.$getLabelStyle(labelStyles, labelStyleIndex);
      var selectedStyle = $tab_DatastoreHeaderAdapter.$getLabelStyle(labelStyles, perLevelHeaderStyles.SelectedStyleIndex[headerLevelStyleDataTableIndex]);
      var brushedStyle = $tab_DatastoreHeaderAdapter.$getLabelStyle(labelStyles, perLevelHeaderStyles.BrushedStyleIndex[headerLevelStyleDataTableIndex]);
      var grandTotalsStyle = $tab_DatastoreHeaderAdapter.$getLabelStyle(labelStyles, perLevelHeaderStyles.GrandTotalsStyleIndex[headerLevelStyleDataTableIndex]);
      var subTotalsStyle = $tab_DatastoreHeaderAdapter.$getLabelStyle(labelStyles, perLevelHeaderStyles.SubtotalsStyleIndex[headerLevelStyleDataTableIndex]);
      var brushedFillColor = tab.ColorModel.fromArgbInt(perLevelHeaderStyles.BrushedFillColor[headerLevelStyleDataTableIndex]);
      var fillColor = tab.ColorModel.fromArgbInt(perLevelHeaderStyles.FillColor[headerLevelStyleDataTableIndex]);
      var highlightedFillColor = tab.ColorModel.fromArgbInt(perLevelHeaderStyles.HighlightedFillColor[headerLevelStyleDataTableIndex]);
      var selectedFillColor = tab.ColorModel.fromArgbInt(perLevelHeaderStyles.SelectedFillColor[headerLevelStyleDataTableIndex]);
      var subTotalsFillColor = tab.ColorModel.fromArgbInt(levelShading.SubtotalsFillColor);
      var grandTotalsFillColor = tab.ColorModel.fromArgbInt(levelShading.GrandTotalsFillColor);
      var leftPadding = perLevelHeaderStyles.LeftPadding[headerLevelStyleDataTableIndex];
      var rightPadding = perLevelHeaderStyles.RightPadding[headerLevelStyleDataTableIndex];
      return { bandColor: tab.ColorModel.fromArgbInt(levelShading.BandingColor), bandSize: levelShading.BandSize, bandLevel: levelShading.BandStartingLevel, brushedFillColor: brushedFillColor, fillColor: fillColor, highlightedFillColor: highlightedFillColor, selectedFillColor: selectedFillColor, selectedStyle: selectedStyle, labelStyle: labelStyle, brushedStyle: brushedStyle, grandTotalsStyle: grandTotalsStyle, subTotalsStyle: subTotalsStyle, subtotalsFillColor: subTotalsFillColor, grandTotalsFillColor: grandTotalsFillColor, labelFontHeight: fontHeight, leftPadding: leftPadding, rightPadding: rightPadding };
    },
    $getLabelStyle: function DatastoreHeaderAdapter$GetLabelStyle(labelStyles, index) {
      var labelStyleTuple = labelStyles[index];
      return tab.TupleDatastoreConversions.textStyleFromTuple(labelStyleTuple);
    },
    buildHeadersFromAxisDescriptor: function DatastoreHeaderAdapter$BuildHeadersFromAxisDescriptor(descriptor) {
      var headerGroupById = {};
      var headerNodeById = {};
      for (var index = 0; index < descriptor.Nodes.Id.length; index++) {
        var nodeId = descriptor.Nodes.Id[index];
        var node = { label: descriptor.Nodes.Label[index], isLeaf: descriptor.Nodes.IsLeaf[index], id: nodeId, headerId: descriptor.Nodes.HeaderId[index], children: [] };
        headerNodeById[nodeId] = node;
        var parentId = descriptor.Nodes.ParentId[index];
        if (parentId !== -1) {
          headerNodeById[parentId].children.push(node);
        }
      }
      for (var index1 = 0; index1 < descriptor.Headers.Id.length; index1++) {
        var groupId = descriptor.Headers.Id[index1];
        headerGroupById[groupId] = { id: groupId, duplicateFieldIndex: descriptor.Headers.DuplicateFieldIndex[index1], header: headerNodeById[descriptor.Headers.NodeId[index1]] };
      }
      for (var index2 = 0; index2 < descriptor.PerHeaderFields.HeaderId.length; index2++) {
        var headerGroup = headerGroupById[descriptor.PerHeaderFields.HeaderId[index2]];
        headerGroup.dataType = descriptor.PerHeaderFields.DataType[index2];
      }
      return headerGroupById;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.DatastorePropsBuilder
  var $tab_DatastorePropsBuilder = global.tab.DatastorePropsBuilder = ss.mkType($asm, 'tab.DatastorePropsBuilder', function() {
  }, null, {
    titleStyleFromDatastore: function DatastorePropsBuilder$TitleStyleFromDatastore(style) {
      return { textOrientation: tab.EnumConversions.textOrientFromInt(style.text_orientation), fontStyle: tab.EnumConversions.tableauFontStyleFromInt(style.font_style), textWrapMode: style.text_wrap_mode, hAlign: style.hAlign, vAlign: style.vAlign, fontWeight: tab.EnumConversions.fontWeightFromInt(style.font_weight), textDecoration: style.text_decoration, font: style.font, color: tab.ColorModel.fromArgbInt(style.text_style_color) };
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.FieldLabelComponent
  var $tab_FieldLabelComponent = global.tab.FieldLabelComponent = ss.mkType($asm, 'tab.FieldLabelComponent', function(props) {
    spiff.PureRenderComponent.call(this, props);
  }, {
    render: function FieldLabelComponent$Render() {
      return spiff.DOMElements.div({ className: 'tab-fieldLabelContainer', style: this.$getFieldLabelContainerStyle() }, this.$makeFieldLabelDiv());
    },
    $makeFieldLabelDiv: function FieldLabelComponent$MakeFieldLabelDiv() {
      return spiff.DOMElements.div({ className: $tab_FieldLabelComponent.fieldLabelClass, style: this.$getFieldLabelStyle() }, this.props.text);
    },
    $getFieldLabelStyle: function FieldLabelComponent$GetFieldLabelStyle() {
      var fieldLabelTextStyle = this.props.style;
      var divStyle = $tab_TextStyleHelper.getCssFromTextStyle(fieldLabelTextStyle);
      divStyle.fontFamily = tab.FontUtil.createFallbackCanvasFontName(fieldLabelTextStyle.font);
      divStyle.textDecoration = (fieldLabelTextStyle.underline ? 'underline' : 'none');
      divStyle.color = tab.ColorModel.fromArgbInt(fieldLabelTextStyle.text_style_color).toRgbHex();
      if (this.props.location === 3) {
        divStyle.transform = 'rotate(-90deg)';
      }
      return divStyle;
    },
    $getFieldLabelContainerStyle: function FieldLabelComponent$GetFieldLabelContainerStyle() {
      var style = { backgroundColor: tab.ColorModel.fromArgbInt(this.props.fillColor).toRgba() };
      if (this.props.location === 3) {
        style.height = this.props.alongMarginSize + 'px';
        style.width = this.props.perpendicularSize + 'px';
        style.top = this.props.scrollOffset + 'px';
        style.flexDirection = 'column';
      }
      else {
        style.width = this.props.alongMarginSize + 'px';
        style.height = this.props.perpendicularSize + 'px';
        style.left = this.props.scrollOffset + 'px';
      }
      return style;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.FieldLabelViewModel
  var $tab_FieldLabelViewModel = global.tab.FieldLabelViewModel = ss.mkType($asm, 'tab.FieldLabelViewModel', function(fieldLabels, perpendicularSize, location) {
    this.$fieldLabelTable = null;
    this.$fieldLabelStyles = null;
    this.$location = 0;
    this.$perpendicularSize = 0;
    this.$alongMarginSize = 0;
    this.$scrollPos = { x: 0, y: 0 };
    ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]).call(this);
    this.$fieldLabelTable = fieldLabels.SceneMarginData;
    this.$fieldLabelStyles = fieldLabels.LabelStyles;
    this.$perpendicularSize = perpendicularSize;
    this.$location = location;
  }, {
    set_sceneMarginViewportSize: function FieldLabelViewModel$set_SceneMarginViewportSize(value) {
      var newAlongMarginSize = value.w;
      if (this.$location === 3) {
        newAlongMarginSize = value.h;
      }
      if (this.$alongMarginSize !== newAlongMarginSize) {
        this.$alongMarginSize = newAlongMarginSize;
        this.incrementProps();
      }
    },
    set_scrollPos: function FieldLabelViewModel$set_ScrollPos(value) {
      if (!tab.PointUtil.equals(this.$scrollPos, value)) {
        this.$scrollPos = value;
        this.incrementProps();
      }
    },
    createInitialProps: function FieldLabelViewModel$CreateInitialProps() {
      var row = this.$findRowInFieldLabelTableWithMatchingLoction(this.$location);
      if (row < 0) {
        return {};
      }
      var styleIndex = this.$fieldLabelTable.LabelStyleIndex[row];
      var labelStyleTuple = this.$fieldLabelStyles[styleIndex];
      return { text: this.$fieldLabelTable.SceneMarginFieldLabelsText[row], style: tab.TupleDatastoreConversions.textStyleFromTuple(labelStyleTuple), fillColor: this.$fieldLabelTable.FillColor[row], location: this.$location, perpendicularSize: this.$perpendicularSize };
    },
    createUpdatedProps: function FieldLabelViewModel$CreateUpdatedProps() {
      return { alongMarginSize: this.$alongMarginSize, scrollOffset: (tab.SceneMarginModel.isHorizontal(this.$location) ? this.$scrollPos.x : this.$scrollPos.y) };
    },
    $findRowInFieldLabelTableWithMatchingLoction: function FieldLabelViewModel$FindRowInFieldLabelTableWithMatchingLoction(location) {
      return _.indexOf(this.$fieldLabelTable.SceneMarginLocation, location);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HAlign
  var $tab_HAlign = global.tab.HAlign = ss.mkEnum($asm, 'tab.HAlign', { left: 0, hCenter: 1, right: 2, hAutomatic: 3 });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderHolderComponent
  var $tab_HeaderHolderComponent = global.tab.HeaderHolderComponent = ss.mkType($asm, 'tab.HeaderHolderComponent', function(props) {
    this.$isHorizontal = false;
    spiff.PureRenderComponent.call(this, props);
    this.$isHorizontal = tab.SceneMarginModel.isHorizontal(props.sceneMarginLocation);
  }, {
    render: function HeaderHolderComponent$Render() {
      var holderNodeChildren = this.props.headerNodes.map(function(node) {
        return React.createElement($tab_HeaderNodeComponent, node);
      });
      var holderCellResizerChildren = this.props.cellResizers.map(function(resizer) {
        return React.createElement($tab_CellResizerComponent, resizer);
      });
      var holderTextChildren = this.props.headerNonSkippedText.map(function(node1) {
        return React.createElement($tab_HeaderNonSkippedTextComponent, node1);
      });
      var dividerElements = this.$makeDividerElements();
      return spiff.DOMElements.div({ className: 'tab-vizHeaderHolderWrapper', style: this.$getAxisDimension() }, holderNodeChildren, holderCellResizerChildren, holderTextChildren, (this.$shouldMakeBottomHeaderTickMarks() ? ss.mkdel(this, function() {
        return this.$makeBottomHeaderTickMarks();
      })() : null), dividerElements);
    },
    $shouldMakeBottomHeaderTickMarks: function HeaderHolderComponent$ShouldMakeBottomHeaderTickMarks() {
      return ss.isValue(this.props.tickPlacementDS) && this.props.sceneMarginLocation === 1;
    },
    $makeBottomHeaderTickMarks: function HeaderHolderComponent$MakeBottomHeaderTickMarks() {
      var $t1 = new $tab_TickPlacementConfig(false, true, false);
      $t1.getMinorTicks = true;
      var tpcMinor = $t1;
      var width = (this.$isHorizontal ? this.props.alongAxisTotalPixelSize : this.props.pixelSize);
      var hasSkippedLabels = this.props.headerNonSkippedText.length > 0;
      var tickProps = { majorTicks: (hasSkippedLabels ? null : this.props.tickMarks), majorTickSize: this.props.tickPlacementDS.TickLengthMajorPixels + 1, minorTicks: (hasSkippedLabels ? this.props.tickMarks : null), minorTickSize: this.props.tickPlacementDS.TickLengthMinorPixels + 1, alongAxisPixelSize: this.props.alongAxisTotalPixelSize, pixelSize: this.props.pixelSize, sceneMarginLocation: this.props.sceneMarginLocation, tickMarkColor: this.props.tickMarkColor };
      return React.createElement($tab_TickMarkComponent, tickProps);
    },
    $makeDividerElements: function HeaderHolderComponent$MakeDividerElements() {
      return ((this.props.sceneMarginLocation === 1) ? this.$makeBottomMarginDividers() : this.$makeNonBottomMarginDividers());
    },
    $makeBottomMarginDividers: function HeaderHolderComponent$MakeBottomMarginDividers() {
      var dividers = [];
      for (var $t1 = 0; $t1 < this.props.headerNodes.length; $t1++) {
        var headerNode = this.props.headerNodes[$t1];
        if (ss.isValue(headerNode.dividerAttributes)) {
          dividers.push($tab_BorderRenderer.drawLine({ x: headerNode.left, y: headerNode.top }, headerNode.height, headerNode.dividerAttributes, false));
        }
      }
      return dividers;
    },
    $makeNonBottomMarginDividers: function HeaderHolderComponent$MakeNonBottomMarginDividers() {
      var dividers = [];
      var isLineHorizontal = !this.$isHorizontal;
      for (var $t1 = 0; $t1 < this.props.headerNodes.length; $t1++) {
        var headerNode = this.props.headerNodes[$t1];
        if (ss.isValue(headerNode.dividerAttributes)) {
          var lineLength = (isLineHorizontal ? headerNode.width : headerNode.height);
          dividers.push($tab_BorderRenderer.drawLine({ x: headerNode.left, y: headerNode.top }, lineLength, headerNode.dividerAttributes, isLineHorizontal));
        }
      }
      return dividers;
    },
    $getAxisDimension: function HeaderHolderComponent$GetAxisDimension() {
      if (this.$isHorizontal) {
        var axisDimension = { width: this.props.alongAxisTotalPixelSize + 'px', height: this.props.pixelSize + 'px' };
        if (this.props.sceneMarginLocation === 1) {
          axisDimension.marginTop = '1px';
        }
        return axisDimension;
      }
      else {
        return { width: this.props.pixelSize + 'px', height: this.props.alongAxisTotalPixelSize + 'px' };
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderHolderViewModel
  var $tab_HeaderHolderViewModel = global.tab.HeaderHolderViewModel = ss.mkType($asm, 'tab.HeaderHolderViewModel', function(sceneMarginModel, marginRow, sceneMarginSelection, borderDataModel, totalMap) {
    this.$nodeData = null;
    this.$tickPlacementRowOffset = 0;
    this.$tickPlacement = null;
    this.$unfilteredAlongDirectionPixelSize = null;
    this.$headerLevelStyleDataTableIndex = 0;
    this.$labelSkip = null;
    this.$borderDataModel = null;
    this.$sortIndicatorData = null;
    this.$perFieldStyleIndexData = null;
    this.$axisStyles = null;
    this.$headerNodeStyle = null;
    this.$fieldNames = null;
    this.$headerNodePropsBuilder = null;
    this.$totalMap = null;
    this.$areHeaderNodesFocusable = false;
    this.$shouldDisableCellResize = false;
    this.$sendHeaderResizeCommand = null;
    this.$sendCellResizeCommand = null;
    ss.makeGenericType($tab_BaseHolderViewModel$1, [Object]).call(this, sceneMarginModel, marginRow, sceneMarginSelection);
    this.$tickPlacement = sceneMarginModel.get_tickPlacement();
    this.$fieldNames = sceneMarginModel.get_sceneMarginLayout().FieldName;
    this.$headerLevelStyleDataTableIndex = _.indexOf(sceneMarginModel.get_headerDepths(), this.level);
    this.$borderDataModel = borderDataModel;
    this.observeBrushingChange();
    this.$unfilteredAlongDirectionPixelSize = sceneMarginModel.get_layoutTable().AlongDirectionPixelSize;
    this.$totalMap = totalMap;
    this.$nodeData = this.$nodesToNodeData(sceneMarginModel.get_nodeData(), sceneMarginModel.get_nodeLevelStyles(), sceneMarginModel.get_elidedNodeLabels());
    this.$labelSkip = new $tab_LabelSkip(this.location, this.$nodeData, sceneMarginModel.get_labelSkipTable());
    this.$tickPlacementRowOffset = ((this.location === 3) ? sceneMarginModel.get_axisTable().ScaleType.length : 0);
    this.$areHeaderNodesFocusable = false;
    this.$sendHeaderResizeCommand = ss.mkdel(sceneMarginModel, sceneMarginModel.sendHeaderResizeCommand);
    this.$sendCellResizeCommand = ss.mkdel(sceneMarginModel, sceneMarginModel.sendCellResizeCommand);
    this.$shouldDisableCellResize = sceneMarginModel.shouldDisableCellResize();
    this.$sortIndicatorData = sceneMarginModel.get_sortIndicatorData();
    this.$perFieldStyleIndexData = sceneMarginModel.get_axisTable().PerFieldStyleIndex;
    this.$axisStyles = sceneMarginModel.get_axisOutput().Style;
    this.$headerNodeStyle = $tab_DatastoreHeaderAdapter.buildHeaderNodeStyle(sceneMarginModel.get_headerStyleAndShading(), this.$headerLevelStyleDataTableIndex, this.isHorizontal());
    var getAllHeadersWithSameEnclosedIndexAndLevel = ss.mkdel(this, function(enclosedIndex, level) {
      return this.getAllHeadersWithSameEnclosedIndexAndLevel(enclosedIndex, level);
    });
    this.$headerNodePropsBuilder = new $tab_HeaderNodePropsBuilder(this.$unfilteredAlongDirectionPixelSize, this.$headerNodeStyle, this.location, $tab_HeaderHolderViewModel.$getLabelPadding(this.location, this.$tickPlacement, this.$headerNodeStyle), this.$sortIndicatorData, getAllHeadersWithSameEnclosedIndexAndLevel);
  }, {
    set_invokeSortCommand: function HeaderHolderViewModel$set_InvokeSortCommand(value) {
      this.$headerNodePropsBuilder.set_invokeSortCommand(value);
    },
    set_sortIndicatorHoverCallback: function HeaderHolderViewModel$set_SortIndicatorHoverCallback(value) {
      this.$headerNodePropsBuilder.set_sortIndicatorHoverCallback(value);
    },
    getIndexAndEnclosedIndexForNodeWithIdIfPresent: function HeaderHolderViewModel$GetIndexAndEnclosedIndexForNodeWithIdIfPresent(id) {
      for (var i = 0; i < this.$nodeData.length; i++) {
        if (ss.referenceEquals(this.$nodeData[i].id, id)) {
          return { item1: i, item2: this.$nodeData[i].enclosedIndex };
        }
      }
      return null;
    },
    findFirstNodeIndexWithEnclosedIndex: function HeaderHolderViewModel$FindFirstNodeIndexWithEnclosedIndex(enclosedIndex) {
      for (var i = 0; i < this.$nodeData.length; i++) {
        if (this.$nodeData[i].enclosedIndex === enclosedIndex) {
          return i;
        }
      }
      ss.Debug.assert(false, 'There should always be at least one node with the provided enclosed index.');
      return -1;
    },
    findAndFocusIfPossible: function HeaderHolderViewModel$FindAndFocusIfPossible(nodeIndex) {
      if (nodeIndex < 0 || nodeIndex > this.$nodeData.length - 1) {
        return;
      }
      this.$findAndFocus(nodeIndex);
    },
    $findAndFocus: function HeaderHolderViewModel$FindAndFocus(nodeIndex) {
      var id = this.$nodeData[nodeIndex].id;
      var elem = document.getElementById(id);
      if (!ss.isNullOrUndefined(elem)) {
        elem.focus();
      }
    },
    updateHeaderNodesFocusState: function HeaderHolderViewModel$UpdateHeaderNodesFocusState(isFocusable) {
      this.$areHeaderNodesFocusable = isFocusable;
      this.incrementProps();
    },
    createInitialProps: function HeaderHolderViewModel$CreateInitialProps() {
      return { sceneMarginLocation: this.location, alongAxisTotalPixelSize: this.orientedSize.get_along(), pixelSize: this.orientedSize.get_perpendicular(), headerNodes: [], headerNonSkippedText: [], sceneMarginViewportSize: this.get_sceneMarginViewportSize(), fieldName: (ss.isValue(this.$fieldNames) ? this.$fieldNames[this.marginRow] : ''), sendHeaderResizeCommand: this.$sendHeaderResizeCommand, pixelOffset: this.pixelOffset, cellResizers: [], tickMarkColor: (!ss.isNullOrUndefined(this.$getAxisStyles()) ? this.$getAxisStyles().tickColor : null), tickMarks: ((this.location === 1) ? this.$getBottomHeaderTicks() : null) };
    },
    createUpdatedProps: function HeaderHolderViewModel$CreateUpdatedProps() {
      if (tab.SizeUtil.isEmpty(this.get_sceneMarginViewportSize()) || this.$headerLevelStyleDataTableIndex < 0) {
        return {};
      }
      var headerNodes = this.$buildHeaderNodes();
      var headerNonSkippedText = this.$buildHeaderNonSkippedText(headerNodes);
      return { headerNodes: headerNodes, headerNonSkippedText: headerNonSkippedText, sceneMarginViewportSize: this.get_sceneMarginViewportSize(), pixelOffset: this.pixelOffset, cellResizers: (this.$shouldDisableCellResize ? [] : this.$computeCellResizerProps(headerNodes)), level: this.level, tickPlacementDS: this.$tickPlacement };
    },
    $computeCellResizerProps: function HeaderHolderViewModel$ComputeCellResizerProps(headerNodes) {
      var cellResizers = [];
      for (var nodeIndex = 0; nodeIndex < headerNodes.length; ++nodeIndex) {
        var $t1 = new $tab_CellResizerProps();
        $t1.left = headerNodes[nodeIndex].left;
        $t1.top = headerNodes[nodeIndex].top;
        $t1.width = headerNodes[nodeIndex].width;
        $t1.height = headerNodes[nodeIndex].height;
        $t1.isHorizontal = this.isHorizontal();
        $t1.isLastHeaderElement = headerNodes.length - 1 === nodeIndex;
        $t1.numLeaves = this.$nodeData[nodeIndex].numLeaves;
        $t1.sendCellResizeCommand = this.$sendCellResizeCommand;
        var cellResizer = $t1;
        cellResizers.push(cellResizer);
      }
      return cellResizers;
    },
    $buildHeaderNodes: function HeaderHolderViewModel$BuildHeaderNodes() {
      if (ss.isNullOrUndefined(this.$nodeData)) {
        return [];
      }
      var result = new Array(this.$nodeData.length);
      var headerPlacements = this.$getHeaderPlacements(this.orientedSize.get_perpendicular());
      for (var nodeIndex = 0; nodeIndex < this.$nodeData.length; ++nodeIndex) {
        var isNodeSelected = this.isHolderSelected(nodeIndex);
        var isNodeBrushed = this.sceneMarginSelection.isNodeBrushed(this.level, nodeIndex);
        var thisTick = headerPlacements[nodeIndex];
        var nextTick = headerPlacements[nodeIndex + 1];
        var perNodeData = this.$nodeData[nodeIndex];
        var perpendicularSize = this.pixelSize;
        if (perNodeData.totalType !== 0) {
          var totalNode = this.$totalMap.getTotalNode(this.level, nodeIndex);
          if (ss.isValue(totalNode)) {
            perpendicularSize = totalNode.stretchedPixelSize;
            if (perpendicularSize > 0) {
              perNodeData.labelForRender = totalNode.label;
            }
          }
        }
        var orientedNodeSize = this.makeOrientedSize(nextTick - thisTick, perpendicularSize);
        var orientedTickOffset = this.makeOrientedSize(thisTick, this.pixelOffset);
        var dividerAttributes = this.$borderDataModel.getSceneMarginDividerAttributes(this.level, perNodeData.borderStartLevel);
        result[nodeIndex] = this.$headerNodePropsBuilder.build(perNodeData, orientedNodeSize, orientedTickOffset, isNodeSelected, isNodeBrushed, this.$labelSkip.paneHasSkippedLabel(nodeIndex), dividerAttributes, this.$areHeaderNodesFocusable);
      }
      return result;
    },
    $buildHeaderNonSkippedText: function HeaderHolderViewModel$BuildHeaderNonSkippedText(headerNodes) {
      if (!this.$labelSkip.hasSkippedLabels) {
        return [];
      }
      var averageWidth = ss.idiv(this.get_props().alongAxisTotalPixelSize, headerNodes.length);
      var result = [];
      for (var nodeIndex = 0; nodeIndex < headerNodes.length; ++nodeIndex) {
        if (!this.$labelSkip.paneHasSkippedLabel(nodeIndex)) {
          continue;
        }
        if (!this.$labelSkip.isSkipped(nodeIndex)) {
          var skip = this.$labelSkip.getSkip(nodeIndex);
          result.push(this.$computeNonSkippedTextProps(headerNodes[nodeIndex], averageWidth * skip));
        }
      }
      return Array.prototype.slice.call(result);
    },
    $getNonBottomHeaderPlacements: function HeaderHolderViewModel$GetNonBottomHeaderPlacements() {
      var headerPlacements = [];
      var alongAxisPixelSize = 0;
      var alongAxisPixelOffset = 0;
      for (var i = 0; i < this.alongAxisPixelOffset.length; ++i) {
        alongAxisPixelSize = this.alongAxisPixelSize[i];
        alongAxisPixelOffset = this.alongAxisPixelOffset[i];
        headerPlacements.push(alongAxisPixelOffset);
      }
      headerPlacements.push(alongAxisPixelOffset + alongAxisPixelSize);
      return headerPlacements;
    },
    $getHeaderPlacements: function HeaderHolderViewModel$GetHeaderPlacements(perpendicularPixelSize) {
      if (this.location !== 1) {
        return this.$getNonBottomHeaderPlacements();
      }
      return this.$getTickPlacements(perpendicularPixelSize, false);
    },
    $getTickPlacements: function HeaderHolderViewModel$GetTickPlacements(perpendicularPixelSize, getMinorTicks) {
      var tickPlacements = [];
      var enclosureCount = this.$nodeData[this.$nodeData.length - 1].enclosedIndex + 1;
      var alongAxisPixelSize = 0;
      var alongAxisPixelOffset = 0;
      for (var i = 0; i < enclosureCount; i++) {
        alongAxisPixelSize = this.alongAxisPixelSize[i];
        alongAxisPixelOffset = this.alongAxisPixelOffset[i];
        var regionRect = (this.isHorizontal() ? { x: 0, y: 0, w: alongAxisPixelSize, h: perpendicularPixelSize } : { x: 0, y: 0, w: perpendicularPixelSize, h: alongAxisPixelSize });
        var tpc = new $tab_TickPlacementConfig(!this.isHorizontal(), this.isHorizontal(), getMinorTicks);
        var placements = $tab_TickPlacement.getTickPlacement(this.$tickPlacement, regionRect, this.$tickPlacementRowOffset + i, tpc, true);
        placements = _.map(placements, function(placement) {
          return placement + alongAxisPixelOffset;
        });
        if (!getMinorTicks) {
          tickPlacements.push(alongAxisPixelOffset);
        }
        ss.arrayAddRange(tickPlacements, placements);
      }
      if (!getMinorTicks) {
        tickPlacements.push(alongAxisPixelOffset + alongAxisPixelSize);
      }
      return tickPlacements;
    },
    $computeNonSkippedTextProps: function HeaderHolderViewModel$ComputeNonSkippedTextProps(headerProp, labelWidth) {
      var labelTextOffset = headerProp.width / 2 - labelWidth / 2;
      return { width: labelWidth, height: headerProp.height, left: headerProp.left + ss.trunc(labelTextOffset), text: headerProp.text, canShowSortIndicatorOnHover: headerProp.canShowSortIndicatorOnHover, headerLabelStyle: headerProp.headerLabelStyle, labelPadding: $tab_HeaderHolderViewModel.$getLabelPadding(this.location, this.$tickPlacement, this.$headerNodeStyle), sceneMarginLocation: this.location, isHorizontal: headerProp.isHorizontal, persistentSortIndicatorClassName: headerProp.persistentSortIndicatorClassName, isNodeSorted: headerProp.isNodeSorted, invokeSortCommand: headerProp.invokeSortCommand };
    },
    $getIdForNodeHash: function HeaderHolderViewModel$GetIdForNodeHash(nodeHash) {
      return $tab_NodeUtils.getIdForNodeHash(nodeHash, this.isHorizontal());
    },
    $nodesToNodeData: function HeaderHolderViewModel$NodesToNodeData(nodes, nodeLevelStyles, labelsForRendering) {
      var result = [];
      for (var i = 0; i < nodes.Level.length; ++i) {
        if (nodes.Level[i] !== this.level) {
          continue;
        }
        var nodeHash = $tab_NodeUtils.toNodeHash(nodes.Id[i]);
        var $t1 = new $tab_PerNodeData();
        $t1.fullText = nodes.Label[i - 1];
        $t1.labelForRender = (ss.isNullOrUndefined(labelsForRendering) ? nodes.Label[i - 1] : labelsForRendering[i]);
        $t1.enclosedIndex = nodes.EnclosedIndex[i];
        $t1.level = nodes.Level[i];
        $t1.isLeaf = nodes.IsLeaf[i];
        $t1.totalType = nodeLevelStyles.TotalType[i];
        $t1.isBandFilled = nodeLevelStyles.ShouldUseBandFillColor[i];
        $t1.nodeTableIndex = i;
        $t1.id = this.$getIdForNodeHash(nodeHash);
        $t1.numLeaves = (ss.isNullOrUndefined(nodes.NumLeaves) ? 0 : nodes.NumLeaves[i]);
        $t1.leftmostLeafIndex = (ss.isNullOrUndefined(nodes.LeftmostLeafIndex) ? 0 : nodes.LeftmostLeafIndex[i]);
        $t1.borderStartLevel = nodes.BorderStartLevel[i];
        $t1.canShowSortIndicatorOnHover = nodes.CanShowHoverSortIndicator[i];
        var nodeData = $t1;
        result.push(nodeData);
      }
      return Array.prototype.slice.call(result);
    },
    $getAxisStyles: function HeaderHolderViewModel$GetAxisStyles() {
      if (this.$hasPerFieldStyleIndexData()) {
        var index = this.$getLastPerFieldStyleIndex();
        return $tab_DatastoreHeaderAdapter.buildStyleProps(this.$axisStyles, index);
      }
      return null;
    },
    $getLastPerFieldStyleIndex: function HeaderHolderViewModel$GetLastPerFieldStyleIndex() {
      var xStyleCount = this.$perFieldStyleIndexData.length;
      return this.$perFieldStyleIndexData[xStyleCount - 1];
    },
    $hasPerFieldStyleIndexData: function HeaderHolderViewModel$HasPerFieldStyleIndexData() {
      return ss.isValue(this.$axisStyles) && ss.isValue(this.$perFieldStyleIndexData) && this.$perFieldStyleIndexData.length > 0;
    },
    $getBottomHeaderTicks: function HeaderHolderViewModel$GetBottomHeaderTicks() {
      if (this.$labelSkip.hasSkippedLabels) {
        return this.$getTickPlacements(this.orientedSize.get_perpendicular(), true);
      }
      return this.$getTickPlacements(this.orientedSize.get_perpendicular(), false);
    },
    getAllHeadersWithSameEnclosedIndexAndLevel: function HeaderHolderViewModel$GetAllHeadersWithSameEnclosedIndexAndLevel(enclosedIndex, level) {
      var headerGroup = {};
      for (var $t1 = 0; $t1 < this.$nodeData.length; $t1++) {
        var node = this.$nodeData[$t1];
        if (node.enclosedIndex === enclosedIndex && node.level === level) {
          headerGroup[node.id] = ss.getKeyCount(headerGroup);
        }
      }
      return headerGroup;
    }
  }, {
    $getLabelPadding: function HeaderHolderViewModel$GetLabelPadding(location, tickPlacement, headerNodeStyle) {
      switch (location) {
        case 1: {
          var $t1 = new tab.LabelPadding();
          $t1.top = tickPlacement.TickLengthMajorPixels;
          return $t1;
        }
        case 0:
        case 3: {
          var $t2 = new tab.LabelPadding();
          $t2.right = headerNodeStyle.rightPadding;
          $t2.left = headerNodeStyle.leftPadding;
          return $t2;
        }
        default: {
          return new tab.LabelPadding();
        }
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderLabelStyleHelper
  var $tab_HeaderLabelStyleHelper = global.tab.HeaderLabelStyleHelper = ss.mkType($asm, 'tab.HeaderLabelStyleHelper', function(headerLabelStyle, rotation, paneHasSkippedLabel) {
    this.$headerLabelStyle = null;
    this.$rotation = 0;
    this.$paneHasSkippedLabel = false;
    this.$headerLabelStyle = headerLabelStyle;
    this.$rotation = rotation;
    this.$paneHasSkippedLabel = paneHasSkippedLabel;
  }, {
    getGeneralHeaderLabelCss: function HeaderLabelStyleHelper$GetGeneralHeaderLabelCss() {
      var headerItemStyle = $tab_TextStyleHelper.getCssFromTextStyle(this.$headerLabelStyle);
      headerItemStyle.fontFamily = tab.FontUtil.createFallbackCanvasFontName(this.$headerLabelStyle.font);
      headerItemStyle.textDecoration = (this.$headerLabelStyle.underline ? 'underline' : 'none');
      headerItemStyle.color = tab.ColorModel.fromArgbInt(this.$headerLabelStyle.text_style_color).toRgbHex();
      if (tab.EnumConversions.textWrapModeFromInt(this.$headerLabelStyle.text_wrap_mode) === 'text-wrap-off') {
        headerItemStyle.whiteSpace = 'nowrap';
      }
      else if (tab.EnumConversions.textWrapModeFromInt(this.$headerLabelStyle.text_wrap_mode) === 'text-wrap-on' || this.$paneHasSkippedLabel) {
        headerItemStyle.wordBreak = 'break-all';
      }
      var vAlign = this.$headerLabelStyle.vAlign;
      var hAlign = this.$headerLabelStyle.hAlign;
      var textOrientation = this.$rotation;
      this.$setTextAlignment(headerItemStyle, hAlign, vAlign, textOrientation);
      return headerItemStyle;
    },
    $setTextAlignment: function HeaderLabelStyleHelper$SetTextAlignment(cssStyle, hAlign, vAlign, textOrientation) {
      if (textOrientation === 0) {
        cssStyle.textAlign = this.$horizontalLabelTextAlignment(hAlign);
      }
      else {
        cssStyle.writingMode = $tab_HeaderLabelStyleHelper.writingModeVertical();
        cssStyle.textAlign = this.$verticalLabelTextAlignment(vAlign, textOrientation);
        if (textOrientation === -90) {
          cssStyle.transform = 'rotate(180deg)';
        }
      }
    },
    $verticalLabelTextAlignment: function HeaderLabelStyleHelper$VerticalLabelTextAlignment(alignment, textOrientation) {
      switch (alignment) {
        case 2: {
          return ((textOrientation === 90) ? 'left' : 'right');
        }
        case 0: {
          return ((textOrientation === 90) ? 'right' : 'left');
        }
        case 1:
        default: {
          return 'center';
        }
      }
    },
    $horizontalLabelTextAlignment: function HeaderLabelStyleHelper$HorizontalLabelTextAlignment(alignment) {
      switch (alignment) {
        case 0: {
          return 'left';
        }
        case 2: {
          return 'right';
        }
        case 1:
        default: {
          return 'center';
        }
      }
    }
  }, {
    writingModeVertical: function HeaderLabelStyleHelper$WritingModeVertical() {
      return (BrowserSupport.BrowserSupport.IsIE() ? 'tb-rl' : 'vertical-rl');
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderNodeComponent
  var $tab_HeaderNodeComponent = global.tab.HeaderNodeComponent = ss.mkType($asm, 'tab.HeaderNodeComponent', function(nodeProps) {
    this.$sortIndicator = null;
    this.$boundHeaderNode = null;
    spiff.PureRenderComponent.call(this, nodeProps);
    this.$sortIndicator = new $tab_HeaderNodeSortIndicator(nodeProps);
    this.state = { isHovered: false };
    var boundAttachDragSource = null;
    var boundAttachDropTarget = null;
    if (tab.FeatureFlags.isEnabled('BeviDragHeaders')) {
      boundAttachDragSource = spiff.ReactRefs.attachDragSource(ss.mkdel(this, function() {
        return this;
      }));
      boundAttachDropTarget = spiff.ReactRefs.attachDropTarget(ss.mkdel(this, function() {
        return this;
      }));
    }
    this.$boundHeaderNode = function(d) {
      if (ss.isValue(d)) {
        if (!ss.staticEquals(boundAttachDragSource, null) && !ss.staticEquals(boundAttachDropTarget, null)) {
          boundAttachDragSource(d);
          boundAttachDropTarget(d);
        }
      }
    };
  }, {
    get_feedbackType: function HeaderNodeComponent$get_FeedbackType() {
      return 'dropfeedbackuponentry';
    },
    $getSortIndicatorDiv: function HeaderNodeComponent$GetSortIndicatorDiv() {
      return spiff.DOMElements.div({ className: this.$sortIndicator.getSortIndicatorCssClassName(this.state.isHovered), style: this.$sortIndicator.getSortIndicatorCss(), title: this.props.sortIndicatorTooltip, onClick: ss.mkdel(this, function(evt) {
        this.$sortIndicator.sortIndicatorClicked(evt);
      }), onMouseOver: ss.mkdel(this, function(evt1) {
        this.props.sortIndicatorHoverCallback(true);
      }), onMouseLeave: ss.mkdel(this, function(evt2) {
        this.props.sortIndicatorHoverCallback(false);
      }) });
    },
    $getLabelContainerDiv: function HeaderNodeComponent$GetLabelContainerDiv() {
      return spiff.DOMElements.div({ className: 'tab-vizHeaderLabelContainer', style: this.$getHeaderLabelContainerCss() }, this.$getNonSkippedHeaderLabelDiv());
    },
    $getNonSkippedHeaderLabelDiv: function HeaderNodeComponent$GetNonSkippedHeaderLabelDiv() {
      return spiff.DOMElements.div({ className: 'tab-vizHeader', style: this.$getHeaderLabelCss() }, this.props.text);
    },
    render: function HeaderNodeComponent$Render() {
      if (this.props.isHiddenForStretching) {
        return null;
      }
      var headerNodeWrapper = { className: 'tab-vizHeaderWrapper', style: this.$getHeaderWrapperCss(), id: this.props.id, ref: this.$boundHeaderNode, onMouseOver: ss.mkdel(this, function(evt) {
        this.setState({ isHovered: true });
      }), onMouseLeave: ss.mkdel(this, function(evt1) {
        this.setState({ isHovered: false });
      }), tabIndex: ((tab.SceneMarginModel.isKeyboardAccessibilityEnabled() && this.props.isFocusable) ? 0 : -1) };
      return spiff.DOMElements.div(headerNodeWrapper, (!this.props.paneHasSkippedLabel ? ss.mkdel(this, function() {
        return this.$getLabelContainerDiv();
      })() : null), (this.$canShowSortIndicator() ? ss.mkdel(this, function() {
        return this.$getSortIndicatorDiv();
      })() : null));
    },
    startDrag: function HeaderNodeComponent$StartDrag(e) {
      return new EventUtils.DragInstance(this, null);
    },
    acceptsDragType: function HeaderNodeComponent$AcceptsDragType() {
      return 1;
    },
    dragOver: function HeaderNodeComponent$DragOver(d) {
      return this;
    },
    dragExit: function HeaderNodeComponent$DragExit(d) {
    },
    acceptDrop: function HeaderNodeComponent$AcceptDrop(d) {
      var promise = $.Deferred();
      return promise.resolve(true);
    },
    getDropTarget: function HeaderNodeComponent$GetDropTarget(hit) {
      return this;
    },
    getDropCursor: function HeaderNodeComponent$GetDropCursor(currentDrag) {
      return spiff.CustomCursor.move;
    },
    $canShowSortIndicator: function HeaderNodeComponent$CanShowSortIndicator() {
      if (this.props.paneHasSkippedLabel) {
        return false;
      }
      return this.$sortIndicator.canShowSortIndicator(this.state.isHovered);
    },
    $getHeaderWrapperCss: function HeaderNodeComponent$GetHeaderWrapperCss() {
      var heightWithPadding = this.props.height;
      if (this.props.sceneMarginLocation === 1) {
        heightWithPadding += this.props.labelPadding.top;
      }
      var headerWrapperStyle = { width: this.props.width + 'px', height: heightWithPadding + 'px' };
      if (this.props.isHorizontal) {
        headerWrapperStyle.left = this.props.left + 'px';
      }
      else {
        headerWrapperStyle.top = this.props.top + 'px';
      }
      if (BrowserSupport.BrowserSupport.IsIE() && this.$canShowSortIndicator()) {
        this.$ieHackToFixAlignmentWithSortIndicator(headerWrapperStyle);
      }
      else {
        headerWrapperStyle.alignItems = this.$pageVerticalContentAlignment();
        headerWrapperStyle.justifyContent = this.$pageHorizontalContentAlignment();
      }
      this.$setHeaderWrapperBackgroundColor(headerWrapperStyle);
      return headerWrapperStyle;
    },
    $ieHackToFixAlignmentWithSortIndicator: function HeaderNodeComponent$IEHackToFixAlignmentWithSortIndicator(style) {
      style.flexDirection = 'column-reverse';
      style.alignItems = this.$pageHorizontalContentAlignment();
      var justifyContentValue = this.$pageVerticalContentAlignment();
      if (ss.equalsT(justifyContentValue, 'flex-start')) {
        style.justifyContent = 'flex-end';
      }
      else if (ss.equalsT(justifyContentValue, 'flex-end')) {
        style.justifyContent = 'flex-start';
      }
      else {
        style.justifyContent = justifyContentValue;
      }
    },
    $getActiveTextStyle: function HeaderNodeComponent$GetActiveTextStyle() {
      if (this.props.isSelected && ss.isValue(this.props.selectedLabelStyle)) {
        return this.props.selectedLabelStyle;
      }
      if (this.props.isBrushed && ss.isValue(this.props.brushedLabelStyle)) {
        return this.props.brushedLabelStyle;
      }
      if (this.state.isHovered && ss.isValue(this.props.hoverLabelStyle)) {
        return this.props.hoverLabelStyle;
      }
      return this.props.headerLabelStyle;
    },
    $getHeaderLabelCss: function HeaderNodeComponent$GetHeaderLabelCss() {
      var headerLabelStyleHelper = new $tab_HeaderLabelStyleHelper(this.$getActiveTextStyle(), this.props.rotation, this.props.paneHasSkippedLabel);
      var style = headerLabelStyleHelper.getGeneralHeaderLabelCss();
      if (BrowserSupport.BrowserSupport.IsIE() && this.props.rotation !== 0) {
        style.height = this.props.height + 'px';
      }
      return style;
    },
    $getHeaderLabelContainerCss: function HeaderNodeComponent$GetHeaderLabelContainerCss() {
      var style = { maxWidth: this.props.width + 'px', maxHeight: this.props.height + 'px' };
      var vAlign = this.props.headerLabelStyle.vAlign;
      this.$setAutomaticTopMargin(style, vAlign);
      var textOrientation = this.props.rotation;
      this.$setPaddingAttributes(style, textOrientation);
      if (!BrowserSupport.BrowserSupport.IsIE() && !BrowserSupport.BrowserSupport.IsLegacyEdge()) {
        this.$setStickyHeaderLabelAttributes(style, textOrientation);
        if (textOrientation !== 0) {
          style.writingMode = $tab_HeaderLabelStyleHelper.writingModeVertical();
        }
      }
      if (this.props.isNodeSorted) {
        this.$sortIndicator.adjustLabelRectangleForSortIndicator(style);
      }
      return style;
    },
    $setHeaderWrapperBackgroundColor: function HeaderNodeComponent$SetHeaderWrapperBackgroundColor(headerWrapperStyle) {
      headerWrapperStyle.backgroundColor = this.props.fillColor.toRgba();
      if (this.state.isHovered && !this.props.isBrushed && !this.props.isSelected) {
        headerWrapperStyle.backgroundColor = this.props.highlightedFillColor.toRgbHex();
      }
    },
    $needsSmartVerticalAlignment: function HeaderNodeComponent$NeedsSmartVerticalAlignment(vAlign) {
      return this.props.autoVAlignTopOffset !== -1 && !this.props.isHorizontal && vAlign === 3;
    },
    $setAutomaticTopMargin: function HeaderNodeComponent$SetAutomaticTopMargin(headerLabelStyle, vAlign) {
      if (this.$needsSmartVerticalAlignment(vAlign)) {
        headerLabelStyle.marginTop = this.props.autoVAlignTopOffset;
      }
    },
    $setPaddingAttributes: function HeaderNodeComponent$SetPaddingAttributes(headerItemStyle, textOrientation) {
      switch (this.props.sceneMarginLocation) {
        case 1: {
          headerItemStyle.paddingTop = this.props.labelPadding.top + 'px';
          break;
        }
        case 3:
        case 0: {
          if (textOrientation === 0) {
            headerItemStyle.paddingLeft = this.props.labelPadding.left + 'px';
            headerItemStyle.paddingRight = this.props.labelPadding.right + 'px';
          }
          break;
        }
      }
    },
    $setStickyHeaderLabelAttributes: function HeaderNodeComponent$SetStickyHeaderLabelAttributes(headerItemStyle, textOrientation) {
      if (this.props.isHorizontal) {
        if (textOrientation === 0) {
          headerItemStyle.position = 'sticky';
          headerItemStyle.left = '0px';
          headerItemStyle.right = '0px';
        }
      }
      else {
        headerItemStyle.position = 'sticky';
        headerItemStyle.top = '0px';
        headerItemStyle.bottom = '0px';
      }
    },
    $pageVerticalContentAlignment: function HeaderNodeComponent$PageVerticalContentAlignment() {
      var vAlign = this.props.headerLabelStyle.vAlign;
      if (this.$needsSmartVerticalAlignment(vAlign)) {
        vAlign = 2;
      }
      switch (vAlign) {
        case 2: {
          return 'flex-start';
        }
        case 0: {
          return 'flex-end';
        }
        case 1: {
          return 'center';
        }
        default: {
          return 'center';
        }
      }
    },
    $pageHorizontalContentAlignment: function HeaderNodeComponent$PageHorizontalContentAlignment() {
      var hAlign = this.props.headerLabelStyle.hAlign;
      switch (hAlign) {
        case 0: {
          return 'flex-start';
        }
        case 2: {
          return 'flex-end';
        }
        case 1: {
          return 'center';
        }
        default: {
          return 'center';
        }
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderNodePropsBuilder
  var $tab_HeaderNodePropsBuilder = global.tab.HeaderNodePropsBuilder = ss.mkType($asm, 'tab.HeaderNodePropsBuilder', function(unfilteredAlongDirectionPixelSize, headerNodeStyle, location, labelPadding, sortIndicatorData, getAllHeadersWithSameEnclosedIndexAndLevel) {
    this.$unfilteredAlongDirectionPixelSize = null;
    this.$headerNodeStyle = null;
    this.$location = 0;
    this.$labelPadding = null;
    this.$sortIndicatorLookup = null;
    this.$getAllHeadersWithSameEnclosedIndexAndLevel = null;
    this.$1$InvokeSortCommandField = null;
    this.$1$SortIndicatorHoverCallbackField = null;
    this.$unfilteredAlongDirectionPixelSize = unfilteredAlongDirectionPixelSize;
    this.$headerNodeStyle = headerNodeStyle;
    this.$location = location;
    this.$labelPadding = labelPadding;
    this.$sortIndicatorLookup = this.$populateSortIndicatorLookup(sortIndicatorData);
    this.$getAllHeadersWithSameEnclosedIndexAndLevel = getAllHeadersWithSameEnclosedIndexAndLevel;
  }, {
    get_invokeSortCommand: function HeaderNodePropsBuilder$get_InvokeSortCommand() {
      return this.$1$InvokeSortCommandField;
    },
    set_invokeSortCommand: function HeaderNodePropsBuilder$set_InvokeSortCommand(value) {
      this.$1$InvokeSortCommandField = value;
    },
    get_sortIndicatorHoverCallback: function HeaderNodePropsBuilder$get_SortIndicatorHoverCallback() {
      return this.$1$SortIndicatorHoverCallbackField;
    },
    set_sortIndicatorHoverCallback: function HeaderNodePropsBuilder$set_SortIndicatorHoverCallback(value) {
      this.$1$SortIndicatorHoverCallbackField = value;
    },
    build: function HeaderNodePropsBuilder$Build(perNodeData, orientedNodeSize, orientedTickOffset, isNodeSelected, isNodeBrushed, paneHasSkippedLabel, dividerAttributes, areHeaderNodesFocusable) {
      var headerLabelStyle = this.$getHeaderLabelStyle(perNodeData.totalType);
      var sortIndicatorData = (ss.keyExists(this.$sortIndicatorLookup, perNodeData.id) ? this.$sortIndicatorLookup[perNodeData.id] : null);
      var isSortedLeafNode = ss.isValue(sortIndicatorData) && perNodeData.isLeaf;
      return { width: orientedNodeSize.get_width(), height: orientedNodeSize.get_height(), top: orientedTickOffset.get_height(), left: orientedTickOffset.get_width(), rotation: this.$headerNodeStyle.labelStyle.text_orientation, isSelected: isNodeSelected, isBrushed: isNodeBrushed, isFocusable: areHeaderNodesFocusable, key: this.$location + orientedTickOffset.get_width(), id: perNodeData.id, enclosedIndex: perNodeData.enclosedIndex, level: perNodeData.level, text: this.$getLabelText(perNodeData, orientedNodeSize), paneHasSkippedLabel: paneHasSkippedLabel, isHorizontal: tab.SceneMarginModel.isHorizontal(this.$location), headerLabelStyle: headerLabelStyle, isBandFilled: perNodeData.isBandFilled, fillColor: this.$getFillColor(perNodeData, isNodeSelected, isNodeBrushed), highlightedFillColor: this.$headerNodeStyle.highlightedFillColor, selectedLabelStyle: this.$headerNodeStyle.selectedStyle, brushedLabelStyle: this.$headerNodeStyle.brushedStyle, hoverLabelStyle: this.$getHoverLabelStyle(headerLabelStyle), autoVAlignTopOffset: this.$computeSmartVerticalLabelOffset(perNodeData), dividerAttributes: dividerAttributes, isNodeSorted: isSortedLeafNode, persistentSortIndicatorClassName: this.$getPersistentSortIndicatorClassName(sortIndicatorData, isSortedLeafNode), canShowSortIndicatorOnHover: perNodeData.canShowSortIndicatorOnHover, sortIndicatorTooltip: (isSortedLeafNode ? sortIndicatorData.tooltip : ''), labelPadding: this.$labelPadding, sceneMarginLocation: this.$location, invokeSortCommand: this.get_invokeSortCommand(), sortIndicatorHoverCallback: this.get_sortIndicatorHoverCallback(), getAllHeadersWithSameEnclosedIndexAndLevel: this.$getAllHeadersWithSameEnclosedIndexAndLevel, isHiddenForStretching: orientedNodeSize.get_perpendicular() <= 0 };
    },
    $isLabelRectTooSmall: function HeaderNodePropsBuilder$IsLabelRectTooSmall(orientedNodeSize) {
      var MIN_LABELLED_SIZE = 2;
      if (this.$location !== 3) {
        return false;
      }
      return Math.min(orientedNodeSize.get_width(), orientedNodeSize.get_height()) < MIN_LABELLED_SIZE;
    },
    $getPersistentSortIndicatorClassName: function HeaderNodePropsBuilder$GetPersistentSortIndicatorClassName(sortIndicatorData, isSortedLeafNode) {
      if (!isSortedLeafNode) {
        return '';
      }
      var sortDirection = sortIndicatorData.indicatorDirection;
      return ((sortDirection === 'asc') ? 'sortIndLeft' : 'sortIndRight');
    },
    $getLabelText: function HeaderNodePropsBuilder$GetLabelText(perNodeData, orientedNodeSize) {
      if (this.$isLabelRectTooSmall(orientedNodeSize)) {
        return '';
      }
      return $tab_NodeUtils.getLabelText(perNodeData.fullText, perNodeData.labelForRender);
    },
    $getHoverLabelStyle: function HeaderNodePropsBuilder$GetHoverLabelStyle(normalLabelStyle) {
      var hoverStyle = _.clone(normalLabelStyle);
      hoverStyle.text_style_color = $tab_HeaderNodePropsBuilder.$black.toArgbInt();
      return hoverStyle;
    },
    $populateSortIndicatorLookup: function HeaderNodePropsBuilder$PopulateSortIndicatorLookup(sortIndicatorData) {
      var result = {};
      if (ss.isNullOrUndefined(sortIndicatorData)) {
        return result;
      }
      var isHorizontal = tab.SceneMarginModel.isHorizontal(this.$location);
      var idsOfSortedNodes = sortIndicatorData.SortIndicatorHash;
      for (var i = 0; i < idsOfSortedNodes.length; ++i) {
        var sortDirection = ((sortIndicatorData.SortIndicatorDirection[i] === 0) ? 'asc' : 'desc');
        var sortedNodeId = $tab_NodeUtils.getIdForNodeHash($tab_NodeUtils.toNodeHash(idsOfSortedNodes[i]), isHorizontal);
        var $t1 = new $tab_NestedSortIndicatorDataTableRow();
        $t1.indicatorDirection = sortDirection;
        $t1.tooltip = sortIndicatorData.SortIndicatorTooltip[i];
        result[sortedNodeId] = $t1;
      }
      return result;
    },
    $computeSmartVerticalLabelOffset: function HeaderNodePropsBuilder$ComputeSmartVerticalLabelOffset(currentNodeData) {
      if (!tab.SceneMarginModel.isHorizontal(this.$location) && currentNodeData.numLeaves > 1) {
        var fontHeight = this.$headerNodeStyle.labelFontHeight;
        var leafIndex = currentNodeData.leftmostLeafIndex;
        var leftmostLeafHeight = this.$unfilteredAlongDirectionPixelSize[leafIndex];
        var offset = ss.idiv(leftmostLeafHeight, 2) - ss.trunc(fontHeight / 2);
        return ((offset < 0) ? 0 : offset);
      }
      return -1;
    },
    $getHeaderLabelStyle: function HeaderNodePropsBuilder$GetHeaderLabelStyle(totalType) {
      if (totalType === 1) {
        return this.$headerNodeStyle.subTotalsStyle;
      }
      if (totalType === 2) {
        return this.$headerNodeStyle.grandTotalsStyle;
      }
      return this.$headerNodeStyle.labelStyle;
    },
    $getFillColor: function HeaderNodePropsBuilder$GetFillColor(perNodeData, isNodeSelected, isNodeBrushed) {
      if (isNodeSelected) {
        return this.$headerNodeStyle.selectedFillColor;
      }
      if (isNodeBrushed) {
        return this.$headerNodeStyle.brushedFillColor;
      }
      var fillColor = { $: this.$headerNodeStyle.fillColor };
      if (perNodeData.isBandFilled) {
        fillColor.$ = this.$headerNodeStyle.bandColor;
      }
      this.$updateFillColorForTotalsIfNeeded(fillColor, perNodeData.totalType);
      return fillColor.$;
    },
    $updateFillColorForTotalsIfNeeded: function HeaderNodePropsBuilder$UpdateFillColorForTotalsIfNeeded(fillColor, totalType) {
      if (ss.isNullOrUndefined(totalType)) {
        return;
      }
      if (ss.equals(totalType, 1)) {
        if (!ss.equals(this.$headerNodeStyle.subtotalsFillColor.toRgba(), $tab_HeaderNodePropsBuilder.$transparentWhite.toRgba())) {
          fillColor.$ = this.$headerNodeStyle.subtotalsFillColor;
        }
      }
      else if (ss.equals(totalType, 2)) {
        if (!ss.equals(this.$headerNodeStyle.grandTotalsFillColor.toRgba(), $tab_HeaderNodePropsBuilder.$transparentWhite.toRgba())) {
          fillColor.$ = this.$headerNodeStyle.grandTotalsFillColor;
        }
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderNodeSortIndicator
  var $tab_HeaderNodeSortIndicator = global.tab.HeaderNodeSortIndicator = ss.mkType($asm, 'tab.HeaderNodeSortIndicator', function(props) {
    this.$offsetFromNodeEdgeClosestToScene = 0;
    this.$isHorizontalSceneMargin = false;
    this.$isHorizontalLabel = false;
    this.$labelHorizontalAlignment = 0;
    this.$isBottomHeader = false;
    this.$canShowIndicatorOnHover = false;
    this.$persistentSortIndicatorClassName = null;
    this.$nodeWidth = 0;
    this.$nodeHeight = 0;
    this.$headerPadding = null;
    this.$sceneMarginLocation = 0;
    this.$invokeSortCommand = null;
    this.$offsetFromNodeEdgeClosestToScene = (props.isHorizontal ? 2 : 1);
    this.$isHorizontalSceneMargin = props.isHorizontal;
    this.$isHorizontalLabel = props.rotation === 0;
    this.$labelHorizontalAlignment = props.headerLabelStyle.hAlign;
    this.$isBottomHeader = props.sceneMarginLocation === 1;
    this.$persistentSortIndicatorClassName = props.persistentSortIndicatorClassName;
    this.$canShowIndicatorOnHover = props.canShowSortIndicatorOnHover;
    this.$nodeWidth = props.width;
    this.$nodeHeight = props.height;
    this.$headerPadding = props.labelPadding;
    this.$sceneMarginLocation = props.sceneMarginLocation;
    this.$invokeSortCommand = props.invokeSortCommand;
  }, {
    sortIndicatorClicked: function HeaderNodeSortIndicator$SortIndicatorClicked(evt) {
      if (this.$canShowHoverIndicator(true)) {
        this.$invokeSortCommand({ x: evt.pageX, y: evt.pageY }, this.$sceneMarginLocation);
      }
    },
    canShowSortIndicator: function HeaderNodeSortIndicator$CanShowSortIndicator(isHovered) {
      if (this.$canShowHoverIndicator(isHovered)) {
        return true;
      }
      return this.$persistentSortIndicatorClassName !== '';
    },
    getSortIndicatorCss: function HeaderNodeSortIndicator$GetSortIndicatorCss() {
      var style = {};
      this.$setSortIndicatorPosition(style);
      if (this.$isHorizontalSceneMargin) {
        style.transform = 'rotate(90deg)';
      }
      return style;
    },
    getSortIndicatorCssClassName: function HeaderNodeSortIndicator$GetSortIndicatorCssClassName(isHovered) {
      if (this.$canShowHoverIndicator(isHovered)) {
        return this.$getHoverIndicatorClassName();
      }
      return this.$persistentSortIndicatorClassName;
    },
    adjustLabelRectangleForSortIndicator: function HeaderNodeSortIndicator$AdjustLabelRectangleForSortIndicator(style) {
      var indicatorSizeWithPadding = $tab_AxisSortIndicator.sortIndicatorSize + this.$offsetFromNodeEdgeClosestToScene;
      if (this.$isHorizontalLabel) {
        var horizontalPadding = this.$headerPadding.left + this.$headerPadding.right;
        var labelRectangleWidth = this.$nodeWidth - horizontalPadding - indicatorSizeWithPadding;
        style.maxWidth = labelRectangleWidth + 'px';
        this.$shiftLabelHorizontally(style, indicatorSizeWithPadding);
      }
      else if (this.$isBottomHeader) {
        var verticalPadding = this.$headerPadding.top + this.$headerPadding.bottom;
        var labelRectangleHeight = this.$nodeHeight - verticalPadding - indicatorSizeWithPadding;
        style.maxHeight = labelRectangleHeight + 'px';
        this.$shiftLabelVertically(style, indicatorSizeWithPadding);
      }
    },
    $shiftLabelHorizontally: function HeaderNodeSortIndicator$ShiftLabelHorizontally(style, indicatorSizeWithPadding) {
      if (this.$labelHorizontalAlignment === 2) {
        style.transform = ss.formatString('translateX({0}px)', -indicatorSizeWithPadding);
      }
      else if (this.$labelHorizontalAlignment === 1) {
        style.transform = ss.formatString('translateX({0}px)', ss.round(-indicatorSizeWithPadding / 2));
      }
    },
    $shiftLabelVertically: function HeaderNodeSortIndicator$ShiftLabelVertically(style, indicatorSizeWithPadding) {
      style.transform = ss.formatString('translateY({0}px)', indicatorSizeWithPadding);
    },
    $indicatorCanFitInHeader: function HeaderNodeSortIndicator$IndicatorCanFitInHeader() {
      return $tab_AxisSortIndicator.sortIndicatorSize < this.$nodeWidth && $tab_AxisSortIndicator.sortIndicatorSize < this.$nodeHeight;
    },
    $canShowHoverIndicator: function HeaderNodeSortIndicator$CanShowHoverIndicator(isHovered) {
      if (this.$indicatorCanFitInHeader()) {
        return isHovered && this.$canShowIndicatorOnHover;
      }
      return false;
    },
    $getHoverIndicatorClassName: function HeaderNodeSortIndicator$GetHoverIndicatorClassName() {
      if (this.$persistentSortIndicatorClassName === 'sortIndLeft') {
        return 'sortIndSolidLeft';
      }
      return 'sortIndSolidRight';
    },
    $setSortIndicatorPosition: function HeaderNodeSortIndicator$SetSortIndicatorPosition(style) {
      if (this.$isHorizontalLabel) {
        style.right = this.$offsetFromNodeEdgeClosestToScene + 'px';
        if (this.$isBottomHeader) {
          style.top = this.$headerPadding.top + 'px';
        }
      }
      else if (this.$isBottomHeader) {
        style.top = this.$offsetFromNodeEdgeClosestToScene + 'px';
      }
      else {
        var indicatorCenter = $tab_AxisSortIndicator.sortIndicatorSize / 2;
        style.left = this.$nodeWidth / 2 - indicatorCenter + 'px';
        style.top = this.$nodeHeight / 2 - indicatorCenter + 'px';
      }
    }
  }, {
    $ctor1: function(props) {
      this.$offsetFromNodeEdgeClosestToScene = 0;
      this.$isHorizontalSceneMargin = false;
      this.$isHorizontalLabel = false;
      this.$labelHorizontalAlignment = 0;
      this.$isBottomHeader = false;
      this.$canShowIndicatorOnHover = false;
      this.$persistentSortIndicatorClassName = null;
      this.$nodeWidth = 0;
      this.$nodeHeight = 0;
      this.$headerPadding = null;
      this.$sceneMarginLocation = 0;
      this.$invokeSortCommand = null;
      this.$offsetFromNodeEdgeClosestToScene = (props.isHorizontal ? 2 : 1);
      this.$isHorizontalSceneMargin = props.isHorizontal;
      this.$isHorizontalLabel = props.headerLabelStyle.text_orientation === 0;
      this.$labelHorizontalAlignment = props.headerLabelStyle.hAlign;
      this.$isBottomHeader = props.sceneMarginLocation === 1;
      this.$canShowIndicatorOnHover = props.canShowSortIndicatorOnHover;
      this.$persistentSortIndicatorClassName = props.persistentSortIndicatorClassName;
      this.$nodeWidth = props.width;
      this.$nodeHeight = props.height;
      this.$headerPadding = props.labelPadding;
      this.$sceneMarginLocation = props.sceneMarginLocation;
      this.$invokeSortCommand = props.invokeSortCommand;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderNonSkippedTextComponent
  var $tab_HeaderNonSkippedTextComponent = global.tab.HeaderNonSkippedTextComponent = ss.mkType($asm, 'tab.HeaderNonSkippedTextComponent', function(nodeProps) {
    this.$sortIndicator = null;
    spiff.PureRenderComponent.call(this, nodeProps);
    this.$sortIndicator = new $tab_HeaderNodeSortIndicator.$ctor1(nodeProps);
    this.state = { isHovered: false };
  }, {
    $getSortIndicatorDiv: function HeaderNonSkippedTextComponent$GetSortIndicatorDiv() {
      return spiff.DOMElements.div({ className: this.$sortIndicator.getSortIndicatorCssClassName(this.state.isHovered), style: this.$sortIndicator.getSortIndicatorCss() });
    },
    $getTextDiv: function HeaderNonSkippedTextComponent$GetTextDiv() {
      return spiff.DOMElements.div({ className: $tab_HeaderNonSkippedTextComponent.nonSkippedTextLabelContainerClass, style: this.$getHeaderTextCss() }, this.props.text);
    },
    render: function HeaderNonSkippedTextComponent$Render() {
      var wrapper = { className: 'tab-vizHeaderNonSkippedWrapper', style: this.$getHeaderWrapperCss(), onMouseOver: ss.mkdel(this, function(evt) {
        this.setState({ isHovered: true });
      }), onMouseLeave: ss.mkdel(this, function(evt1) {
        this.setState({ isHovered: false });
      }) };
      return spiff.DOMElements.div(wrapper, this.$getTextDiv(), (this.props.isNodeSorted ? ss.mkdel(this, function() {
        return this.$getSortIndicatorDiv();
      })() : null));
    },
    $getHeaderWrapperCss: function HeaderNonSkippedTextComponent$GetHeaderWrapperCss() {
      var headerWrapperCss = { left: this.props.left + 'px', width: this.props.width + 'px', height: this.props.height + 'px' };
      this.$setStylePosition(headerWrapperCss);
      if (this.props.headerLabelStyle.text_orientation !== 0) {
        headerWrapperCss.writingMode = $tab_HeaderLabelStyleHelper.writingModeVertical();
      }
      return headerWrapperCss;
    },
    $getHeaderTextCss: function HeaderNonSkippedTextComponent$GetHeaderTextCss() {
      var headerLabelStyleHelper = new $tab_HeaderLabelStyleHelper(this.props.headerLabelStyle, this.props.headerLabelStyle.text_orientation, true);
      var headerTextStyle = headerLabelStyleHelper.getGeneralHeaderLabelCss();
      if (this.props.isNodeSorted) {
        this.$sortIndicator.adjustLabelRectangleForSortIndicator(headerTextStyle);
        if (this.props.headerLabelStyle.text_orientation === -90) {
          headerTextStyle.transform += ' rotate(180deg)';
        }
      }
      return headerTextStyle;
    },
    $setStylePosition: function HeaderNonSkippedTextComponent$SetStylePosition(headerItemStyle) {
      var verticalLabel = this.props.headerLabelStyle.text_orientation !== 0;
      if (verticalLabel && this.props.sceneMarginLocation === 1) {
        headerItemStyle.paddingTop = this.props.labelPadding + 'px';
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderResizerComponent
  var $tab_HeaderResizerComponent = global.tab.HeaderResizerComponent = ss.mkType($asm, 'tab.HeaderResizerComponent', function(props) {
    this.$boundAttachDragSource = null;
    this.$boundElementRef = null;
    this.$resizerObject = null;
    this.$offsetBase = 0;
    spiff.PureRenderComponent.call(this, props);
    this.$boundAttachDragSource = spiff.ReactRefs.attachDragSource(ss.mkdel(this, function() {
      return this;
    }));
    this.$boundElementRef = ss.mkdel(this, function(e) {
      this.$boundAttachDragSource(e);
      this.$resizerObject = $(e);
    });
  }, {
    render: function HeaderResizerComponent$Render() {
      var resizerOrigin = this.$getResizerOrigin();
      var resizerLineStyle = this.$getResizerLineStyle(this.$getResizerLineSize(), this.$getResizerLineOrigin(resizerOrigin));
      var resizerLine = spiff.DOMElements.div({ className: 'tab-vizResizerLine', style: resizerLineStyle }, '');
      var resizerStyle = this.$getResizerStyle(this.$getResizerSize(), resizerOrigin);
      return spiff.DOMElements.div({ className: 'tab-vizHeaderResizer', style: resizerStyle, ref: this.$boundElementRef }, resizerLine);
    },
    get_resizerObject: function HeaderResizerComponent$get_ResizerObject() {
      return this.$resizerObject;
    },
    $shouldResizerBeBelowComponent: function HeaderResizerComponent$ShouldResizerBeBelowComponent() {
      return this.props.sceneMarginLocation === 0 || this.props.sceneMarginLocation === 3;
    },
    $getResizerLineSize: function HeaderResizerComponent$GetResizerLineSize() {
      var isHorizontal = tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation);
      var pixelSize = (isHorizontal ? this.props.sceneMarginViewportSize.w : this.props.sceneMarginViewportSize.h);
      return { w: (!isHorizontal ? 1 : pixelSize), h: (!isHorizontal ? pixelSize : 1) };
    },
    $getResizerLineOrigin: function HeaderResizerComponent$GetResizerLineOrigin(resizerOrigin) {
      var resizerWidth = 2;
      if (!tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        return { x: resizerOrigin.x + resizerWidth, y: 0 };
      }
      else {
        return { x: 0, y: resizerOrigin.y + resizerWidth };
      }
    },
    $getResizerSize: function HeaderResizerComponent$GetResizerSize() {
      var isHorizontal = tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation);
      var resizerWidth = 2 * 2;
      var pixelSize = (isHorizontal ? this.props.sceneMarginViewportSize.w : this.props.sceneMarginViewportSize.h);
      return { w: (!isHorizontal ? resizerWidth : pixelSize), h: (!isHorizontal ? pixelSize : resizerWidth) };
    },
    $getResizerOrigin: function HeaderResizerComponent$GetResizerOrigin() {
      var isHorizontal = tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation);
      var resizerWidth = 2;
      var pixelSize = this.props.pixelSize;
      var left = (isHorizontal ? 0 : this.props.pixelOffset);
      var top = (isHorizontal ? this.props.pixelOffset : 0);
      if (!isHorizontal) {
        left += (this.$shouldResizerBeBelowComponent() ? pixelSize : 0);
        return { x: left - resizerWidth, y: top };
      }
      else {
        top += (this.$shouldResizerBeBelowComponent() ? pixelSize : 0);
        return { x: left, y: top - resizerWidth };
      }
    },
    $getResizerStyle: function HeaderResizerComponent$GetResizerStyle(size, origin) {
      var style = { width: size.w + 'px', height: size.h + 'px', left: origin.x + 'px', top: origin.y + 'px', backgroundColor: 'transparent', position: 'absolute', cursor: (!tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation) ? 'ew-resize' : 'ns-resize') };
      return style;
    },
    $getResizerLineStyle: function HeaderResizerComponent$GetResizerLineStyle(size, origin) {
      var style = { left: origin.x + 'px', top: origin.y + 'px', opacity: 0, border: 'none' };
      if (!tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        style.width = '0px';
        style.height = size.h;
        style.borderRight = '1px dotted';
      }
      else {
        style.width = size.w;
        style.height = '0px';
        style.borderBottom = '1px dotted';
      }
      return style;
    },
    $createDragInstance: function HeaderResizerComponent$CreateDragInstance(e) {
      return new spiff.MoveDragInstance($(e), ss.mkdel(this, this.onMove), ss.mkdel(this, this.onDrop), null);
    },
    acceptsDragType: function HeaderResizerComponent$AcceptsDragType() {
      return 1;
    },
    startDrag: function HeaderResizerComponent$StartDrag(e) {
      if (!tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        this.$offsetBase = tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').offset().left);
        this.updateResizerXPosition(this.$calculateXOffset(e.pageX), e.pageX);
      }
      else {
        this.$offsetBase = tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').offset().top);
        this.updateResizerYPosition(this.$calculateYOffset(e.pageY), e.pageY);
      }
      return this.$createDragInstance(e.target);
    },
    onMove: function HeaderResizerComponent$OnMove(e) {
      this.$resizerObject.children('.' + 'tab-vizResizerLine').css('opacity', 1);
      if (!tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        this.updateResizerXPosition(this.$calculateXOffset(e.pageX), e.pageX);
      }
      else {
        this.updateResizerYPosition(this.$calculateYOffset(e.pageY), e.pageY);
      }
    },
    onDrop: function HeaderResizerComponent$OnDrop(e) {
      this.$resizerObject.children('.' + 'tab-vizResizerLine').css('opacity', 0);
      var sizeDifference = (!tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation) ? this.calculateXSizeDifference(e.pageX) : this.calculateYSizeDifference(e.pageY));
      if ($tab_ResizerConstants.isSizeDifferenceOverThreshold(sizeDifference)) {
        var newSize = sizeDifference + this.props.pixelSize;
        this.props.sendHeaderResizeCommand(this.props.fieldName, newSize);
      }
    },
    updateResizerYPosition: function HeaderResizerComponent$UpdateResizerYPosition(currentOffset, pageY) {
      var isReduced = currentOffset < 0;
      var dragY = pageY - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').height()), 2);
      if (Math.abs(currentOffset) <= 2) {
        var minOffset = (isReduced ? -2 : 2);
        dragY = this.$offsetBase + minOffset;
      }
      if (Math.abs(currentOffset) >= 100) {
        var maxOffset = (isReduced ? -100 : 100);
        dragY = this.$offsetBase + maxOffset;
      }
      var offset = this.$resizerObject.children('.' + 'tab-vizResizerLine').offset();
      this.$resizerObject.children('.' + 'tab-vizResizerLine').offset({ left: offset.left, top: dragY });
    },
    updateResizerXPosition: function HeaderResizerComponent$UpdateResizerXPosition(currentOffset, pageX) {
      var isReduced = currentOffset < 0;
      var dragX = pageX - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').width()), 2);
      if (Math.abs(currentOffset) <= 2) {
        var minOffset = (isReduced ? -2 : 2);
        dragX = this.$offsetBase + minOffset;
      }
      if (Math.abs(currentOffset) >= 100) {
        var maxOffset = (isReduced ? -100 : 100);
        dragX = this.$offsetBase + maxOffset;
      }
      var offset = this.$resizerObject.children('.' + 'tab-vizResizerLine').offset();
      this.$resizerObject.children('.' + 'tab-vizResizerLine').offset({ left: dragX, top: offset.top });
    },
    $calculateYOffset: function HeaderResizerComponent$CalculateYOffset(pageY) {
      var dragY = pageY;
      return dragY - this.$offsetBase;
    },
    $calculateXOffset: function HeaderResizerComponent$CalculateXOffset(pageX) {
      var dragX = pageX;
      return dragX - this.$offsetBase;
    },
    calculateYSizeDifference: function HeaderResizerComponent$CalculateYSizeDifference(pageY) {
      var dragY = pageY - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').height()), 2);
      var dragDifference = dragY - this.$offsetBase;
      var isReduced = (this.$shouldResizerBeBelowComponent() ? (dragDifference < 0) : (dragDifference >= 0));
      var difference = Math.min(Math.max(Math.abs(dragDifference), 2), 100);
      return (isReduced ? -difference : difference);
    },
    calculateXSizeDifference: function HeaderResizerComponent$CalculateXSizeDifference(pageX) {
      var dragX = pageX - ss.idiv(tab.DoubleUtil.roundToInt(this.$resizerObject.children('.' + 'tab-vizResizerLine').width()), 2);
      var dragDifference = dragX - this.$offsetBase;
      var isReduced = (this.$shouldResizerBeBelowComponent() ? (dragDifference < 0) : (dragDifference >= 0));
      var difference = Math.min(Math.max(Math.abs(dragDifference), 2), 100);
      return (isReduced ? -difference : difference);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.HeaderTotalsTypes
  var $tab_HeaderTotalsTypes = global.tab.HeaderTotalsTypes = ss.mkEnum($asm, 'tab.HeaderTotalsTypes', { none: 0, subTotalsType: 1, grandTotalsType: 2 });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.IndicatorPosition
  var $tab_IndicatorPosition = global.tab.IndicatorPosition = ss.mkType($asm, 'tab.IndicatorPosition', function() {
    this.along = 0;
    this.perpendicular = 0;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.LabelRange
  var $tab_LabelRange = global.tab.LabelRange = ss.mkType($asm, 'tab.LabelRange', function() {
    this.$1$FirstLabelIndexField = 0;
    this.$1$LastLabelIndexField = 0;
    this.$1$SkipField = 0;
  }, {
    get_firstLabelIndex: function LabelRange$get_FirstLabelIndex() {
      return this.$1$FirstLabelIndexField;
    },
    set_firstLabelIndex: function LabelRange$set_FirstLabelIndex(value) {
      this.$1$FirstLabelIndexField = value;
    },
    get_lastLabelIndex: function LabelRange$get_LastLabelIndex() {
      return this.$1$LastLabelIndexField;
    },
    set_lastLabelIndex: function LabelRange$set_LastLabelIndex(value) {
      this.$1$LastLabelIndexField = value;
    },
    get_skip: function LabelRange$get_Skip() {
      return this.$1$SkipField;
    },
    set_skip: function LabelRange$set_Skip(value) {
      this.$1$SkipField = value;
    },
    isSkipped: function LabelRange$IsSkipped(index) {
      return !(index >= this.get_firstLabelIndex() && index <= this.get_lastLabelIndex() && ss.imod(index, this.get_skip()) === ss.imod(this.get_firstLabelIndex(), this.get_skip()));
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.LabelSkip
  var $tab_LabelSkip = global.tab.LabelSkip = ss.mkType($asm, 'tab.LabelSkip', function(location, nodeData, labelSkipTable) {
    this.$isSupportingLabelSkip = false;
    this.$curPaneIndices = null;
    this.$labelSkipResults = null;
    this.$labelOffsets = null;
    this.$paneEndIndices = null;
    this.hasSkippedLabels = false;
    this.$isSupportingLabelSkip = location === 1;
    this.$curPaneIndices = new Array(nodeData.length);
    for (var index = 0; index < nodeData.length; ++index) {
      this.$curPaneIndices[index] = nodeData[index].enclosedIndex;
    }
    this.$labelSkipResults = this.$getLabelSkipResultForEachPane(labelSkipTable);
    this.$labelOffsets = (this.$isSupportingLabelSkip ? labelSkipTable.LabelOffset : []);
    this.$paneEndIndices = this.$getEndIndexForEachPane();
    this.hasSkippedLabels = this.$getHasSkippedLabels();
  }, {
    isSkipped: function LabelSkip$IsSkipped(nodeIndex) {
      if (!this.$isSupportingLabelSkip) {
        return false;
      }
      var curPaneIndex = this.$curPaneIndices[nodeIndex];
      var totalNumOfNodesInPreviousPanes = ((curPaneIndex === 0) ? 0 : (this.$paneEndIndices[curPaneIndex - 1] + 1));
      var nodeIndexInsideCurrentPane = nodeIndex - totalNumOfNodesInPreviousPanes;
      var visibleLabelRange = this.getLabelSkipResult(nodeIndex).getLabelRangeWithVisibleText(((this.$labelOffsets.length === 0) ? 0 : this.$labelOffsets[curPaneIndex]), this.$paneEndIndices[curPaneIndex] - totalNumOfNodesInPreviousPanes);
      return visibleLabelRange.isSkipped(nodeIndexInsideCurrentPane);
    },
    $getHasSkippedLabels: function LabelSkip$GetHasSkippedLabels() {
      if (!this.$isSupportingLabelSkip) {
        return false;
      }
      for (var $t1 = 0; $t1 < this.$paneEndIndices.length; $t1++) {
        var paneEndIndex = this.$paneEndIndices[$t1];
        if (this.paneHasSkippedLabel(paneEndIndex)) {
          return true;
        }
      }
      return false;
    },
    paneHasSkippedLabel: function LabelSkip$PaneHasSkippedLabel(nodeIndex) {
      if (!this.$isSupportingLabelSkip) {
        return false;
      }
      var curPaneIndex = this.$curPaneIndices[nodeIndex];
      if (this.$labelOffsets[curPaneIndex] > 0) {
        return true;
      }
      var labelSkipResult = this.getLabelSkipResult(nodeIndex);
      return labelSkipResult.get_skip() > 1 || !labelSkipResult.get_includeFirstLabel() || !labelSkipResult.get_includeLastLabel();
    },
    getLabelSkipResult: function LabelSkip$GetLabelSkipResult(nodeIndex) {
      var curPaneIndex = this.$curPaneIndices[nodeIndex];
      return this.$labelSkipResults[curPaneIndex];
    },
    getSkip: function LabelSkip$GetSkip(nodeIndex) {
      return this.getLabelSkipResult(nodeIndex).get_skip();
    },
    $getLabelSkipResultForEachPane: function LabelSkip$GetLabelSkipResultForEachPane(labelSkipTable) {
      if (!this.$isSupportingLabelSkip) {
        return [];
      }
      var enclosureCount = this.$curPaneIndices[this.$curPaneIndices.length - 1] + 1;
      var result = new Array(enclosureCount);
      for (var i = 0; i < enclosureCount; i++) {
        result[i] = new $tab_LabelSkipResult(labelSkipTable.Skip[i], labelSkipTable.IncludeFirstLabel[i], labelSkipTable.IncludeLastLabel[i]);
      }
      return result;
    },
    $getEndIndexForEachPane: function LabelSkip$GetEndIndexForEachPane() {
      if (!this.$isSupportingLabelSkip) {
        return [];
      }
      var enclosureCount = this.$curPaneIndices[this.$curPaneIndices.length - 1] + 1;
      var result = new Array(enclosureCount);
      for (var nodeIndex = 0; nodeIndex < this.$curPaneIndices.length - 1; ++nodeIndex) {
        if (this.$curPaneIndices[nodeIndex + 1] > this.$curPaneIndices[nodeIndex]) {
          result[this.$curPaneIndices[nodeIndex]] = nodeIndex;
        }
      }
      result[enclosureCount - 1] = this.$curPaneIndices.length - 1;
      return result;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.LabelSkipResult
  var $tab_LabelSkipResult = global.tab.LabelSkipResult = ss.mkType($asm, 'tab.LabelSkipResult', function(skip, includeFirstLabel, includeLastLabel) {
    this.$1$SkipField = 0;
    this.$1$IncludeFirstLabelField = false;
    this.$1$IncludeLastLabelField = false;
    this.set_skip(skip);
    this.set_includeFirstLabel(includeFirstLabel);
    this.set_includeLastLabel(includeLastLabel);
  }, {
    get_skip: function LabelSkipResult$get_Skip() {
      return this.$1$SkipField;
    },
    set_skip: function LabelSkipResult$set_Skip(value) {
      this.$1$SkipField = value;
    },
    get_includeFirstLabel: function LabelSkipResult$get_IncludeFirstLabel() {
      return this.$1$IncludeFirstLabelField;
    },
    set_includeFirstLabel: function LabelSkipResult$set_IncludeFirstLabel(value) {
      this.$1$IncludeFirstLabelField = value;
    },
    get_includeLastLabel: function LabelSkipResult$get_IncludeLastLabel() {
      return this.$1$IncludeLastLabelField;
    },
    set_includeLastLabel: function LabelSkipResult$set_IncludeLastLabel(value) {
      this.$1$IncludeLastLabelField = value;
    },
    getLabelRangeWithVisibleText: function LabelSkipResult$GetLabelRangeWithVisibleText(startIndex, endIndex) {
      var firstTickIndex = startIndex + (this.get_includeFirstLabel() ? 0 : this.get_skip());
      var lastTickIndex = endIndex - ss.imod(endIndex - startIndex, this.get_skip());
      if (!this.get_includeLastLabel()) {
        lastTickIndex -= this.get_skip();
      }
      var $t1 = new $tab_LabelRange();
      $t1.set_firstLabelIndex(firstTickIndex);
      $t1.set_lastLabelIndex(lastTickIndex);
      $t1.set_skip(this.get_skip());
      return $t1;
    }
  }, {
    generateFromLabelSkipTable: function LabelSkipResult$GenerateFromLabelSkipTable(labelSkip, tickPlacementIndex) {
      var labelSkipTableSize = (ss.isNullOrUndefined(labelSkip) ? 0 : labelSkip.HeaderIndex.length);
      for (var index = 0; index < labelSkipTableSize; index++) {
        if (labelSkip.HeaderIndex[index] === tickPlacementIndex) {
          return new $tab_LabelSkipResult(labelSkip.Skip[index], labelSkip.IncludeFirstLabel[index], labelSkip.IncludeLastLabel[index]);
        }
      }
      return new $tab_LabelSkipResult(1, true, true);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.MinMaxPair
  var $tab_MinMaxPair = global.tab.MinMaxPair = ss.mkType($asm, 'tab.MinMaxPair', function(minValue, maxValue) {
    this.min = 0;
    this.max = 0;
    this.min = minValue;
    this.max = maxValue;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.NestedSortIndicatorDataTableRow
  var $tab_NestedSortIndicatorDataTableRow = global.tab.NestedSortIndicatorDataTableRow = ss.mkType($asm, 'tab.NestedSortIndicatorDataTableRow', function() {
    this.indicatorDirection = null;
    this.tooltip = null;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.NodeInfo
  var $tab_NodeInfo = global.tab.NodeInfo = ss.mkType($asm, 'tab.NodeInfo', function() {
    this.hash = 0;
    this.extentsX = 0;
    this.extentsY = 0;
    this.extentsWidth = 0;
    this.extentsHeight = 0;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.NodeInfoConverter
  var $tab_NodeInfoConverter = global.tab.NodeInfoConverter = ss.mkType($asm, 'tab.NodeInfoConverter', function(marginLocation, layoutTable, nodeData, sceneMarginLayout, foldStateOfAllNodes) {
    this.$marginLocation = 0;
    this.$layoutTable = null;
    this.$nodeIds = null;
    this.$sceneMarginLayout = null;
    this.$foldStateOfAllNodes = null;
    this.$marginLocation = marginLocation;
    this.$layoutTable = layoutTable;
    this.$nodeIds = nodeData.Id;
    this.$sceneMarginLayout = sceneMarginLayout;
    this.$foldStateOfAllNodes = foldStateOfAllNodes;
  }, {
    convert: function NodeInfoConverter$Convert(marginRow) {
      var level = this.$sceneMarginLayout.HeaderDepth[marginRow];
      var isHorizontal = tab.SceneMarginModel.isHorizontal(this.$marginLocation);
      var elementType = this.$sceneMarginLayout.ElementType[marginRow];
      var isAxis = elementType === 0 || elementType === 1;
      var isMarginFolded = elementType === 1;
      var nodeInfoList = [];
      for (var i = 0; i < this.$layoutTable.Level.length; i++) {
        var nodeLevel = this.$layoutTable.Level[i];
        var isNodeFolded = this.$foldStateOfAllNodes[i] !== 0;
        if (isAxis && isNodeFolded !== isMarginFolded) {
          continue;
        }
        if (nodeLevel !== level) {
          continue;
        }
        var nodeInfo;
        if (isHorizontal) {
          var $t1 = new $tab_NodeInfo();
          $t1.hash = this.$calcNodeHash(i);
          $t1.extentsWidth = this.$layoutTable.AlongDirectionPixelSize[i];
          $t1.extentsHeight = this.$sceneMarginLayout.PixelSize[marginRow];
          $t1.extentsX = this.$layoutTable.AlongDirectionPixelOffset[i];
          $t1.extentsY = this.$sceneMarginLayout.PixelOffset[marginRow];
          nodeInfo = $t1;
        }
        else {
          var $t2 = new $tab_NodeInfo();
          $t2.hash = this.$calcNodeHash(i);
          $t2.extentsWidth = this.$sceneMarginLayout.PixelSize[marginRow];
          $t2.extentsHeight = this.$layoutTable.AlongDirectionPixelSize[i];
          $t2.extentsX = this.$sceneMarginLayout.PixelOffset[marginRow];
          $t2.extentsY = this.$layoutTable.AlongDirectionPixelOffset[i];
          nodeInfo = $t2;
        }
        nodeInfoList.push(nodeInfo);
      }
      return nodeInfoList;
    },
    $calcNodeHash: function NodeInfoConverter$CalcNodeHash(nodeLevel) {
      var nodeHash = this.$nodeIds[nodeLevel];
      nodeHash >>>= 0;
      return nodeHash;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.NodeUtils
  var $tab_NodeUtils = global.tab.NodeUtils = ss.mkType($asm, 'tab.NodeUtils', null, null, {
    toNodeHash: function NodeUtils$ToNodeHash(id) {
      var nodeHash = id;
      nodeHash = nodeHash >>> 0;
      return nodeHash;
    },
    getIdForNodeHash: function NodeUtils$GetIdForNodeHash(nodeHash, isHorizontal) {
      var orientation = (isHorizontal ? 1 : 0);
      return nodeHash.toString() + orientation;
    },
    getLabelText: function NodeUtils$GetLabelText(fullText, labelForRender) {
      return ((labelForRender === '') ? fullText : labelForRender);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.NonScrollableHolderComponent
  var $tab_NonScrollableHolderComponent = global.tab.NonScrollableHolderComponent = ss.mkType($asm, 'tab.NonScrollableHolderComponent', function(props) {
    this.$isHorizontal = false;
    spiff.PureRenderComponent.call(this, props);
    this.$isHorizontal = tab.SceneMarginModel.isHorizontal(props.sceneMarginLocation);
  }, {
    render: function NonScrollableHolderComponent$Render() {
      var resizers = null;
      if (tsConfig.is_authoring) {
        resizers = this.$getResizers();
      }
      var sideBorders = this.$getSideBorders();
      return spiff.DOMElements.div({ className: 'tab-vizNonScrollableHolderContainer' }, resizers, sideBorders);
    },
    $getResizers: function NonScrollableHolderComponent$GetResizers() {
      var resizers = [];
      if (!ss.isNullOrUndefined(this.props.headerStackProps)) {
        for (var i = 0; i < this.props.headerStackProps.length; ++i) {
          var headerHolderProps = this.props.headerStackProps[i];
          var headerResizer = React.createElement($tab_HeaderResizerComponent, headerHolderProps);
          resizers.push(headerResizer);
        }
      }
      if (!ss.isNullOrUndefined(this.props.axisProps)) {
        var axisHolderProps = this.props.axisProps;
        if (ss.isValue(axisHolderProps.axisResizers)) {
          for (var $t1 = 0; $t1 < axisHolderProps.axisResizers.length; $t1++) {
            var resizerProps = axisHolderProps.axisResizers[$t1];
            var axisResizer = React.createElement($tab_AxisResizerComponent, resizerProps);
            resizers.push(axisResizer);
          }
        }
      }
      return resizers;
    },
    $getSideBorders: function NonScrollableHolderComponent$GetSideBorders() {
      var sideBorders = [];
      var borderAttributes = this.props.borderDataModel.get_sideBorder();
      if (ss.isNullOrUndefined(borderAttributes)) {
        return sideBorders;
      }
      var orientedViewportSize = $tab_OrientedSize.makeOrientedSize(this.props.viewportSize.w, this.props.viewportSize.h, this.$isHorizontal);
      var alongSize = orientedViewportSize.get_width();
      var perpendicularSize = (this.$shouldUpdatePerpendicularSize(orientedViewportSize.get_height()) ? this.$getUpdatedPerpendicularSize() : orientedViewportSize.get_height());
      var isLineHorizontal = !this.$isHorizontal;
      var secondStartPoint = (this.$isHorizontal ? { x: alongSize - 1, y: 0 } : { x: 0, y: alongSize - 1 });
      sideBorders.push($tab_BorderRenderer.drawLine({ x: 0, y: 0 }, perpendicularSize, borderAttributes, isLineHorizontal));
      sideBorders.push($tab_BorderRenderer.drawLine(secondStartPoint, perpendicularSize, borderAttributes, isLineHorizontal));
      return sideBorders;
    },
    $getUpdatedPerpendicularSize: function NonScrollableHolderComponent$GetUpdatedPerpendicularSize() {
      if (ss.isValue(this.props.axisProps)) {
        return this.props.axisProps.pixelSize;
      }
      else {
        return this.props.headerStackProps[0].pixelSize;
      }
    },
    $shouldUpdatePerpendicularSize: function NonScrollableHolderComponent$ShouldUpdatePerpendicularSize(perpendicularSize) {
      if (perpendicularSize === 0 || ss.isNullOrUndefined(this.props.axisProps) && (ss.isNullOrUndefined(this.props.headerStackProps) || this.props.headerStackProps.length === 0)) {
        return false;
      }
      return this.props.sceneMarginLocation === 1 || this.props.sceneMarginLocation === 2;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.OrientedSize
  var $tab_OrientedSize = global.tab.OrientedSize = ss.mkType($asm, 'tab.OrientedSize', function(isHorizontal) {
    this.$isHorizontal = false;
    this.$along = 0;
    this.$perpendicular = 0;
    this.$isHorizontal = isHorizontal;
  }, {
    get_along: function OrientedSize$get_Along() {
      return this.$along;
    },
    set_along: function OrientedSize$set_Along(value) {
      this.$along = value;
    },
    get_perpendicular: function OrientedSize$get_Perpendicular() {
      return this.$perpendicular;
    },
    set_perpendicular: function OrientedSize$set_Perpendicular(value) {
      this.$perpendicular = value;
    },
    get_width: function OrientedSize$get_Width() {
      return (this.$isHorizontal ? this.$along : this.$perpendicular);
    },
    set_width: function OrientedSize$set_Width(value) {
      if (this.$isHorizontal) {
        this.$along = value;
      }
      else {
        this.$perpendicular = value;
      }
    },
    get_height: function OrientedSize$get_Height() {
      return (this.$isHorizontal ? this.$perpendicular : this.$along);
    },
    set_height: function OrientedSize$set_Height(value) {
      if (this.$isHorizontal) {
        this.$perpendicular = value;
      }
      else {
        this.$along = value;
      }
    }
  }, {
    makeOrientedSize: function OrientedSize$MakeOrientedSize(along, perpendicular, isHorizontal) {
      var $t1 = new $tab_OrientedSize(isHorizontal);
      $t1.set_along(along);
      $t1.set_perpendicular(perpendicular);
      return $t1;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.OuterBorderComponent
  var $tab_OuterBorderComponent = global.tab.OuterBorderComponent = ss.mkType($asm, 'tab.OuterBorderComponent', function(props) {
    spiff.PureRenderComponent.call(this, props);
  }, {
    render: function OuterBorderComponent$Render() {
      var borders = [];
      if (this.props.sceneMarginLocation === 1 || this.props.sceneMarginLocation === 2) {
        var alongMarginOutsideBorder = this.$drawAlongMarginOutsideBorder(this.props.actualAlongMarginSize);
        borders.push(alongMarginOutsideBorder);
      }
      else {
        var alongMarginBorders = this.$getAlongMarginBorders(this.props.actualAlongMarginSize);
        ss.arrayAddRange(borders, alongMarginBorders);
      }
      return spiff.DOMElements.div({ className: 'tab-vizBorderHolder' }, borders);
    },
    $drawAlongMarginOutsideBorder: function OuterBorderComponent$DrawAlongMarginOutsideBorder(alongMarginSize) {
      if (ss.isNullOrUndefined(this.props.borderDataModel.get_alongAxisBorder())) {
        return null;
      }
      var startPoint = null;
      var isLineHorizontal = tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation);
      var borderOffset = ss.round(this.props.borderDataModel.get_alongAxisBorder().borderWidth / 2);
      switch (this.props.sceneMarginLocation) {
        case 0: {
          startPoint = { x: 0, y: 0 };
          break;
        }
        case 1: {
          startPoint = { x: 0, y: this.props.perpendicularSize - 2 - borderOffset };
          break;
        }
        case 3: {
          startPoint = { x: this.props.perpendicularSize, y: 0 };
          break;
        }
        case 2: {
          startPoint = { x: this.props.perpendicularSize - 2 - borderOffset, y: 0 };
          break;
        }
      }
      return $tab_BorderRenderer.drawLine(startPoint, alongMarginSize, this.props.borderDataModel.get_alongAxisBorder(), isLineHorizontal);
    },
    $getAlongMarginBorders: function OuterBorderComponent$GetAlongMarginBorders(totalAlongMarginSize) {
      var alongMarginBorders = [];
      if (ss.isNullOrUndefined(this.props.borderDataModel.get_alongAxisBorder())) {
        return alongMarginBorders;
      }
      var borderAttributes = this.props.borderDataModel.get_alongAxisBorder();
      for (var $t1 = 0; $t1 < this.props.alongMarginOffsets.length; $t1++) {
        var offset = this.props.alongMarginOffsets[$t1];
        var isHorizontal = tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation);
        var startPoint = (isHorizontal ? { x: 0, y: offset } : { x: offset, y: 0 });
        var alongMarginBorder = $tab_BorderRenderer.drawLine(startPoint, totalAlongMarginSize, borderAttributes, isHorizontal);
        alongMarginBorders.push(alongMarginBorder);
      }
      return alongMarginBorders;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.OuterBorderViewModel
  var $tab_OuterBorderViewModel = global.tab.OuterBorderViewModel = ss.mkType($asm, 'tab.OuterBorderViewModel', function(sceneMarginLocation, borderDataModel, sceneMarginModel) {
    this.$sceneMarginLocation = 0;
    this.$borderDataModel = null;
    this.$sceneMarginLayout = null;
    this.$layoutTable = null;
    this.$actualAlongMarginSize = 0;
    this.$perpendicularSize = 0;
    this.$sceneMarginModel = null;
    ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]).call(this);
    this.$sceneMarginLocation = sceneMarginLocation;
    this.$borderDataModel = borderDataModel;
    this.$sceneMarginLayout = sceneMarginModel.get_sceneMarginLayout();
    this.$layoutTable = sceneMarginModel.get_layoutTable();
    this.$actualAlongMarginSize = this.$getActualAlongMarginSize();
    this.$sceneMarginModel = sceneMarginModel;
  }, {
    set_sceneMarginViewportSize: function OuterBorderViewModel$set_SceneMarginViewportSize(value) {
      if (this.$sceneMarginModel.isHorizontal()) {
        this.$perpendicularSize = value.h;
      }
      else {
        this.$perpendicularSize = value.w;
      }
      this.incrementProps();
    },
    createInitialProps: function OuterBorderViewModel$CreateInitialProps() {
      var outerBorderProps = { sceneMarginLocation: this.$sceneMarginLocation, borderDataModel: this.$borderDataModel };
      return outerBorderProps;
    },
    createUpdatedProps: function OuterBorderViewModel$CreateUpdatedProps() {
      return { actualAlongMarginSize: this.$actualAlongMarginSize, perpendicularSize: this.$perpendicularSize, alongMarginOffsets: this.$getAlongMarginOffsets() };
    },
    $getActualAlongMarginSize: function OuterBorderViewModel$GetActualAlongMarginSize() {
      return this.$layoutTable.AlongDirectionPixelSize[0];
    },
    $getAlongMarginOffsets: function OuterBorderViewModel$GetAlongMarginOffsets() {
      var alongMarginOffsets = [];
      for (var i = 0; i < this.$sceneMarginLayout.SceneMarginLocation.length; i++) {
        if (this.$sceneMarginLayout.SceneMarginLocation[i] === this.$sceneMarginLocation) {
          alongMarginOffsets.push(this.$sceneMarginLayout.PixelOffset[i]);
        }
      }
      return alongMarginOffsets;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.PerNodeData
  var $tab_PerNodeData = global.tab.PerNodeData = ss.mkType($asm, 'tab.PerNodeData', function() {
    this.fullText = null;
    this.labelForRender = null;
    this.isLeaf = false;
    this.enclosedIndex = 0;
    this.level = 0;
    this.totalType = 0;
    this.isBandFilled = false;
    this.nodeTableIndex = 0;
    this.id = null;
    this.numLeaves = 0;
    this.leftmostLeafIndex = 0;
    this.borderStartLevel = 0;
    this.canShowSortIndicatorOnHover = false;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.ResizerConstants
  var $tab_ResizerConstants = global.tab.ResizerConstants = ss.mkType($asm, 'tab.ResizerConstants', null, null, {
    isSizeDifferenceOverThreshold: function ResizerConstants$IsSizeDifferenceOverThreshold(sizeDifference) {
      return Math.abs(sizeDifference) > 1;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginBorderBuilder
  var $tab_SceneMarginBorderBuilder = global.tab.SceneMarginBorderBuilder = ss.mkType($asm, 'tab.SceneMarginBorderBuilder', null, null, {
    build: function SceneMarginBorderBuilder$Build(perAxisBorderStyles, location) {
      var defaultBorder = $tab_SceneMarginBorderBuilder.$toBorderAttributes(perAxisBorderStyles.DefaultDividerPenColor, perAxisBorderStyles.DefaultDividerPenStyle, perAxisBorderStyles.DefaultDividerPenWidth);
      var totalBorder = $tab_SceneMarginBorderBuilder.$toBorderAttributes(perAxisBorderStyles.SubtotalDividerPenColor, perAxisBorderStyles.SubtotalDividerPenStyle, perAxisBorderStyles.SubtotalDividerPenWidth);
      var grandTotalBorder = $tab_SceneMarginBorderBuilder.$toBorderAttributes(perAxisBorderStyles.GrandTotalDividerPenColor, perAxisBorderStyles.GrandTotalDividerPenStyle, perAxisBorderStyles.GrandTotalDividerPenWidth);
      var customDivider = $tab_SceneMarginBorderBuilder.$toBorderAttributes(perAxisBorderStyles.CustomDividerPenColor, perAxisBorderStyles.CustomDividerPenStyle, perAxisBorderStyles.CustomDividerPenWidth);
      return new $tab_BorderDataModel(defaultBorder, totalBorder, grandTotalBorder, customDivider, perAxisBorderStyles.CustomDividerTargetDepth, location);
    },
    $toBorderAttributes: function SceneMarginBorderBuilder$ToBorderAttributes(dividerPenColor, dividerPenStyle, dividerPenWidth) {
      var $t1 = new $tab_BorderAttributes();
      $t1.color = dividerPenColor;
      $t1.borderWidth = dividerPenWidth * 2;
      $t1.borderStyle = dividerPenStyle;
      var borderAttributes = $t1;
      return borderAttributes;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginComponent
  var $tab_SceneMarginComponent = global.tab.SceneMarginComponent = ss.mkType($asm, 'tab.SceneMarginComponent', function(props) {
    this.$updateShortcutRef = null;
    this.$arrowKeysShortcut = null;
    this.$enterSceneMarginShortcut = null;
    this.$exitSceneMarginShortcut = null;
    spiff.PureRenderComponent.call(this, props);
    this.$updateShortcutRef = ss.mkdel(this, this.$resetShortcuts);
  }, {
    render: function SceneMarginComponent$Render() {
      var hasAxis = !ss.isNullOrUndefined(this.props.axisProps);
      var hasFieldLabel = this.$hasFieldLabel();
      var hasHeader = !ss.isNullOrUndefined(this.props.headerStackProps);
      var numChildren = (hasHeader ? this.props.headerStackProps.length : 0) + (hasAxis ? 1 : 0) + (hasFieldLabel ? 1 : 0);
      var children = [];
      if (hasFieldLabel) {
        children.push(React.createElement($tab_FieldLabelComponent, this.props.fieldLabelProps));
      }
      if (hasHeader) {
        for (var i = 0; i < this.props.headerStackProps.length; ++i) {
          var headerHolderProps = this.props.headerStackProps[i];
          children.push(React.createElement($tab_HeaderHolderComponent, headerHolderProps));
        }
      }
      if (hasAxis) {
        children.push(React.createElement($tab_AxisHolderComponent, this.props.axisProps));
      }
      children.push(React.createElement($tab_OuterBorderComponent, this.props.outerBorderProps));
      return spiff.DOMElements.div({ style: this.$getSceneMarginStyle(), ref: this.$updateShortcutRef, className: $tab_SceneMarginComponent.getMarginClassName(this.props.sceneMarginLocation), tabIndex: this.$getTabIndex(), onBlur: ss.mkdel(this, this.$onBlur) }, children);
    },
    $getSceneMarginStyle: function SceneMarginComponent$GetSceneMarginStyle() {
      var style = {};
      if (tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation)) {
        style.left = -this.props.scrollOffset + 'px';
      }
      else {
        style.top = -this.props.scrollOffset + 'px';
      }
      return style;
    },
    $hasFieldLabel: function SceneMarginComponent$HasFieldLabel() {
      if (ss.isNullOrUndefined(this.props.fieldLabelProps)) {
        return false;
      }
      return !ss.isNullOrUndefined(this.props.fieldLabelProps.text) && !ss.isNullOrUndefined(this.props.fieldLabelProps.style);
    },
    $getTabIndex: function SceneMarginComponent$GetTabIndex() {
      return ((tab.SceneMarginModel.isKeyboardAccessibilityEnabled() && this.props.focusState === 1) ? 0 : -1);
    },
    $onBlur: function SceneMarginComponent$OnBlur(focusEvent) {
      var target = focusEvent.currentTarget;
      window.setTimeout(ss.mkdel(this, function() {
        if (!target.contains(document.activeElement)) {
          this.props.handleFocusLostEvent();
        }
      }));
    },
    componentWillUnmount: function SceneMarginComponent$ComponentWillUnmount() {
      this.$unregisterAllShortcutsIfPreviouslyRegistered();
    },
    $unregisterAllShortcutsIfPreviouslyRegistered: function SceneMarginComponent$UnregisterAllShortcutsIfPreviouslyRegistered() {
      if (ss.isValue(this.$arrowKeysShortcut)) {
        KeyboardShortcuts.KeyboardShortcutManager.UnregisterShortcut(this.$arrowKeysShortcut);
        this.$arrowKeysShortcut = null;
      }
      if (ss.isValue(this.$enterSceneMarginShortcut)) {
        KeyboardShortcuts.KeyboardShortcutManager.UnregisterShortcut(this.$enterSceneMarginShortcut);
        this.$enterSceneMarginShortcut = null;
      }
      if (ss.isValue(this.$exitSceneMarginShortcut)) {
        KeyboardShortcuts.KeyboardShortcutManager.UnregisterShortcut(this.$exitSceneMarginShortcut);
        this.$exitSceneMarginShortcut = null;
      }
    },
    $resetShortcuts: function SceneMarginComponent$ResetShortcuts(elem) {
      if (tab.SceneMarginModel.isKeyboardAccessibilityEnabled() && !ss.isNullOrUndefined(elem)) {
        this.$enterSceneMarginShortcut = new $tab_SceneMarginEnterSpaceKeyboardShortcut(elem, this.props.handleEnterOrSpaceKeyEvent);
        KeyboardShortcuts.KeyboardShortcutManager.RegisterShortcut(this.$enterSceneMarginShortcut);
        this.$arrowKeysShortcut = new $tab_ArrowKeyNavKeyboardShortcut(elem, this.props.handleArrowKeyEvent);
        KeyboardShortcuts.KeyboardShortcutManager.RegisterShortcut(this.$arrowKeysShortcut);
        this.$exitSceneMarginShortcut = new $tab_SceneMarginEscKeyboardShortcut(elem, this.props.handleEscKeyEvent);
        KeyboardShortcuts.KeyboardShortcutManager.RegisterShortcut(this.$exitSceneMarginShortcut);
      }
    }
  }, {
    getMarginClassName: function SceneMarginComponent$GetMarginClassName(sceneMarginLocation) {
      switch (sceneMarginLocation) {
        case 1: {
          return 'tab-vizBottomSceneMargin';
        }
        case 3: {
          return 'tab-vizLeftSceneMargin';
        }
        case 0: {
          return 'tab-vizTopSceneMargin';
        }
        case 2: {
          return 'tab-vizRightSceneMargin';
        }
      }
      return 'tab-vizUnknownSceneMarign';
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginElement
  var $tab_SceneMarginElement = global.tab.SceneMarginElement = ss.mkType($asm, 'tab.SceneMarginElement', function(domNode, domNodeForInteraction, sceneVm) {
    $tab_BaseSceneMarginElement.call(this, domNode, domNodeForInteraction, sceneVm);
    this.viewModel = sceneVm;
    this.reactView = tab.ObjectRegistry.newView(ss.makeGenericType(spiff.ReactHostView$3, [$tab_SceneMarginViewModel, $tab_SceneMarginComponent, Object])).call(null, [sceneVm]);
    this.reactView.addToDom(domNode);
    this.reactViewForInteraction = tab.ObjectRegistry.newView(ss.makeGenericType(spiff.ReactHostView$3, [$tab_SceneMarginViewModel, $tab_NonScrollableHolderComponent, Object])).call(null, [sceneVm]);
    this.reactViewForInteraction.addToDom(domNodeForInteraction);
  }, {
    resize: function SceneMarginElement$Resize() {
      var sceneVm = ss.safeCast(this.get_viewModel(), $tab_SceneMarginViewModel);
      if (ss.isValue(sceneVm) && !tab.SizeUtil.equals(sceneVm.get_viewportSize(), this.actualViewSize)) {
        sceneVm.set_viewportSize(this.actualViewSize);
      }
    },
    updateScrollPos: function SceneMarginElement$UpdateScrollPos() {
      var sceneVm = ss.safeCast(this.get_viewModel(), $tab_SceneMarginViewModel);
      if (ss.isValue(sceneVm) && !tab.PointUtil.equals(sceneVm.get_scrollPos(), this.scrollPos)) {
        sceneVm.set_scrollPos(this.scrollPos);
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginEnterSpaceKeyboardShortcut
  var $tab_SceneMarginEnterSpaceKeyboardShortcut = global.tab.SceneMarginEnterSpaceKeyboardShortcut = ss.mkType($asm, 'tab.SceneMarginEnterSpaceKeyboardShortcut', function(elem, enterSceneMarginHandler) {
    this.$elem = null;
    this.$enterSceneMarginHandler = null;
    KeyboardShortcuts.BaseKeyboardShortcut.call(this);
    this.$elem = elem;
    this.$enterSceneMarginHandler = enterSceneMarginHandler;
  }, {
    getKeyComboOrKeyCombos: function SceneMarginEnterSpaceKeyboardShortcut$GetKeyComboOrKeyCombos() {
      return new KeyboardShortcuts.KeyCombos(new KeyboardShortcuts.KeyCombo('Enter', null), new KeyboardShortcuts.KeyCombo(' ', null));
    },
    getElement: function SceneMarginEnterSpaceKeyboardShortcut$GetElement() {
      return this.$elem;
    },
    isAllowed: function SceneMarginEnterSpaceKeyboardShortcut$IsAllowed(e) {
      return ss.isValue(e.target);
    },
    executeShortcut: function SceneMarginEnterSpaceKeyboardShortcut$ExecuteShortcut(e) {
      var target = e.target;
      this.$enterSceneMarginHandler(target.id);
    },
    getTelemetryKey: function SceneMarginEnterSpaceKeyboardShortcut$GetTelemetryKey() {
      return 'Enter scene margin';
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginEscKeyboardShortcut
  var $tab_SceneMarginEscKeyboardShortcut = global.tab.SceneMarginEscKeyboardShortcut = ss.mkType($asm, 'tab.SceneMarginEscKeyboardShortcut', function(elem, exitSceneMarginHandler) {
    this.$elem = null;
    this.$exitSceneMarginHandler = null;
    KeyboardShortcuts.BaseKeyboardShortcut.call(this);
    this.$elem = elem;
    this.$exitSceneMarginHandler = exitSceneMarginHandler;
  }, {
    getKeyComboOrKeyCombos: function SceneMarginEscKeyboardShortcut$GetKeyComboOrKeyCombos() {
      return new KeyboardShortcuts.KeyCombos(new KeyboardShortcuts.KeyCombo('Escape', null));
    },
    getElement: function SceneMarginEscKeyboardShortcut$GetElement() {
      return this.$elem;
    },
    isAllowed: function SceneMarginEscKeyboardShortcut$IsAllowed(e) {
      return ss.isValue(e.target);
    },
    executeShortcut: function SceneMarginEscKeyboardShortcut$ExecuteShortcut(e) {
      this.$exitSceneMarginHandler();
    },
    getTelemetryKey: function SceneMarginEscKeyboardShortcut$GetTelemetryKey() {
      return 'Scene Margin Esc key pressed';
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginFocusState
  var $tab_SceneMarginFocusState = global.tab.SceneMarginFocusState = ss.mkEnum($asm, 'tab.SceneMarginFocusState', { inside: 0, outside: 1 });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginHitTester
  var $tab_SceneMarginHitTester = global.tab.SceneMarginHitTester = ss.mkType($asm, 'tab.SceneMarginHitTester', function(nodeInfoConverter, sceneMarginLocation, locationArray) {
    this.$isHorizontal = false;
    this.$sceneMarginLocation = 0;
    this.$nodeInfoConverter = null;
    this.$rowCount = 0;
    this.$locationArray = null;
    this.$nodeListsCache = {};
    this.$1$IsMouseOverSortIndicatorField = false;
    this.$nodeInfoConverter = nodeInfoConverter;
    this.$isHorizontal = tab.SceneMarginModel.isHorizontal(sceneMarginLocation);
    this.$sceneMarginLocation = sceneMarginLocation;
    this.$rowCount = locationArray.length;
    this.$locationArray = locationArray;
  }, {
    get_isMouseOverSortIndicator: function SceneMarginHitTester$get_IsMouseOverSortIndicator() {
      return this.$1$IsMouseOverSortIndicatorField;
    },
    set_isMouseOverSortIndicator: function SceneMarginHitTester$set_IsMouseOverSortIndicator(value) {
      this.$1$IsMouseOverSortIndicatorField = value;
    },
    hitTestNodes: function SceneMarginHitTester$HitTestNodes(coords) {
      for (var i = 0; i < this.$rowCount; i++) {
        if (ss.equals(this.$locationArray[i], this.$sceneMarginLocation)) {
          var nodeInfoList = this.$getNodeInfoList(i);
          var nodeInfoHit = $tab_SceneMarginHitTester.$hitTest(coords, nodeInfoList);
          if (ss.isValue(nodeInfoHit)) {
            return nodeInfoHit;
          }
        }
      }
      return null;
    },
    getNodeWithId: function SceneMarginHitTester$GetNodeWithId(id) {
      for (var i = 0; i < this.$rowCount; i++) {
        if (ss.equals(this.$locationArray[i], this.$sceneMarginLocation)) {
          var nodeInfoHit = _.find(this.$getNodeInfoList(i), ss.mkdel(this, function(nodeInfo) {
            return ss.referenceEquals(this.$getIdForNodeHash(nodeInfo.hash), id);
          }));
          if (ss.isValue(nodeInfoHit)) {
            return nodeInfoHit;
          }
        }
      }
      return null;
    },
    updateIsMouseOverSortIndicator: function SceneMarginHitTester$UpdateIsMouseOverSortIndicator(isMouseOverSortIndicator) {
      this.set_isMouseOverSortIndicator(isMouseOverSortIndicator);
    },
    $getNodeInfoList: function SceneMarginHitTester$GetNodeInfoList(marginRow) {
      var nodeInfoList = this.$nodeListsCache[marginRow];
      if (ss.isValue(nodeInfoList)) {
        return nodeInfoList;
      }
      nodeInfoList = this.$nodeInfoConverter.convert(marginRow);
      this.$nodeListsCache[marginRow] = nodeInfoList;
      return nodeInfoList;
    },
    $getIdForNodeHash: function SceneMarginHitTester$GetIdForNodeHash(nodeHash) {
      return $tab_NodeUtils.getIdForNodeHash(nodeHash, this.$isHorizontal);
    }
  }, {
    $hitTest: function SceneMarginHitTester$HitTest(coords, nodeInfoList) {
      var hitNode = _.find(nodeInfoList, function(nodeInfo) {
        var x = nodeInfo.extentsX || 0;
        var y = nodeInfo.extentsY || 0;
        var extents = { x: x, y: y, w: nodeInfo.extentsWidth, h: nodeInfo.extentsHeight };
        return tab.RectXYUtil.inRect(extents, coords);
      });
      return hitNode;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginNodesContainer
  var $tab_SceneMarginNodesContainer = global.tab.SceneMarginNodesContainer = ss.mkType($asm, 'tab.SceneMarginNodesContainer', function(nodesTable) {
    this.$nodesTable = null;
    this.$1$ParentChildLevelMapField = null;
    this.$1$ChildToParentIndicesMapField = null;
    this.$1$NodeMapField = null;
    this.$nodesTable = nodesTable;
    this.set_childToParentIndicesMap({});
    this.$initNodeMap();
  }, {
    get_parentChildLevelMap: function SceneMarginNodesContainer$get_ParentChildLevelMap() {
      return this.$1$ParentChildLevelMapField;
    },
    set_parentChildLevelMap: function SceneMarginNodesContainer$set_ParentChildLevelMap(value) {
      this.$1$ParentChildLevelMapField = value;
    },
    get_childToParentIndicesMap: function SceneMarginNodesContainer$get_ChildToParentIndicesMap() {
      return this.$1$ChildToParentIndicesMapField;
    },
    set_childToParentIndicesMap: function SceneMarginNodesContainer$set_ChildToParentIndicesMap(value) {
      this.$1$ChildToParentIndicesMapField = value;
    },
    get_nodeMap: function SceneMarginNodesContainer$get_NodeMap() {
      return this.$1$NodeMapField;
    },
    set_nodeMap: function SceneMarginNodesContainer$set_NodeMap(value) {
      this.$1$NodeMapField = value;
    },
    $initNodeMap: function SceneMarginNodesContainer$InitNodeMap() {
      this.set_nodeMap({});
      this.set_parentChildLevelMap({});
      for (var i = 0; i < this.$nodesTable.Level.length; ++i) {
        var level = this.$nodesTable.Level[i];
        if (level === -1) {
          continue;
        }
        var $t1 = new $tab_SelectionNode();
        $t1.index = (ss.isNullOrUndefined(this.get_nodeMap()[level]) ? 0 : this.get_nodeMap()[level].length);
        $t1.nodeHash = $tab_NodeUtils.toNodeHash(this.$nodesTable.Id[i]);
        $t1.level = level;
        var node = $t1;
        if (ss.keyExists(this.get_nodeMap(), level)) {
          this.get_nodeMap()[level].push(node);
        }
        else {
          this.get_nodeMap()[level] = ss.arrayClone([node]);
        }
        this.$prepareParentChildLevelMap(i, level);
      }
      if (ss.isValue(this.get_parentChildLevelMap()) && ss.isValue(this.$nodesTable.HierarchicalParentLevel) && ss.isValue(this.$nodesTable.HierarchicalParentNodeIndex)) {
        var $t2 = new ss.ObjectEnumerator(this.get_parentChildLevelMap());
        try {
          while ($t2.moveNext()) {
            var parentChildLevelPair = $t2.current();
            var childLevel = parentChildLevelPair.value;
            var parentIndices = [];
            for (var i1 = 0; i1 < this.$nodesTable.Level.length; i1++) {
              if (this.$nodesTable.Level[i1] === childLevel) {
                parentIndices.push(this.$nodesTable.HierarchicalParentNodeIndex[i1]);
              }
            }
            this.get_childToParentIndicesMap()[childLevel] = parentIndices;
          }
        }
        finally {
          $t2.dispose();
        }
      }
    },
    $prepareParentChildLevelMap: function SceneMarginNodesContainer$PrepareParentChildLevelMap(i, level) {
      if (ss.isValue(this.$nodesTable.HierarchicalParentLevel) && ss.isValue(this.$nodesTable.HierarchicalParentNodeIndex)) {
        var parentLevel = this.$nodesTable.HierarchicalParentLevel[i];
        if (parentLevel < 0) {
          return;
        }
        if (!ss.keyExists(this.get_parentChildLevelMap(), parentLevel)) {
          this.get_parentChildLevelMap()[parentLevel] = level;
        }
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginSelection
  var $tab_SceneMarginSelection = global.tab.SceneMarginSelection = ss.mkType($asm, 'tab.SceneMarginSelection', function(nodesContainer, sceneMarginLocation, selectionModel, brushingModel) {
    this.$sceneMarginLocation = 0;
    this.$nodesContainer = null;
    this.$1$SelectionModelField = null;
    this.$1$BrushingModelField = null;
    this.$selectedNodeMap = null;
    this.$brushedNodeMap = null;
    this.$1$PageField = 0;
    this.set_page(0);
    this.$nodesContainer = nodesContainer;
    this.$sceneMarginLocation = sceneMarginLocation;
    this.set_selectionModel(selectionModel);
    this.set_brushingModel(brushingModel);
    this.$selectedNodeMap = {};
    this.$brushedNodeMap = {};
  }, {
    get_selectionModel: function SceneMarginSelection$get_SelectionModel() {
      return this.$1$SelectionModelField;
    },
    set_selectionModel: function SceneMarginSelection$set_SelectionModel(value) {
      this.$1$SelectionModelField = value;
    },
    get_brushingModel: function SceneMarginSelection$get_BrushingModel() {
      return this.$1$BrushingModelField;
    },
    set_brushingModel: function SceneMarginSelection$set_BrushingModel(value) {
      this.$1$BrushingModelField = value;
    },
    get_page: function SceneMarginSelection$get_Page() {
      return this.$1$PageField;
    },
    set_page: function SceneMarginSelection$set_Page(value) {
      this.$1$PageField = value;
    },
    updateSelection: function SceneMarginSelection$UpdateSelection() {
      if (ss.getKeyCount(this.$selectedNodeMap) > 0) {
        ss.clearKeys(this.$selectedNodeMap);
      }
      if (ss.getKeyCount(this.$brushedNodeMap) > 0) {
        ss.clearKeys(this.$brushedNodeMap);
      }
      this.$updateParentSelectedNodeMap(this.get_selectionModel(), this.$selectedNodeMap);
      this.$updateParentSelectedNodeMap(this.get_brushingModel(), this.$brushedNodeMap);
    },
    $updateParentSelectedNodeMap: function SceneMarginSelection$UpdateParentSelectedNodeMap(selectionModel, nodeMap) {
      var $t1 = new ss.ObjectEnumerator(this.$nodesContainer.get_nodeMap());
      try {
        while ($t1.moveNext()) {
          var levelToIndicesEntry = $t1.current();
          var level = levelToIndicesEntry.key;
          var nodes = levelToIndicesEntry.value;
          for (var $t2 = 0; $t2 < nodes.length; $t2++) {
            var node = nodes[$t2];
            if (this.$isHeaderNodeInSelectionModel(selectionModel, node.nodeHash)) {
              if (!ss.keyExists(nodeMap, level)) {
                nodeMap[level] = new Set();
              }
              nodeMap[level].add(node.index);
            }
          }
        }
      }
      finally {
        $t1.dispose();
      }
      this.$propagateSelectionThroughHierarchy(nodeMap);
    },
    $propagateSelectionThroughHierarchy: function SceneMarginSelection$PropagateSelectionThroughHierarchy(nodeMap) {
      if (ss.isNullOrUndefined(this.$nodesContainer.get_parentChildLevelMap())) {
        return;
      }
      var $t1 = new ss.ObjectEnumerator(this.$nodesContainer.get_parentChildLevelMap());
      try {
        while ($t1.moveNext()) {
          var parentChildLevelPair = $t1.current();
          var parentLevel = parentChildLevelPair.key;
          var childLevel = parentChildLevelPair.value;
          if (this.$nodesContainer.get_childToParentIndicesMap()[childLevel].length === 0) {
            continue;
          }
          this.$propagateSelection(nodeMap, parentLevel, childLevel);
        }
      }
      finally {
        $t1.dispose();
      }
    },
    $propagateSelection: function SceneMarginSelection$PropagateSelection(selectedNodeMap, parentLevel, childLevel) {
      if (ss.isValue(selectedNodeMap[parentLevel]) && selectedNodeMap[parentLevel].size > 0) {
        var selectedParentNodeIndices = selectedNodeMap[parentLevel];
        var parentIndicesForEachChild = this.$nodesContainer.get_childToParentIndicesMap()[childLevel];
        for (var childIndex = 0; childIndex < parentIndicesForEachChild.length; childIndex++) {
          if (selectedParentNodeIndices.has(parentIndicesForEachChild[childIndex])) {
            if (!ss.keyExists(selectedNodeMap, childLevel)) {
              selectedNodeMap[childLevel] = new Set();
            }
            selectedNodeMap[childLevel].add(childIndex);
          }
        }
      }
    },
    isNodeSelected: function SceneMarginSelection$IsNodeSelected(level, index) {
      return ss.keyExists(this.$selectedNodeMap, level) && this.$selectedNodeMap[level].has(index);
    },
    isNodeBrushed: function SceneMarginSelection$IsNodeBrushed(level, index) {
      return ss.keyExists(this.$brushedNodeMap, level) && this.$brushedNodeMap[level].has(index);
    },
    $isHorizontal: function SceneMarginSelection$IsHorizontal() {
      return this.$sceneMarginLocation === 0 || this.$sceneMarginLocation === 1;
    },
    $isHeaderNodeInSelectionModel: function SceneMarginSelection$IsHeaderNodeInSelectionModel(model, nodeHash) {
      return model.isNodeSelected$2(nodeHash, (this.$isHorizontal() ? 'o-horiz' : 'o-vert'), this.get_page());
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SceneMarginViewModel
  var $tab_SceneMarginViewModel = global.tab.SceneMarginViewModel = ss.mkType($asm, 'tab.SceneMarginViewModel', function(sceneMarginModel, selectionModel, brushingModel) {
    this.$leafAxisViewModel = null;
    this.$fieldLabelViewModel = null;
    this.headerModels = null;
    this.$outerBorderViewModel = null;
    this.$borderDataModel = null;
    this.$sceneMarginLocation = 0;
    this.$selectionModel = null;
    this.$scrollPos = { x: 0, y: 0 };
    this.$page = 0;
    this.$viewportSize = { w: 0, h: 0 };
    this.$model = null;
    this.$sceneMarginSelection = null;
    this.$sceneMarginHitTester = null;
    this.$3$FocusStateField = 0;
    this.$3$HandleToggleSelectNodeField = null;
    this.$3$HandleDeselectNodeField = null;
    ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]).call(this);
    this.$model = sceneMarginModel;
    this.$selectionModel = selectionModel;
    this.$sceneMarginLocation = sceneMarginModel.get_sceneMarginLocation();
    var layoutTable = sceneMarginModel.get_sceneMarginLayout();
    this.$sceneMarginSelection = new $tab_SceneMarginSelection(new $tab_SceneMarginNodesContainer(sceneMarginModel.get_nodeData()), sceneMarginModel.get_sceneMarginLocation(), selectionModel, brushingModel);
    this.headerModels = [];
    this.$borderDataModel = $tab_SceneMarginBorderBuilder.build(sceneMarginModel.get_borderStyles(), this.$sceneMarginLocation);
    var totalMap = new $tab_TotalNodeMap(sceneMarginModel.get_nodeData(), sceneMarginModel.get_nodeLevelStyles().TotalType, sceneMarginModel.get_sceneMarginLayout(), sceneMarginModel.get_elidedNodeLabels(), this.$sceneMarginLocation);
    this.$outerBorderViewModel = new $tab_OuterBorderViewModel(this.$sceneMarginLocation, this.$borderDataModel, sceneMarginModel);
    this.disposables.add$1(this.addChildViewModel(this.$outerBorderViewModel));
    this.set_focusState(1);
    for (var layoutTableRow = 0; layoutTableRow < layoutTable.SceneMarginLocation.length; ++layoutTableRow) {
      if (layoutTable.SceneMarginLocation[layoutTableRow] === this.$sceneMarginLocation) {
        var elementType = layoutTable.ElementType[layoutTableRow];
        if (elementType === 0 || elementType === 1) {
          this.$leafAxisViewModel = new $tab_AxisHolderViewModel(sceneMarginModel, layoutTableRow, this.$sceneMarginSelection, this.$borderDataModel);
          this.disposables.add$1(this.addChildViewModel(this.$leafAxisViewModel));
        }
        else if (elementType === 2) {
          if (this.$isHeaderNodeVisible(sceneMarginModel, layoutTableRow)) {
            var headerHolderViewModel = new $tab_HeaderHolderViewModel(sceneMarginModel, layoutTableRow, this.$sceneMarginSelection, this.$borderDataModel, totalMap);
            this.headerModels.push(headerHolderViewModel);
            this.disposables.add$1(this.addChildViewModel(headerHolderViewModel));
          }
        }
        else if (elementType === 3) {
          this.$fieldLabelViewModel = new $tab_FieldLabelViewModel(sceneMarginModel.get_fieldLabels(), layoutTable.PixelSize[layoutTableRow], this.$sceneMarginLocation);
          this.disposables.add$1(this.addChildViewModel(this.$fieldLabelViewModel));
        }
      }
    }
    var nodeInfoConverter = new $tab_NodeInfoConverter(this.$sceneMarginLocation, sceneMarginModel.get_layoutTable(), sceneMarginModel.get_nodeData(), layoutTable, sceneMarginModel.getFoldStateOfNodes());
    this.$sceneMarginHitTester = new $tab_SceneMarginHitTester(nodeInfoConverter, this.$sceneMarginLocation, layoutTable.SceneMarginLocation);
    this.$bindSortIndicatorHoverCallbackWithHitTester();
  }, {
    get_model: function SceneMarginViewModel$get_Model() {
      return this.$model;
    },
    get_isMouseOverSortIndicator: function SceneMarginViewModel$get_IsMouseOverSortIndicator() {
      return this.$sceneMarginHitTester.get_isMouseOverSortIndicator();
    },
    set_invokeSortCommand: function SceneMarginViewModel$set_InvokeSortCommand(value) {
      this.$bindSortCommand(value);
    },
    get_page: function SceneMarginViewModel$get_Page() {
      return this.$page;
    },
    set_page: function SceneMarginViewModel$set_Page(value) {
      this.$page = value;
      if (!ss.isNullOrUndefined(this.$leafAxisViewModel)) {
        this.$leafAxisViewModel.set_page(value);
      }
      _.each(this.headerModels, function(x) {
        x.set_page(value);
      });
      this.$sceneMarginSelection.set_page(value);
    },
    get_viewportSize: function SceneMarginViewModel$get_ViewportSize() {
      return this.$viewportSize;
    },
    set_viewportSize: function SceneMarginViewModel$set_ViewportSize(value) {
      if (!tab.SizeUtil.equals(this.$viewportSize, value)) {
        this.$viewportSize = value;
        if (!ss.isNullOrUndefined(this.$leafAxisViewModel)) {
          this.$leafAxisViewModel.set_sceneMarginViewportSize(value);
        }
        if (!ss.isNullOrUndefined(this.$fieldLabelViewModel)) {
          this.$fieldLabelViewModel.set_sceneMarginViewportSize(value);
        }
        if (!ss.isNullOrUndefined(this.$outerBorderViewModel)) {
          this.$outerBorderViewModel.set_sceneMarginViewportSize(value);
        }
        _.each(this.headerModels, function(x) {
          x.set_sceneMarginViewportSize(value);
        });
      }
    },
    get_scrollPos: function SceneMarginViewModel$get_ScrollPos() {
      return this.$scrollPos;
    },
    set_scrollPos: function SceneMarginViewModel$set_ScrollPos(value) {
      if (!tab.PointUtil.equals(this.$scrollPos, value)) {
        this.$scrollPos = value;
        if (!ss.isNullOrUndefined(this.$fieldLabelViewModel)) {
          this.$fieldLabelViewModel.set_scrollPos(value);
        }
        this.incrementProps();
      }
    },
    get_focusState: function SceneMarginViewModel$get_FocusState() {
      return this.$3$FocusStateField;
    },
    set_focusState: function SceneMarginViewModel$set_FocusState(value) {
      this.$3$FocusStateField = value;
    },
    get_handleToggleSelectNode: function SceneMarginViewModel$get_HandleToggleSelectNode() {
      return this.$3$HandleToggleSelectNodeField;
    },
    set_handleToggleSelectNode: function SceneMarginViewModel$set_HandleToggleSelectNode(value) {
      this.$3$HandleToggleSelectNodeField = value;
    },
    get_handleDeselectNode: function SceneMarginViewModel$get_HandleDeselectNode() {
      return this.$3$HandleDeselectNodeField;
    },
    set_handleDeselectNode: function SceneMarginViewModel$set_HandleDeselectNode(value) {
      this.$3$HandleDeselectNodeField = value;
    },
    hitTestNodes: function SceneMarginViewModel$HitTestNodes(coords) {
      return this.$sceneMarginHitTester.hitTestNodes(coords);
    },
    getNodeWithId: function SceneMarginViewModel$GetNodeWithId(id) {
      return this.$sceneMarginHitTester.getNodeWithId(id);
    },
    createInitialProps: function SceneMarginViewModel$CreateInitialProps() {
      this.$sceneMarginSelection.updateSelection();
      return { sceneMarginLocation: this.$sceneMarginLocation, handleArrowKeyEvent: ss.mkdel(this, this.$handleArrowKeyEvent), handleEnterOrSpaceKeyEvent: ss.mkdel(this, this.$handleEnterOrSpaceKeyEvent), handleEscKeyEvent: ss.mkdel(this, this.$handleEscKeyEvent), handleFocusLostEvent: ss.mkdel(this, this.$handleFocusLostEvent), outerBorderProps: (ss.isNullOrUndefined(this.$outerBorderViewModel) ? undefined : this.$outerBorderViewModel.get_props()), viewportSize: this.$viewportSize, borderDataModel: this.$borderDataModel };
    },
    createUpdatedProps: function SceneMarginViewModel$CreateUpdatedProps() {
      this.$sceneMarginSelection.updateSelection();
      var headerLevelCount = this.headerModels.length;
      var headerProps = new Array(headerLevelCount);
      for (var i = 0; i < headerLevelCount; ++i) {
        headerProps[i] = this.headerModels[i].get_props();
      }
      var isHorizontal = tab.SceneMarginModel.isHorizontal(this.$sceneMarginLocation);
      return { headerStackProps: headerProps, fieldLabelProps: (ss.isNullOrUndefined(this.$fieldLabelViewModel) ? undefined : this.$fieldLabelViewModel.get_props()), axisProps: (ss.isNullOrUndefined(this.$leafAxisViewModel) ? undefined : this.$leafAxisViewModel.get_props()), outerBorderProps: (ss.isNullOrUndefined(this.$outerBorderViewModel) ? undefined : this.$outerBorderViewModel.get_props()), focusState: this.get_focusState(), scrollOffset: (isHorizontal ? this.$scrollPos.x : this.$scrollPos.y), viewportSize: this.$viewportSize };
    },
    $bindSortIndicatorHoverCallbackWithHitTester: function SceneMarginViewModel$BindSortIndicatorHoverCallbackWithHitTester() {
      if (ss.isValue(this.$leafAxisViewModel)) {
        this.$leafAxisViewModel.set_sortIndicatorHoverCallback(ss.mkdel(this.$sceneMarginHitTester, this.$sceneMarginHitTester.updateIsMouseOverSortIndicator));
      }
      for (var $t1 = 0; $t1 < this.headerModels.length; $t1++) {
        var headerHolderViewModel = this.headerModels[$t1];
        headerHolderViewModel.set_sortIndicatorHoverCallback(ss.mkdel(this.$sceneMarginHitTester, this.$sceneMarginHitTester.updateIsMouseOverSortIndicator));
      }
    },
    $bindSortCommand: function SceneMarginViewModel$BindSortCommand(invokeSortCommand) {
      if (ss.isValue(this.$leafAxisViewModel)) {
        this.$leafAxisViewModel.set_invokeSortCommand(invokeSortCommand);
      }
      for (var $t1 = 0; $t1 < this.headerModels.length; $t1++) {
        var headerHolderViewModel = this.headerModels[$t1];
        headerHolderViewModel.set_invokeSortCommand(invokeSortCommand);
      }
    },
    $handleArrowKeyEvent: function SceneMarginViewModel$HandleArrowKeyEvent(id, keyValue) {
      if (this.get_focusState() === 0) {
        $tab_ArrowKeyNavigationUtil.handleArrowKeyEvent(id, keyValue, this.headerModels, this.$sceneMarginLocation);
      }
    },
    $handleEnterOrSpaceKeyEvent: function SceneMarginViewModel$HandleEnterOrSpaceKeyEvent(nodeId) {
      if (this.get_focusState() === 1) {
        if (this.headerModels.length > 0) {
          this.set_focusState(0);
          this.incrementProps();
          this.headerModels.forEach(function(headerModel) {
            headerModel.updateHeaderNodesFocusState(true);
          });
          this.headerModels[0].findAndFocusIfPossible(0);
        }
      }
      else if (this.get_focusState() === 0) {
        this.get_handleToggleSelectNode()(nodeId);
      }
    },
    $handleEscKeyEvent: function SceneMarginViewModel$HandleEscKeyEvent() {
      if (this.$selectionModel.isEmpty) {
        this.set_focusState(1);
        this.headerModels.forEach(function(headerModel) {
          headerModel.updateHeaderNodesFocusState(false);
        });
        this.incrementProps();
        document.getElementsByClassName($tab_SceneMarginComponent.getMarginClassName(this.$sceneMarginLocation))[0].focus();
      }
      this.get_handleDeselectNode()();
    },
    $handleFocusLostEvent: function SceneMarginViewModel$HandleFocusLostEvent() {
      this.set_focusState(1);
      this.headerModels.forEach(function(headerModel) {
        headerModel.updateHeaderNodesFocusState(false);
      });
      this.incrementProps();
    },
    $getTotalAlongMarginSize: function SceneMarginViewModel$GetTotalAlongMarginSize() {
      return this.$model.get_layoutTable().AlongDirectionPixelSize[0];
    },
    $isHeaderNodeVisible: function SceneMarginViewModel$IsHeaderNodeVisible(sceneMarginModel, layoutTableRow) {
      return sceneMarginModel.get_sceneMarginLayout().PixelSize[layoutTableRow] > 0;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.SelectionNode
  var $tab_SelectionNode = global.tab.SelectionNode = ss.mkType($asm, 'tab.SelectionNode', function() {
    this.nodeHash = 0;
    this.index = 0;
    this.level = 0;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TextOrientation
  var $tab_TextOrientation = global.tab.TextOrientation = ss.mkEnum($asm, 'tab.TextOrientation', { horizontalText: 0, downwardText: 90, upwardText: -90 });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TextStyleHelper
  var $tab_TextStyleHelper = global.tab.TextStyleHelper = ss.mkType($asm, 'tab.TextStyleHelper', null, null, {
    getCssFromTextStyle: function TextStyleHelper$GetCssFromTextStyle(style) {
      return { fontFamily: style.font, fontSize: style.font_size + 'pt', fontStyle: ((tab.EnumConversions.tableauFontStyleFromInt(style.font_style) === 'font-style-italic') ? tab.CssFontStyle.italic : tab.CssFontStyle.normal), fontWeight: ((tab.EnumConversions.fontWeightFromInt(style.font_weight) === 'font-weight-bold') ? tab.CssFontWeight.bold : tab.CssFontWeight.normal) };
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TickLabelComponent
  var $tab_TickLabelComponent = global.tab.TickLabelComponent = ss.mkType($asm, 'tab.TickLabelComponent', function(props) {
    this.$isAxisHorizontal = false;
    spiff.PureRenderComponent.call(this, props);
    this.$isAxisHorizontal = tab.SceneMarginModel.isHorizontal(this.props.sceneMarginLocation);
  }, {
    render: function TickLabelComponent$Render() {
      var labelContentStyle = this.$getLabelContentStyle();
      var tickLabelElements = _.map(_.range(0, this.props.tickLabelPositions.length), ss.mkdel(this, function(index) {
        var labelContent = spiff.DOMElements.div({ className: $tab_TickLabelComponent.tickLabelContentClass, style: labelContentStyle }, this.props.visibleTickLabels[index]);
        return spiff.DOMElements.div({ className: $tab_TickLabelComponent.tickLabelAlignerClass, key: 'tick-label-' + index, style: this.$getAlignerStyle(index) }, labelContent);
      }));
      return spiff.DOMElements.div({ className: 'tab-vizAxisTickLabel', style: this.$getFontStyle() }, tickLabelElements);
    },
    $getLabelContentStyle: function TickLabelComponent$GetLabelContentStyle() {
      var labelContentStyle = { textDecorationLine: (this.props.tickLabelStyle.underline ? 'underline' : 'none') };
      if (this.props.tickLabelStyle.text_orientation === 0) {
        labelContentStyle.overflowX = 'hidden';
        labelContentStyle.overflowY = 'visible';
      }
      else {
        labelContentStyle.overflowX = 'visible';
        labelContentStyle.overflowY = 'hidden';
      }
      return labelContentStyle;
    },
    $getAlignerStyle: function TickLabelComponent$GetAlignerStyle(index) {
      var labelPos = this.$computeAlongAxisLabelPosition(index);
      var style = this.$computeAlignerStyleBasedOnAxisOrientation(labelPos);
      if (this.props.tickLabelStyle.text_orientation === -90) {
        style.transform = 'rotate(180deg)';
      }
      return this.$appendPerpendicularLabelPositionToStyle(style);
    },
    $computeAlongAxisLabelPosition: function TickLabelComponent$ComputeAlongAxisLabelPosition(labelIndex) {
      var alongAxisLabelSize = this.$getAlongAxisLabelSize(labelIndex);
      var labelBeginningPos = this.props.tickLabelPositions[labelIndex] - ss.idiv(alongAxisLabelSize, 2);
      if (labelBeginningPos < 0) {
        return 0;
      }
      else if (labelBeginningPos + alongAxisLabelSize > this.props.alongAxisPixelSize) {
        return this.props.alongAxisPixelSize - alongAxisLabelSize;
      }
      return labelBeginningPos;
    },
    $getAlongAxisLabelSize: function TickLabelComponent$GetAlongAxisLabelSize(labelIndex) {
      var isLabelHorizontal = this.props.tickLabelStyle.text_orientation === 0;
      var isLabelPerpendicularToAxis = !!(this.$isAxisHorizontal ^ isLabelHorizontal);
      if (isLabelPerpendicularToAxis) {
        return this.props.measuredLabelHeight;
      }
      return this.props.measuredLabelWidths[labelIndex];
    },
    $appendPerpendicularLabelPositionToStyle: function TickLabelComponent$AppendPerpendicularLabelPositionToStyle(style) {
      var perpendicularPosition = ss.formatString('{0}px', this.props.majorTickSize + $tab_TickLabelComponent.$padding);
      if (this.props.sceneMarginLocation === 0) {
        style.bottom = perpendicularPosition;
      }
      else if (this.props.sceneMarginLocation === 1) {
        style.top = perpendicularPosition;
      }
      else if (this.props.sceneMarginLocation === 3) {
        style.right = perpendicularPosition;
      }
      else if (this.props.sceneMarginLocation === 2) {
        style.left = perpendicularPosition;
      }
      return style;
    },
    $getFontStyle: function TickLabelComponent$GetFontStyle() {
      var fontStyle = $tab_TextStyleHelper.getCssFromTextStyle(this.props.tickLabelStyle);
      fontStyle.color = tab.ColorModel.fromArgbInt(this.props.tickLabelStyle.text_style_color).toRgbHex();
      if (this.props.tickLabelStyle.text_orientation !== 0) {
        fontStyle.writingMode = (BrowserSupport.BrowserSupport.IsIE() ? 'tb-lr' : 'vertical-lr');
      }
      return fontStyle;
    },
    $computeAlignerStyleBasedOnAxisOrientation: function TickLabelComponent$ComputeAlignerStyleBasedOnAxisOrientation(labelPos) {
      var alongAxisLimit = this.props.alongAxisPixelSize + 'px';
      var perpendicularLimit = ss.formatString('{0}px', this.props.pixelSize - this.props.majorTickSize - $tab_TickLabelComponent.$padding);
      if (this.$isAxisHorizontal) {
        return { left: labelPos + 'px', maxWidth: alongAxisLimit, maxHeight: perpendicularLimit };
      }
      else {
        return { top: labelPos + 'px', maxHeight: alongAxisLimit, maxWidth: perpendicularLimit };
      }
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TickLabelProps
  var $tab_TickLabelProps = global.tab.TickLabelProps = ss.mkType($asm, 'tab.TickLabelProps', function() {
    this.alongAxisPixelSize = 0;
    this.pixelSize = 0;
    this.majorTickSize = 0;
    this.sceneMarginLocation = 0;
    this.tickLabelPositions = null;
    this.visibleTickLabels = null;
    this.tickLabelStyle = null;
    this.measuredLabelWidths = null;
    this.measuredLabelHeight = 0;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TickMarkComponent
  var $tab_TickMarkComponent = global.tab.TickMarkComponent = ss.mkType($asm, 'tab.TickMarkComponent', function(props) {
    spiff.PureRenderComponent.call(this, props);
  }, {
    render: function TickMarkComponent$Render() {
      var majorTicks = (ss.isNullOrUndefined(this.props.majorTicks) ? null : _.map(_.range(0, this.props.majorTicks.length), ss.mkdel(this, function(index) {
        return spiff.DOMElements.line(this.$getLineProps(index, false));
      })));
      var minorTicks = (ss.isNullOrUndefined(this.props.minorTicks) ? null : _.map(_.range(0, this.props.minorTicks.length), ss.mkdel(this, function(index1) {
        return spiff.DOMElements.line(this.$getLineProps(index1, true));
      })));
      var isVertical = this.props.sceneMarginLocation === 3 || this.props.sceneMarginLocation === 2;
      return spiff.DOMElements.svg({ className: 'tab-vizAxisTick', width: (isVertical ? this.props.majorTickSize : this.props.alongAxisPixelSize), height: (isVertical ? this.props.alongAxisPixelSize : this.props.majorTickSize), style: this.$getPosition() }, majorTicks, minorTicks);
    },
    $getLineProps: function TickMarkComponent$GetLineProps(index, isMinorTick) {
      var lineProps = { key: 'tick-' + index, stroke: this.props.tickMarkColor.toRgbHex(), strokeWidth: '1px', opacity: this.props.tickMarkColor.get_a().toString() };
      var location = (isMinorTick ? this.props.minorTicks[index] : this.props.majorTicks[index]);
      location += 0.5;
      var tickSize = (isMinorTick ? this.props.minorTickSize : this.props.majorTickSize);
      switch (this.props.sceneMarginLocation) {
        case 3:
        case 2: {
          lineProps.transform = ss.formatString('translate(0, {0})', location);
          lineProps.x2 = tickSize;
          lineProps.y2 = 0;
          break;
        }
        case 1:
        case 0: {
          lineProps.transform = ss.formatString('translate({0}, 0)', location);
          lineProps.x2 = 0;
          lineProps.y2 = tickSize;
          break;
        }
      }
      return lineProps;
    },
    $getPosition: function TickMarkComponent$GetPosition() {
      var style = { position: 'absolute' };
      switch (this.props.sceneMarginLocation) {
        case 3: {
          style.top = '0px';
          style.left = this.props.pixelSize - this.props.majorTickSize + 'px';
          break;
        }
        case 1: {
          style.top = '0px';
          style.left = '0px';
          break;
        }
        case 0: {
          style.top = this.props.pixelSize - this.props.majorTickSize + 'px';
          style.left = '0px';
          break;
        }
        case 2: {
          style.top = '0px';
          style.left = '1px';
          break;
        }
      }
      return style;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TickPlacement
  var $tab_TickPlacement = global.tab.TickPlacement = ss.mkType($asm, 'tab.TickPlacement', null, null, {
    $getFormatSpecifier: function TickPlacement$GetFormatSpecifier(formatIndicies, formats, index) {
      var formatSpecifier = null;
      if (ss.isValue(formatIndicies)) {
        var formatIndex = formatIndicies[index];
        if (formatIndex >= 0) {
          var formatter = formats[formatIndex];
          formatSpecifier = formatter[32];
        }
      }
      return formatSpecifier;
    },
    getTickLabels: function TickPlacement$GetTickLabels(tickPlacement, sizeOfDimension, index, tickLabelVisibleRange) {
      return $tab_TickPlacement.getTickLabelsAndIsFirstTickOutsideViewPort(tickPlacement, sizeOfDimension, index, tickLabelVisibleRange, new $tab_LabelSkipResult(1, true, true)).tickLabels;
    },
    getTickLabelsAndIsFirstTickOutsideViewPort: function TickPlacement$GetTickLabelsAndIsFirstTickOutsideViewPort(tickPlacement, sizeOfDimension, index, tickLabelVisibleRange, labelSkipResult) {
      var perHeaderMajorTickPlacement = tickPlacement.PerHeaderMajorTickPlacement;
      var formatSpecifier = $tab_TickPlacement.$getFormatSpecifier(tickPlacement.PerHeaderMajorTickPlacement.UpdatedColumnFormatIndex, tickPlacement.UpdatedColumnFormat, index);
      if (ss.isNullOrUndefined(formatSpecifier)) {
        formatSpecifier = $tab_TickPlacement.$getFormatSpecifier(tickPlacement.PerHeaderMajorTickPlacement.ColumnFormatIndex, tickPlacement.ColumnFormat, index);
      }
      var results = new $tab_VisibleTickLabelsResult([], false);
      if (ss.isNullOrUndefined(formatSpecifier)) {
        return results;
      }
      var formatterIndex = tab.RuntimeFormattingHooks.registerRealFormattingTuple(formatSpecifier);
      var tickPlacementType = $tab_TickPlacement.$getTickPlacementType(tickPlacement, index, false);
      switch (tickPlacementType) {
        case 2: {
          results.tickLabels = $tab_TickPlacement.$getDateTimeTickLabels(perHeaderMajorTickPlacement, sizeOfDimension, index, labelSkipResult, formatSpecifier);
          break;
        }
        case 1: {
          var spacing = perHeaderMajorTickPlacement.Spacing[index];
          var origin = perHeaderMajorTickPlacement.Origin[index];
          results.tickLabels = $tab_TickPlacement.$decodeLinearTicks($tab_TickPlacement.$linearTicks(spacing, origin, labelSkipResult), formatterIndex, tickLabelVisibleRange);
          break;
        }
        case 3: {
          var allTickLabelValues = $tab_TickPlacement.$getTickLabelValues(tickPlacement, index);
          results.isFirstTickOutsideViewPort = allTickLabelValues.length === 0 || allTickLabelValues[0] < tickLabelVisibleRange.min;
          results.tickLabels = $tab_TickPlacement.$formatLogTicks(allTickLabelValues, formatterIndex, tickLabelVisibleRange, labelSkipResult);
          break;
        }
        default: {
          break;
        }
      }
      return results;
    },
    $getDateTimeTickLabels: function TickPlacement$GetDateTimeTickLabels(perHeaderMajorTickPlacement, sizeOfDimension, index, labelSkipResult, formatSpecifier) {
      var formatString = null;
      var autoFormatString = perHeaderMajorTickPlacement.DateTimeFormatString[index];
      if (!tab.MiscUtil.isNullOrEmpty$1(autoFormatString)) {
        formatString = ss.replaceAllString(autoFormatString, "'", '"');
      }
      else {
        var serverFormatString = JSON.parse(formatSpecifier);
        formatString = ((serverFormatString.length > 0) ? serverFormatString[0] : null);
      }
      var formatterIndex = tab.RuntimeFormattingHooks.registerDateTimeFormattingTuple(formatString);
      return $tab_TickPlacement.$decodeDateTimeTicks($tab_TickPlacement.$dateTimeLabels(perHeaderMajorTickPlacement, sizeOfDimension, index, labelSkipResult), formatterIndex);
    },
    getTickLabelPositions: function TickPlacement$GetTickLabelPositions(allTickLabelPositions, labelSkipResult, isFirstTickOutsideView) {
      var labelPositions = [];
      var indexOfFirstTickToLabel = $tab_TickPlacement.$getIndexOfFirstTickToLabel(labelSkipResult, isFirstTickOutsideView);
      for (var index = indexOfFirstTickToLabel; index < allTickLabelPositions.length; index += labelSkipResult.get_skip()) {
        if (labelSkipResult.get_includeLastLabel() || index + labelSkipResult.get_skip() < allTickLabelPositions.length) {
          labelPositions.push(allTickLabelPositions[index]);
        }
      }
      return labelPositions;
    },
    $getIndexOfFirstTickToLabel: function TickPlacement$GetIndexOfFirstTickToLabel(labelSkipResult, isFirstTickOutsideView) {
      if (isFirstTickOutsideView) {
        return Math.max(0, labelSkipResult.get_skip() - 1);
      }
      return (labelSkipResult.get_includeFirstLabel() ? 0 : labelSkipResult.get_skip());
    },
    getTickLabelStyle: function TickPlacement$GetTickLabelStyle(tickPlacement, index) {
      var perHeaderMajorTickPlacement = tickPlacement.PerHeaderMajorTickPlacement;
      var labelStyleIndex = perHeaderMajorTickPlacement.LabelStyleIndex[index];
      var labelStyleTuple = tickPlacement.LabelStyle[labelStyleIndex];
      var result = tab.TupleDatastoreConversions.textStyleFromTuple(labelStyleTuple);
      return result;
    },
    getTickPlacement$1: function TickPlacement$GetTickPlacement(tickPlacement, locOrigin, sizeOfDimension, index, config, useExactTickPositions) {
      var perHeaderTickPlacement = $tab_TickPlacement.$getOutputTableForTickStyle(tickPlacement, config.getMinorTicks);
      if (ss.isNullOrUndefined(perHeaderTickPlacement)) {
        return null;
      }
      var tickPlacementType = $tab_TickPlacement.$getTickPlacementType(tickPlacement, index, config.getMinorTicks);
      var includeViewEdges = $tab_TickPlacement.$includeViewEdges(perHeaderTickPlacement, index);
      var ticks = [];
      switch (tickPlacementType) {
        case 3: {
          var encodingIndex = $tab_TickPlacement.$getEncodedTickPositionIndex(perHeaderTickPlacement, index);
          var encodedTickPositions = $tab_TickPlacement.$getEncodedTickPositions(tickPlacement, encodingIndex, config.getMinorTicks);
          ticks = $tab_TickPlacement.$manualTicks(locOrigin, sizeOfDimension, encodedTickPositions, config.reversed, includeViewEdges, config.xAxis);
          break;
        }
        case 2: {
          ticks = $tab_TickPlacement.$dateTimeTicks(locOrigin, sizeOfDimension, perHeaderTickPlacement, index, config.reversed, config.xAxis, includeViewEdges);
          break;
        }
        case 1: {
          var spacing = $tab_TickPlacement.$domainToPixel(sizeOfDimension, perHeaderTickPlacement.Spacing[index], false);
          if (!useExactTickPositions) {
            spacing = $tab_TickPlacement.updateLinearTickSpacing(spacing);
          }
          var origin = $tab_TickPlacement.$domainToPixel(sizeOfDimension, perHeaderTickPlacement.Origin[index], config.reversed);
          ticks = $tab_TickPlacement.$linearTicks$1(locOrigin, sizeOfDimension, spacing, origin, includeViewEdges, config.reversed, config.xAxis);
          break;
        }
        default: {
          break;
        }
      }
      return ticks;
    },
    getTickPlacement: function TickPlacement$GetTickPlacement(tickPlacement, paneRect, index, config, useExactTickPositions) {
      if (ss.isNullOrUndefined(config)) {
        config = new $tab_TickPlacementConfig(false, true, false);
      }
      var locOrigin = (config.xAxis ? paneRect.x : paneRect.y);
      var sizeOfDimension = (config.xAxis ? paneRect.w : paneRect.h);
      return $tab_TickPlacement.getTickPlacement$1(tickPlacement, locOrigin, sizeOfDimension, index, config, useExactTickPositions);
    },
    getTicksForMultiPanes: function TickPlacement$GetTicksForMultiPanes(tickPlacements, index) {
      if (ss.isValue(tickPlacements) && index !== 0 && tickPlacements[0] === 0) {
        var updatedTickPlacements = ss.arrayClone(tickPlacements);
        ss.removeAt(updatedTickPlacements, 0);
        return updatedTickPlacements;
      }
      return tickPlacements;
    },
    $getOutputTableForTickStyle: function TickPlacement$GetOutputTableForTickStyle(tickPlacement, getMinorTicks) {
      return (getMinorTicks ? tickPlacement.PerHeaderMinorTickPlacement : tickPlacement.PerHeaderMajorTickPlacement);
    },
    $hasEncodedTickPositions: function TickPlacement$HasEncodedTickPositions(tickPlacement, getMinorTicks) {
      var encodedTickPositions = (getMinorTicks ? tickPlacement.EncodedMinorTickPositions : tickPlacement.EncodedTickPositions);
      return !ss.isNullOrUndefined(encodedTickPositions) && !ss.isNullOrUndefined($tab_TickPlacement.$getOutputTableForTickStyle(tickPlacement, getMinorTicks).EncodedTickPositionsIndex);
    },
    $hasDateTime: function TickPlacement$HasDateTime(perHeaderTickPlacement) {
      return !ss.isNullOrUndefined(perHeaderTickPlacement.DateTimeOrigin) && !ss.isNullOrUndefined(perHeaderTickPlacement.DateTimeSpacing) && !ss.isNullOrUndefined(perHeaderTickPlacement.DateTimeSpacingUnit) && !ss.isNullOrUndefined(perHeaderTickPlacement.EncodingMin) && !ss.isNullOrUndefined(perHeaderTickPlacement.EncodingMax);
    },
    $hasSpacingOrigin: function TickPlacement$HasSpacingOrigin(perHeaderTickPlacement) {
      return !ss.isNullOrUndefined(perHeaderTickPlacement.Spacing) && !ss.isNullOrUndefined(perHeaderTickPlacement.Origin);
    },
    $isViewEdge: function TickPlacement$IsViewEdge(locOrigin, sizeOfDimension, pt, includeViewEdges) {
      return !includeViewEdges && (Math.floor(pt) === locOrigin || ss.round(pt) >= locOrigin + sizeOfDimension);
    },
    $includeViewEdges: function TickPlacement$IncludeViewEdges(perHeaderTickPlacement, index) {
      return (!ss.isNullOrUndefined(perHeaderTickPlacement.IncludeViewEdges) ? perHeaderTickPlacement.IncludeViewEdges[index] : true);
    },
    $getEncodedTickPositionIndex: function TickPlacement$GetEncodedTickPositionIndex(perHeaderTickPlacement, index) {
      return perHeaderTickPlacement.EncodedTickPositionsIndex[index];
    },
    $getEncodedTickPositions: function TickPlacement$GetEncodedTickPositions(tickPlacement, index, getMinorTicks) {
      return (getMinorTicks ? ss.cast(tickPlacement.EncodedMinorTickPositions, Array)[index] : ss.cast(tickPlacement.EncodedTickPositions, Array)[index]);
    },
    $domainToCoord: function TickPlacement$DomainToCoord(pt, reversed) {
      return (reversed ? (1 - pt) : pt);
    },
    $domainToPixel: function TickPlacement$DomainToPixel(sizeOfDimension, pt, reversed) {
      return $tab_TickPlacement.$domainToCoord(pt, reversed) * sizeOfDimension;
    },
    $calculatePointX: function TickPlacement$CalculatePointX(x, width, pt, reversed) {
      return Math.floor(x + $tab_TickPlacement.$domainToPixel(width, pt, reversed));
    },
    $calculatePointY: function TickPlacement$CalculatePointY(y, height, pt, reversed) {
      return Math.floor(y + height - $tab_TickPlacement.$domainToPixel(height, pt, reversed));
    },
    formatDateTime: function TickPlacement$FormatDateTime(dateTime) {
      if (!(dateTime.indexOf('T') !== -1)) {
        dateTime += 'T00:00:00';
      }
      return new Date(dateTime + 'Z');
    },
    $dateTimeToDomain: function TickPlacement$DateTimeToDomain(dateTime, dateTimeMin, dateTimeMax) {
      var range = tab.DateUtil.dateTimeAsOleDate(dateTimeMax) - tab.DateUtil.dateTimeAsOleDate(dateTimeMin);
      return (tab.DateUtil.dateTimeAsOleDate(dateTime) - tab.DateUtil.dateTimeAsOleDate(dateTimeMin)) / range;
    },
    $getTickPlacementType: function TickPlacement$GetTickPlacementType(tickPlacement, index, getMinorTicks) {
      var perHeaderTickPlacement = $tab_TickPlacement.$getOutputTableForTickStyle(tickPlacement, getMinorTicks);
      if ($tab_TickPlacement.$hasEncodedTickPositions(tickPlacement, getMinorTicks)) {
        var encodingIndex = $tab_TickPlacement.$getEncodedTickPositionIndex(perHeaderTickPlacement, index);
        if (encodingIndex >= 0 && encodingIndex <= 2147483647) {
          return 3;
        }
      }
      if ($tab_TickPlacement.$hasDateTime(perHeaderTickPlacement)) {
        var dateTimeIncrement = perHeaderTickPlacement.DateTimeSpacing[index];
        if (dateTimeIncrement > 0) {
          return 2;
        }
      }
      if ($tab_TickPlacement.$hasSpacingOrigin(perHeaderTickPlacement)) {
        var spacing = perHeaderTickPlacement.Spacing[index];
        if (spacing > 1.40129846432482E-45) {
          return 1;
        }
      }
      return 0;
    },
    updateLinearTickSpacing: function TickPlacement$UpdateLinearTickSpacing(spacing) {
      return ((spacing < 2) ? 2 : spacing);
    },
    $linearTicks$1: function TickPlacement$LinearTicks(axisOrigin, length, spacing, origin, includeViewEdges, reversed, xAxis) {
      if (reversed && xAxis || !reversed && !xAxis) {
        return $tab_TickPlacement.$getTicksDecreasingPixels(axisOrigin, length, spacing, origin, includeViewEdges, xAxis);
      }
      else {
        return $tab_TickPlacement.$getTicksIncreasingPixels(axisOrigin, length, spacing, origin, includeViewEdges, xAxis);
      }
    },
    $linearTicks: function TickPlacement$LinearTicks(spacing, origin, labelSkipResult) {
      var delta = origin % spacing;
      var x = (labelSkipResult.get_includeFirstLabel() ? delta : (delta + labelSkipResult.get_skip() * spacing));
      var ticks = [];
      do {
        var nextTick = x + labelSkipResult.get_skip() * spacing;
        if (nextTick <= 1 || labelSkipResult.get_includeLastLabel()) {
          ticks.push(x);
        }
        x = nextTick;
      } while (x <= 1);
      return ticks;
    },
    $getTicksIncreasingPixels: function TickPlacement$GetTicksIncreasingPixels(axisOrigin, length, spacing, origin, includeViewEdges, xAxis) {
      var delta = (xAxis ? origin : (axisOrigin + length - origin)) % spacing;
      var position = axisOrigin + delta;
      var endPoint = axisOrigin + length;
      var ticks = [];
      do {
        if (!$tab_TickPlacement.$isViewEdge(axisOrigin, length, position, includeViewEdges)) {
          ticks.push(ss.round(position));
        }
        position += spacing;
      } while (ss.round(position) <= endPoint);
      return ticks;
    },
    $getTicksDecreasingPixels: function TickPlacement$GetTicksDecreasingPixels(axisOrigin, length, spacing, origin, includeViewEdges, xAxis) {
      var delta = (xAxis ? (axisOrigin + length - origin) : origin) % spacing;
      var position = axisOrigin + length - delta;
      var ticks = [];
      do {
        if (!$tab_TickPlacement.$isViewEdge(axisOrigin, length, position, includeViewEdges)) {
          ticks.push(ss.round(position));
        }
        position -= spacing;
      } while (ss.round(position) >= axisOrigin);
      return ticks;
    },
    $manualTicks: function TickPlacement$ManualTicks(locOrigin, sizeOfDimension, encodedTickPositions, reversed, includeViewEdges, xAxis) {
      var ticks = [];
      for (var $t1 = 0; $t1 < encodedTickPositions.length; $t1++) {
        var tickPosition = encodedTickPositions[$t1];
        var locCalculated = (xAxis ? $tab_TickPlacement.$calculatePointX(locOrigin, sizeOfDimension, tickPosition, reversed) : $tab_TickPlacement.$calculatePointY(locOrigin, sizeOfDimension, tickPosition, reversed));
        if (locOrigin <= locCalculated && locOrigin + sizeOfDimension >= locCalculated && !$tab_TickPlacement.$isViewEdge(locOrigin, sizeOfDimension, locCalculated, includeViewEdges)) {
          ticks.push(locCalculated);
        }
      }
      return ticks;
    },
    $getDateTimeIntervalForUnit: function TickPlacement$GetDateTimeIntervalForUnit(periodType, numPeriods) {
      var baseDate = new Date();
      var outDate = tab.DateUtil.adjustDateByPeriodInUTC(baseDate, periodType, numPeriods);
      return tab.DateUtil.dateTimeAsOleDate(outDate) - tab.DateUtil.dateTimeAsOleDate(baseDate);
    },
    $firstDateTimeInRange: function TickPlacement$FirstDateTimeInRange(dateTimeOrigin, dateTimeMin, dateTimeUnit, dateTimeIncrement) {
      var dateTimeInterval = $tab_TickPlacement.$getDateTimeIntervalForUnit(dateTimeUnit, dateTimeIncrement);
      var dateTimeIncrementInUnit = Math.floor((tab.DateUtil.dateTimeAsOleDate(dateTimeOrigin) - tab.DateUtil.dateTimeAsOleDate(dateTimeMin)) / dateTimeInterval);
      return tab.DateUtil.adjustDateByPeriodInUTC(dateTimeOrigin, dateTimeUnit, -1 * dateTimeIncrementInUnit * dateTimeIncrement);
    },
    $getRecommendedDateTimeIncrement: function TickPlacement$GetRecommendedDateTimeIncrement(dateTimeMin, dateTimeMax, dateTimeUnit, dateTimeIncrement, sizeOfDimension) {
      var dateTimeInterval = $tab_TickPlacement.$getDateTimeIntervalForUnit(dateTimeUnit, dateTimeIncrement);
      var numOfTicks = Math.floor((tab.DateUtil.dateTimeAsOleDate(dateTimeMax) - tab.DateUtil.dateTimeAsOleDate(dateTimeMin)) / dateTimeInterval);
      if (numOfTicks < ss.idiv(sizeOfDimension, 2)) {
        return dateTimeIncrement;
      }
      return ss.idiv(dateTimeIncrement * (2 * numOfTicks), sizeOfDimension);
    },
    $dateTimeTicks: function TickPlacement$DateTimeTicks(locOrigin, sizeOfDimension, perHeaderMajorTickPlacement, index, reversed, xAxis, includeViewEdges) {
      var dateTimeOrigin = $tab_TickPlacement.formatDateTime(perHeaderMajorTickPlacement.DateTimeOrigin[index]);
      var dateTimeMin = $tab_TickPlacement.formatDateTime(perHeaderMajorTickPlacement.EncodingMin[index]);
      var dateTimeMax = $tab_TickPlacement.formatDateTime(perHeaderMajorTickPlacement.EncodingMax[index]);
      var dateTimeUnit = tab.EnumConversions.datePeriodTypeFromInt(perHeaderMajorTickPlacement.DateTimeSpacingUnit[index]);
      var dateTimeIncrement = perHeaderMajorTickPlacement.DateTimeSpacing[index];
      var recommendedDateTimeIncrement = $tab_TickPlacement.$getRecommendedDateTimeIncrement(dateTimeMin, dateTimeMax, dateTimeUnit, dateTimeIncrement, sizeOfDimension);
      var ticks = [];
      if (ss.staticEquals(dateTimeMin, dateTimeMax)) {
        var tick = (xAxis ? $tab_TickPlacement.$calculatePointX(locOrigin, sizeOfDimension, 0.5, reversed) : $tab_TickPlacement.$calculatePointY(locOrigin, sizeOfDimension, 0.5, reversed));
        if (!$tab_TickPlacement.$isViewEdge(locOrigin, sizeOfDimension, tick, includeViewEdges)) {
          ticks.push(tick);
        }
        return ticks;
      }
      var dateTime = $tab_TickPlacement.$firstDateTimeInRange(dateTimeOrigin, dateTimeMin, dateTimeUnit, dateTimeIncrement);
      do {
        if (dateTimeMin <= dateTime && dateTimeMax >= dateTime) {
          var pt = $tab_TickPlacement.$dateTimeToDomain(dateTime, dateTimeMin, dateTimeMax);
          var tick1 = (xAxis ? $tab_TickPlacement.$calculatePointX(locOrigin, sizeOfDimension, pt, reversed) : $tab_TickPlacement.$calculatePointY(locOrigin, sizeOfDimension, pt, reversed));
          if (!$tab_TickPlacement.$isViewEdge(locOrigin, sizeOfDimension, tick1, includeViewEdges)) {
            ticks.push(tick1);
          }
        }
        dateTime = tab.DateUtil.adjustDateByPeriodInUTC(dateTime, dateTimeUnit, recommendedDateTimeIncrement);
      } while (dateTime <= dateTimeMax);
      return ticks;
    },
    $dateTimeLabels: function TickPlacement$DateTimeLabels(perHeaderMajorTickPlacement, sizeOfDimension, index, labelSkipResult) {
      var dateTimeOrigin = $tab_TickPlacement.formatDateTime(perHeaderMajorTickPlacement.DateTimeOrigin[index]);
      var dateTimeMin = $tab_TickPlacement.formatDateTime(perHeaderMajorTickPlacement.EncodingMin[index]);
      var dateTimeMax = $tab_TickPlacement.formatDateTime(perHeaderMajorTickPlacement.EncodingMax[index]);
      var dateTimeUnit = tab.EnumConversions.datePeriodTypeFromInt(perHeaderMajorTickPlacement.DateTimeSpacingUnit[index]);
      var dateTimeIncrement = perHeaderMajorTickPlacement.DateTimeSpacing[index];
      var recommendedDateTimeIncrement = $tab_TickPlacement.$getRecommendedDateTimeIncrement(dateTimeMin, dateTimeMax, dateTimeUnit, dateTimeIncrement, sizeOfDimension);
      recommendedDateTimeIncrement = recommendedDateTimeIncrement * labelSkipResult.get_skip();
      var labels = [];
      if (ss.staticEquals(dateTimeMin, dateTimeMax)) {
        if (labelSkipResult.get_includeFirstLabel() && labelSkipResult.get_includeLastLabel()) {
          labels.push(dateTimeOrigin);
        }
        return labels;
      }
      var dateTime = $tab_TickPlacement.$firstDateTimeInRange(dateTimeOrigin, dateTimeMin, dateTimeUnit, dateTimeIncrement);
      var isFirstLabel = true;
      do {
        if (dateTimeMin <= dateTime && dateTimeMax >= dateTime) {
          if (labelSkipResult.get_includeFirstLabel() || !isFirstLabel) {
            labels.push(dateTime);
          }
          if (isFirstLabel) {
            isFirstLabel = false;
          }
        }
        dateTime = tab.DateUtil.adjustDateByPeriodInUTC(dateTime, dateTimeUnit, recommendedDateTimeIncrement);
      } while (dateTime <= dateTimeMax);
      if (!labelSkipResult.get_includeLastLabel() && labels.length > 0) {
        ss.removeAt(labels, labels.length - 1);
      }
      return labels;
    },
    $getTickLabelValues: function TickPlacement$GetTickLabelValues(tickPlacement, index) {
      var labelValueIndex = tickPlacement.PerHeaderMajorTickPlacement.EncodedTickPositionsIndex[index];
      return tickPlacement.TickLabelValues[labelValueIndex];
    },
    $decodeLinearTicks: function TickPlacement$DecodeLinearTicks(encodedTicks, formatterIndex, tickLabelVisibleRange) {
      var range = tickLabelVisibleRange.max - tickLabelVisibleRange.min;
      return _.map(encodedTicks, function(x) {
        return tab.RuntimeFormattingHooks.formatRealValue(tickLabelVisibleRange.min + x * range, formatterIndex);
      });
    },
    $decodeDateTimeTicks: function TickPlacement$DecodeDateTimeTicks(encodedTicks, formatterIndex) {
      return _.map(encodedTicks, function(x) {
        return tab.RuntimeFormattingHooks.formatDateTimeValue(x, formatterIndex);
      });
    },
    $formatLogTicks: function TickPlacement$FormatLogTicks(tickLabelValues, formatterIndex, tickLabelVisibleRange, labelSkipResult) {
      var boundedTicks = [];
      var visibleTickLabelValues = $tab_TickPlacement.$getVisibleTickLabelValues(tickLabelValues, tickLabelVisibleRange, labelSkipResult);
      for (var $t1 = 0; $t1 < visibleTickLabelValues.length; $t1++) {
        var tickLabelValue = visibleTickLabelValues[$t1];
        if (tickLabelValue <= tickLabelVisibleRange.max && tickLabelValue >= tickLabelVisibleRange.min) {
          boundedTicks.push(tab.RuntimeFormattingHooks.formatRealValue(tickLabelValue, formatterIndex));
        }
      }
      return boundedTicks;
    },
    $getVisibleTickLabelValues: function TickPlacement$GetVisibleTickLabelValues(allTickLabelValues, tickLabelVisibleRange, labelSkipResult) {
      var tickLabelValues = [];
      if (allTickLabelValues.length === 0) {
        return tickLabelValues;
      }
      var idx = (labelSkipResult.get_includeFirstLabel() ? 0 : labelSkipResult.get_skip());
      while (idx < allTickLabelValues.length) {
        var curVal = allTickLabelValues[idx];
        var isLastTickAndShouldExcluded = !labelSkipResult.get_includeLastLabel() && (idx + labelSkipResult.get_skip() >= allTickLabelValues.length || allTickLabelValues[idx + labelSkipResult.get_skip()] > tickLabelVisibleRange.max);
        if (curVal >= tickLabelVisibleRange.min && curVal <= tickLabelVisibleRange.max && !isLastTickAndShouldExcluded) {
          tickLabelValues.push(curVal);
        }
        idx += labelSkipResult.get_skip();
      }
      return tickLabelValues;
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TickPlacementConfig
  var $tab_TickPlacementConfig = global.tab.TickPlacementConfig = ss.mkType($asm, 'tab.TickPlacementConfig', function(reversed, xAxis, getMinorTicks) {
    this.reversed = false;
    this.xAxis = false;
    this.getMinorTicks = false;
    this.reversed = reversed;
    this.xAxis = xAxis;
    this.getMinorTicks = getMinorTicks;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TotalNode
  var $tab_TotalNode = global.tab.TotalNode = ss.mkType($asm, 'tab.TotalNode', function() {
    this.label = null;
    this.stretchedPixelSize = 0;
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.TotalNodeMap
  var $tab_TotalNodeMap = global.tab.TotalNodeMap = ss.mkType($asm, 'tab.TotalNodeMap', function(nodesTable, totalTypes, sceneMarginLayoutTable, elidedLabels, sceneMarginLocation) {
    this.$totalNodeMap = null;
    this.$totalNodeMap = {};
    if (sceneMarginLocation === 1) {
      return;
    }
    this.$initTotalMap(nodesTable, totalTypes, elidedLabels, sceneMarginLayoutTable, sceneMarginLocation);
  }, {
    getTotalNode: function TotalNodeMap$GetTotalNode(level, nodeIndex) {
      return this.$totalNodeMap[$tab_TotalNodeMap.$makeKey(level, nodeIndex)];
    },
    $adjustTotalNodeIfParentIsTotalNode: function TotalNodeMap$AdjustTotalNodeIfParentIsTotalNode(pixelSizeArrayPerLevel, internalTotalMap) {
      var $t1 = new ss.ObjectEnumerator(internalTotalMap);
      try {
        while ($t1.moveNext()) {
          var levelIndexTuple = $t1.current();
          var currentInternalNode = levelIndexTuple.value;
          var parentInternalNode = internalTotalMap[$tab_TotalNodeMap.$makeKey(currentInternalNode.$level - 1, currentInternalNode.$enclosedIndex)];
          var label;
          var stretchedPixelSize = 0;
          if (ss.isValue(parentInternalNode)) {
            currentInternalNode.$label = parentInternalNode.$label;
            label = parentInternalNode.$label;
            if (parentInternalNode.$isStretched || parentInternalNode.$isEmpty) {
              currentInternalNode.$isEmpty = true;
            }
            else {
              stretchedPixelSize = pixelSizeArrayPerLevel[currentInternalNode.$level].item2;
            }
          }
          else {
            label = currentInternalNode.$label;
            stretchedPixelSize = pixelSizeArrayPerLevel[currentInternalNode.$level].item2;
          }
          var $t3 = this.$totalNodeMap;
          var $t4 = levelIndexTuple.key;
          var $t2 = new $tab_TotalNode();
          $t2.label = label;
          $t2.stretchedPixelSize = stretchedPixelSize;
          $t3[$t4] = $t2;
        }
      }
      finally {
        $t1.dispose();
      }
    },
    $initTotalMap: function TotalNodeMap$InitTotalMap(nodesTable, totalTypes, elidedLabels, sceneMarginLayoutTable, sceneMarginLocation) {
      var internalTotalMap = {};
      var pixelSizeArrayPerLevel = $tab_TotalNodeMap.$initPixelSizeArrayPerLevel(sceneMarginLayoutTable, sceneMarginLocation);
      var nodeIndexOnCurrentLevel = new Array(pixelSizeArrayPerLevel.length);
      for (var i = 0; i < nodeIndexOnCurrentLevel.length; i++) {
        nodeIndexOnCurrentLevel[i] = 0;
      }
      for (var i1 = 0; i1 < nodesTable.Level.length; i1++) {
        var level = nodesTable.Level[i1];
        if (ss.isNullOrUndefined(pixelSizeArrayPerLevel[level])) {
          continue;
        }
        var nodeIndex = nodeIndexOnCurrentLevel[level];
        nodeIndexOnCurrentLevel[level]++;
        if (totalTypes[i1] === 0) {
          continue;
        }
        var label = nodesTable.Label[i1 - 1];
        var labelForRender = (ss.isNullOrUndefined(elidedLabels) ? label : elidedLabels[i1]);
        var $t1 = new $tab_$InternalTotalNode();
        $t1.$label = $tab_NodeUtils.getLabelText(label, labelForRender);
        $t1.$isStretched = $tab_TotalNodeMap.$isStretched(pixelSizeArrayPerLevel[level]);
        $t1.$enclosedIndex = nodesTable.EnclosedIndex[i1];
        $t1.$level = level;
        var internalTotalNode = $t1;
        internalTotalMap[$tab_TotalNodeMap.$makeKey(level, nodeIndex)] = internalTotalNode;
      }
      if (pixelSizeArrayPerLevel.length > 0) {
        this.$adjustTotalNodeIfParentIsTotalNode(pixelSizeArrayPerLevel, internalTotalMap);
      }
    }
  }, {
    $initPixelSizeArrayPerLevel: function TotalNodeMap$InitPixelSizeArrayPerLevel(sceneMarginLayoutTable, sceneMarginLocation) {
      var pixelSizeArray = [];
      for (var i = 0; i < sceneMarginLayoutTable.SceneMarginLocation.length; i++) {
        if (sceneMarginLocation === sceneMarginLayoutTable.SceneMarginLocation[i] && sceneMarginLayoutTable.ElementType[i] === 2) {
          pixelSizeArray[sceneMarginLayoutTable.HeaderDepth[i]] = { item1: sceneMarginLayoutTable.PixelSize[i], item2: sceneMarginLayoutTable.StretchedPixelSize[i] };
        }
      }
      return pixelSizeArray;
    },
    $makeKey: function TotalNodeMap$MakeKey(level, nodeIndex) {
      return level + ':' + nodeIndex;
    },
    $isStretched: function TotalNodeMap$IsStretched(pixelSizes) {
      return !!(pixelSizes.item2 > pixelSizes.item1 & pixelSizes.item1 > 0);
    }
  });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.VAlign
  var $tab_VAlign = global.tab.VAlign = ss.mkEnum($asm, 'tab.VAlign', { bottom: 0, vCenter: 1, top: 2, vAutomatic: 3 });
  ////////////////////////////////////////////////////////////////////////////////
  // Tableau.JavaScript.Vql.RuntimeRendered.VisibleTickLabelsResult
  var $tab_VisibleTickLabelsResult = global.tab.VisibleTickLabelsResult = ss.mkType($asm, 'tab.VisibleTickLabelsResult', function(tickLabels, isFirstTickOutsideViewPort) {
    this.tickLabels = null;
    this.isFirstTickOutsideViewPort = false;
    this.tickLabels = tickLabels;
    this.isFirstTickOutsideViewPort = isFirstTickOutsideViewPort;
  });
  ss.initClass($tab_$InternalTotalNode);
  ss.initClass($tab_ArrowKeyNavigationUtil);
  ss.initClass($tab_ArrowKeyNavKeyboardShortcut, KeyboardShortcuts.BaseKeyboardShortcut, [KeyboardShortcuts.IKeyboardShortcut]);
  ss.initClass($tab_AxisBorderInput);
  ss.initClass($tab_AxisComponent, spiff.PureRenderComponent);
  ss.initClass($tab_AxisHolderComponent, spiff.PureRenderComponent);
  ss.initClass($tab_AxisHolderViewModel, ss.makeGenericType($tab_BaseHolderViewModel$1, [Object]), [tab.IViewModel, ss.IDisposable, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
  ss.initClass($tab_AxisPropsBuilder);
  ss.initClass($tab_AxisResizerComponent, spiff.PureRenderComponent);
  ss.initClass($tab_AxisResizerProps);
  ss.initClass($tab_AxisSortIndicator);
  ss.initClass($tab_AxisTitleComponent, spiff.PureRenderComponent);
  ss.initClass($tab_BaseSceneMarginElement, null, [tab.IRegionContentProvider, spiff.IScrollable]);
  ss.initClass($tab_BorderAttributes);
  ss.initClass($tab_BorderComponent, spiff.PureRenderComponent);
  ss.initClass($tab_BorderDataModel);
  ss.initClass($tab_BorderRenderer);
  ss.initClass($tab_CellResizerComponent, spiff.PureRenderComponent);
  ss.initClass($tab_CellResizerProps);
  ss.initClass($tab_DatastoreHeaderAdapter);
  ss.initClass($tab_DatastorePropsBuilder);
  ss.initClass($tab_FieldLabelComponent, spiff.PureRenderComponent);
  ss.initClass($tab_FieldLabelViewModel, ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]), [tab.IViewModel, ss.IDisposable, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
  ss.initClass($tab_HeaderHolderComponent, spiff.PureRenderComponent);
  ss.initClass($tab_HeaderHolderViewModel, ss.makeGenericType($tab_BaseHolderViewModel$1, [Object]), [tab.IViewModel, ss.IDisposable, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
  ss.initClass($tab_HeaderLabelStyleHelper);
  ss.initClass($tab_HeaderNodeComponent, spiff.PureRenderComponent);
  ss.initClass($tab_HeaderNodePropsBuilder);
  ss.initClass($tab_HeaderNodeSortIndicator);
  $tab_HeaderNodeSortIndicator.$ctor1.prototype = $tab_HeaderNodeSortIndicator.prototype;
  ss.initClass($tab_HeaderNonSkippedTextComponent, spiff.PureRenderComponent);
  ss.initClass($tab_HeaderResizerComponent, spiff.PureRenderComponent);
  ss.initClass($tab_IndicatorPosition);
  ss.initClass($tab_LabelRange);
  ss.initClass($tab_LabelSkip);
  ss.initClass($tab_LabelSkipResult);
  ss.initClass($tab_MinMaxPair);
  ss.initClass($tab_NestedSortIndicatorDataTableRow);
  ss.initClass($tab_NodeInfo);
  ss.initClass($tab_NodeInfoConverter);
  ss.initClass($tab_NodeUtils);
  ss.initClass($tab_NonScrollableHolderComponent, spiff.PureRenderComponent);
  ss.initClass($tab_OrientedSize);
  ss.initClass($tab_OuterBorderComponent, spiff.PureRenderComponent);
  ss.initClass($tab_OuterBorderViewModel, ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]), [tab.IViewModel, ss.IDisposable, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
  ss.initClass($tab_PerNodeData);
  ss.initClass($tab_ResizerConstants);
  ss.initClass($tab_SceneMarginBorderBuilder);
  ss.initClass($tab_SceneMarginComponent, spiff.PureRenderComponent);
  ss.initClass($tab_SceneMarginElement, $tab_BaseSceneMarginElement, [tab.IRegionContentProvider, spiff.IScrollable]);
  ss.initClass($tab_SceneMarginEnterSpaceKeyboardShortcut, KeyboardShortcuts.BaseKeyboardShortcut, [KeyboardShortcuts.IKeyboardShortcut]);
  ss.initClass($tab_SceneMarginEscKeyboardShortcut, KeyboardShortcuts.BaseKeyboardShortcut, [KeyboardShortcuts.IKeyboardShortcut]);
  ss.initClass($tab_SceneMarginHitTester);
  ss.initClass($tab_SceneMarginNodesContainer);
  ss.initClass($tab_SceneMarginSelection);
  ss.initClass($tab_SceneMarginViewModel, ss.makeGenericType(spiff.BaseReactViewModel$1, [Object]), [tab.IViewModel, ss.IDisposable, ss.makeGenericType(spiff.IPropsProvider$1, [Object])]);
  ss.initClass($tab_SelectionNode);
  ss.initClass($tab_TextStyleHelper);
  ss.initClass($tab_TickLabelComponent, spiff.PureRenderComponent);
  ss.initClass($tab_TickLabelProps);
  ss.initClass($tab_TickMarkComponent, spiff.PureRenderComponent);
  ss.initClass($tab_TickPlacement);
  ss.initClass($tab_TickPlacementConfig);
  ss.initClass($tab_TotalNode);
  ss.initClass($tab_TotalNodeMap);
  ss.initClass($tab_VisibleTickLabelsResult);
  (function() {
    $tab_AxisTitleComponent.displayName = ss.getTypeName($tab_AxisTitleComponent);
    $tab_AxisTitleComponent.multiLineAxisTitleContainerClass = 'tab-multiLineAxisTitleContainer';
    $tab_AxisTitleComponent.singleLineAxisTitleContainerClass = 'tab-singleLineAxisTitleContainer';
  })();
  (function() {
    $tab_TickMarkComponent.displayName = ss.getTypeName($tab_TickMarkComponent);
  })();
  (function() {
    $tab_TickLabelComponent.displayName = ss.getTypeName($tab_TickLabelComponent);
    $tab_TickLabelComponent.tickLabelAlignerClass = 'tab-vizAxisTickLabelAligner';
    $tab_TickLabelComponent.tickLabelContentClass = 'tab-vizAxisTickLabelContent';
    $tab_TickLabelComponent.$padding = 2;
  })();
  (function() {
    $tab_AxisSortIndicator.sortIndicatorSize = 15;
  })();
  (function() {
    $tab_AxisComponent.displayName = ss.getTypeName($tab_AxisComponent);
  })();
  (function() {
    $tab_BorderComponent.displayName = ss.getTypeName($tab_BorderComponent);
    $tab_BorderComponent.$crispEdges = 'crispEdges';
    $tab_BorderComponent.$svgWidth = 6;
  })();
  (function() {
    $tab_AxisHolderComponent.displayName = ss.getTypeName($tab_AxisHolderComponent);
  })();
  (function() {
    $tab_AxisResizerComponent.displayName = ss.getTypeName($tab_AxisResizerComponent);
  })();
  (function() {
    $tab_CellResizerComponent.displayName = ss.getTypeName($tab_CellResizerComponent);
  })();
  (function() {
    $tab_FieldLabelComponent.displayName = ss.getTypeName($tab_FieldLabelComponent);
    $tab_FieldLabelComponent.fieldLabelClass = 'tab-vizHeaderFieldLabel';
  })();
  (function() {
    $tab_HeaderNodeComponent.displayName = ss.getTypeName($tab_HeaderNodeComponent);
  })();
  (function() {
    $tab_HeaderNonSkippedTextComponent.displayName = ss.getTypeName($tab_HeaderNonSkippedTextComponent);
    $tab_HeaderNonSkippedTextComponent.nonSkippedTextLabelContainerClass = 'tab-vizHeaderNonSkippedLabelContainer';
  })();
  (function() {
    $tab_HeaderHolderComponent.displayName = ss.getTypeName($tab_HeaderHolderComponent);
  })();
  (function() {
    $tab_HeaderNodePropsBuilder.$transparentWhite = new tab.ColorModel(255, 255, 255, 0);
    $tab_HeaderNodePropsBuilder.$black = new tab.ColorModel(0, 0, 0, 1);
  })();
  (function() {
    $tab_HeaderResizerComponent.displayName = ss.getTypeName($tab_HeaderResizerComponent);
  })();
  (function() {
    $tab_NonScrollableHolderComponent.displayName = ss.getTypeName($tab_NonScrollableHolderComponent);
  })();
  (function() {
    $tab_OuterBorderComponent.displayName = ss.getTypeName($tab_OuterBorderComponent);
  })();
  (function() {
    $tab_SceneMarginComponent.displayName = ss.getTypeName($tab_SceneMarginComponent);
  })();
})();
// END RuntimeRendered
