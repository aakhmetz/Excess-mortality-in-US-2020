(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"), require("@tableau/browser-support"), require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery", "@tableau/browser-support", "react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["EventUtils"] = factory(require("jquery"), require("@tableau/browser-support"), require("react"), require("react-dom"));
	else
		root["EventUtils"] = factory(root["$"], root["BrowserSupport"], root["React"], root["ReactDOM"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_35__, __WEBPACK_EXTERNAL_MODULE_36__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil = /** @class */ (function () {
    function MiscUtil() {
    }
    // tslint:disable-next-line:no-any
    MiscUtil.IsNullOrUndefined = function (o) {
        return (o === null || o === undefined);
    };
    /**
     * Returns a deep clone of the given object
     * @param src the object to be deep copied
     */
    MiscUtil.CloneObject = function (src) {
        var objStr = JSON.stringify(src, function (k, v) {
            /*
             * This is necessary because the runtime HUTT serializer sends over data
             * in associative containers and javascript does not have a definition for handling them.
             * This code snippet forces them to be interpreted as standard arrays for the purpose
             * of serialization.
             */
            if (v instanceof Uint32Array || v instanceof Float64Array || v instanceof Float32Array) {
                return Array.prototype.slice.call(v);
            }
            return v;
        });
        return JSON.parse(objStr);
    };
    /**
     * Safely calls Window.ClearTimeout for the provided handle, which was previously created using Window.SetTimeout.
     * Returns null so that you can clear the timeout and assign in one statement, e.g.:
     * myTimeout = MiscUtil.ClearTimeout(myTimeout);
     */
    MiscUtil.ClearTimeout = function (handle) {
        if (!MiscUtil.IsNullOrUndefined(handle)) {
            window.clearTimeout(handle);
        }
        return null;
    };
    return MiscUtil;
}());
exports.MiscUtil = MiscUtil;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:no-any
var defaultShim = function () {
    throw new Error('Uninitialized EventUtils module use.');
};
var BootstrapUtility = /** @class */ (function () {
    function BootstrapUtility() {
    }
    Object.defineProperty(BootstrapUtility, "IsEmbedded", {
        get: function () {
            return BootstrapUtility.isEmbedded;
        },
        set: function (v) {
            BootstrapUtility.isEmbedded = v;
        },
        enumerable: true,
        configurable: true
    });
    BootstrapUtility.isEmbedded = defaultShim;
    return BootstrapUtility;
}());
exports.BootstrapUtility = BootstrapUtility;
var TsConfig = /** @class */ (function () {
    function TsConfig() {
    }
    Object.defineProperty(TsConfig, "IsMobile", {
        get: function () {
            return TsConfig.isMobile;
        },
        set: function (v) {
            TsConfig.isMobile = v;
        },
        enumerable: true,
        configurable: true
    });
    TsConfig.isMobile = defaultShim;
    return TsConfig;
}());
exports.TsConfig = TsConfig;
var FeatureParam = /** @class */ (function () {
    function FeatureParam() {
    }
    Object.defineProperty(FeatureParam, "DebugTools", {
        get: function () {
            return FeatureParam.debugTools;
        },
        set: function (v) {
            FeatureParam.debugTools = v;
        },
        enumerable: true,
        configurable: true
    });
    FeatureParam.debugTools = defaultShim;
    return FeatureParam;
}());
exports.FeatureParam = FeatureParam;
var FeatureFlag = /** @class */ (function () {
    function FeatureFlag() {
    }
    Object.defineProperty(FeatureFlag, "IsEventHandlingReworkEnabled", {
        get: function () {
            return FeatureFlag.isEventHandlingReworkEnabled;
        },
        set: function (v) {
            FeatureFlag.isEventHandlingReworkEnabled = v;
        },
        enumerable: true,
        configurable: true
    });
    FeatureFlag.isEventHandlingReworkEnabled = defaultShim;
    return FeatureFlag;
}());
exports.FeatureFlag = FeatureFlag;
var Logger = /** @class */ (function () {
    function Logger() {
    }
    Object.defineProperty(Logger, "Debug", {
        get: function () {
            return Logger.debug;
        },
        set: function (v) {
            Logger.debug = v;
        },
        enumerable: true,
        configurable: true
    });
    Logger.debug = function (unused) {
        // by default ignore
    };
    return Logger;
}());
exports.Logger = Logger;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil_1 = __webpack_require__(0);
var TypeUtil;
(function (TypeUtil) {
    function GetField(obj, v) {
        // tslint:disable-next-line:no-any whitespace
        return obj[v];
    }
    TypeUtil.GetField = GetField;
    // tslint:disable-next-line:no-any
    function SetField(obj, v, value) {
        // tslint:disable-next-line:no-any whitespace
        obj[v] = value;
    }
    TypeUtil.SetField = SetField;
    function HasField(obj, v) {
        return !MiscUtil_1.MiscUtil.IsNullOrUndefined(GetField(obj, v));
    }
    TypeUtil.HasField = HasField;
    function HasMethod(obj, v) {
        return !MiscUtil_1.MiscUtil.IsNullOrUndefined(GetField(obj, v))
            && (typeof (GetField(obj, v)) === 'function');
    }
    TypeUtil.HasMethod = HasMethod;
})(TypeUtil || (TypeUtil = {}));
exports.TypeUtil = TypeUtil;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = __webpack_require__(12);
var browser_support_1 = __webpack_require__(4);
var EventRecognizer_1 = __webpack_require__(16);
var MiscUtil_1 = __webpack_require__(0);
var MouseEventUtil_1 = __webpack_require__(15);
var NormalizedEventBuilder_1 = __webpack_require__(32);
var SelectAction_1 = __webpack_require__(33);
var TypeUtil_1 = __webpack_require__(2);
// ------------------------------------
// Helper functions
var TouchListImpl = /** @class */ (function (_super) {
    __extends(TouchListImpl, _super);
    function TouchListImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TouchListImpl.prototype.item = function (index) {
        return this[index];
    };
    return TouchListImpl;
}(Array));
/**
* Wrapper class around touch and mouse events to normalize them for our event handling system. Generally,
* the NormalizedEvent object looks more like a TouchEvent object than a MouseEvent object. See the comments
* on the fields for the API.
*/
var NormalizedEvent = /** @class */ (function () {
    // ===========================================================================================================
    // Constructors
    // ===========================================================================================================
    /**
    * Initializes a new instance of the NormalizedEvent class
    *
    * @param {TouchEvent} evt - TouchEvent object from Browser
    * @param {HTMLElement} listeningNode - Element object of the relevant node
    * @param {React.SyntheticEvent} reactEvent - Only necessary if coming from the React world
    */
    function NormalizedEvent(evt, listeningNode, reactEvent) {
        if (reactEvent === void 0) { reactEvent = null; }
        this.originalEvent = evt;
        this.reactEvent = reactEvent;
        this.type = evt.type;
        this.timeStamp = evt.timeStamp;
        this.keyCode = TypeUtil_1.TypeUtil.GetField(evt, 'keyCode');
        this.ctrlKey = evt.ctrlKey;
        this.altKey = evt.altKey;
        this.metaKey = evt.metaKey;
        this.shiftKey = evt.shiftKey;
        this.clientX = TypeUtil_1.TypeUtil.GetField(evt, 'clientX');
        this.clientY = TypeUtil_1.TypeUtil.GetField(evt, 'clientY');
        // Both iOS and Android browsers make the target of an event the textNode, not the Element. W3 decided that
        // this is dumb (on 3/25/2011), and we think it is too. Targets should be elements, not text nodes
        // $NOTE-kjacyna-2020-02-25: This problem also occurs in Firefox - updating this check to apply to
        // mouse events as well // TFSID: 1073360 [Firefox] Slow metadata search throws TypeError: 'matches' called
        // on an object that does not implement interface Element.
        var target = evt.target;
        // tslint:disable-next-line:strict-boolean-expressions
        this.target = target && target.nodeType === 3 /*XmlNodeType.Text*/ ? target.parentNode : target;
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(evt.touches)) {
            // we're in a touch environment
            // $NOTE-myork-2011-04-25: Hello person from the future. This doesn't normalize for Android vs iOS differences.
            // The TouchObjects in the touches, targetTouches arrays are different ontouchend. I don't know the exact details
            // - those are for whoever has to implement Android support.
            this.touches = evt.touches;
            this.targetTouches = evt.targetTouches;
            this.changedTouches = evt.changedTouches;
            // touch objects don't provide the currentTarget that the event listener is attached to
            this.currentTarget = listeningNode;
        }
        else {
            // we're in a mouse environment
            // touches and targetTouches should be empty onmouseup
            // tslint:disable:whitespace
            var tmpArray = new TouchListImpl();
            tmpArray[0] = evt; // wow this is still shady
            this.targetTouches = (evt.type === "mouseup" /* MouseUp */) ? new TouchListImpl() : tmpArray;
            this.touches = this.targetTouches;
            this.changedTouches = new TouchListImpl();
            this.changedTouches[0] = evt;
            this.currentTarget = evt.currentTarget;
            // tslint:enable:whitespace
        }
        // build associative array so we can grab touches by their unique identifier.
        var i = this.touches.length;
        this.touchesById = new Array(i);
        while (i > 0) {
            i -= 1;
            // tslint:disable-next-line:strict-boolean-expressions
            var index = this.touches[i].identifier || NormalizedEvent.MouseIdentifier;
            this.touchesById[index] = this.touches[i];
        }
        i = this.changedTouches.length;
        while (i > 0) {
            i -= 1;
            // tslint:disable-next-line:strict-boolean-expressions
            var index = this.changedTouches[i].identifier || NormalizedEvent.MouseIdentifier;
            this.touchesById[index] = this.changedTouches[i];
        }
    }
    Object.defineProperty(NormalizedEvent.prototype, "IsMouseEvent", {
        // ===========================================================================================================
        // Properties
        // ===========================================================================================================
        get: function () {
            return this.source === 1 /* Mouse */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsTouchEvent", {
        get: function () {
            return this.source === 2 /* Touch */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsStartEvent", {
        get: function () {
            return this.inputType === 0 /* Start */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsMoveEvent", {
        get: function () {
            return this.inputType === 1 /* Move */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsOutEvent", {
        get: function () {
            return this.inputType === 3 /* Out */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsEndEvent", {
        get: function () {
            return this.inputType === 2 /* End */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsScrollEvent", {
        get: function () {
            return this.inputType === 4 /* Scroll */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsRightClickEvent", {
        get: function () {
            return (this.type === "contextmenu" /* ContextMenu */ && this.source === 1 /* Mouse */);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsLeftMouseEvent", {
        get: function () {
            if (this.IsMouseEvent) {
                var mouseBtn = this.RetrieveMouseButton();
                if (mouseBtn === "left" /* Left */) {
                    // on mac, left button + ctrl key = contextmenu event so should actually be treated as a right-click
                    if (browser_support_1.BrowserSupport.IsMac() && this.ctrlKey) {
                        return false;
                    }
                    return true;
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsRightMouseEvent", {
        get: function () {
            if (this.IsMouseEvent) {
                var mouseBtn = this.RetrieveMouseButton();
                if (mouseBtn === "right" /* Right */) {
                    return true;
                }
                else {
                    if (mouseBtn === "left" /* Left */ && browser_support_1.BrowserSupport.IsMac() && this.altKey) {
                        // on mac, left button + option key = should be treated as a right-drag
                        return true;
                    }
                }
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "IsCtrlKey", {
        /**
        * @returns {boolean} true if the Ctrl key is pressed on Windows, or the meta(command) key is pressed on Mac.
        */
        get: function () {
            return browser_support_1.BrowserSupport.IsMac() ? this.metaKey : this.ctrlKey;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalizedEvent.prototype, "GestureInfo", {
        /**
        * Gets the gesture event info for this event.
        */
        get: function () {
            // Gesture event info gets "mixed in" using jQuery.Extend.
            return this;
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Returns whether or not all touches in the event object share a currentTarget.
    * Only pays attention to the first two touches in the touches array.
    * Preconditions:
    *   - more than 1 touch in e.touches in array
    *   - one touch  must be a child of the target (implicitly true
    *     by being inside of the EventHandler - one of the touches must be a child of
    *     the currentTarget, otherwise we would never have received a touch event object).
    *
    * We need to let Safari do its default viewport zoom for a pinch where the targets
    * are different. Unfortunately, we have no way to get the currentTarget of touch objects.
    * It's just not provided. So we do the dirty work here.
    */
    NormalizedEvent.prototype.AllTouchesShareCurrentTarget = function () {
        var node1 = this.touches[0].target; // a Touch Object's target behaves like currentTarget for a mouse event
        var node2 = this.touches[1].target;
        // Touch Target is of type EventTarget and it could be either Element(XmlElement in Salterelle), Document or Window.
        // If any one of the touch target is
        // not of the type Element, then we can safely determine that touches don't share target.
        if (!(node1 instanceof Element) || !(node2 instanceof Element)) {
            return false;
        }
        var body = document.body;
        var currentTarget = this.currentTarget;
        var done = false;
        // walk up the tree until each element reaches the target or the body.
        while (!done && !MiscUtil_1.MiscUtil.IsNullOrUndefined(node1) && !MiscUtil_1.MiscUtil.IsNullOrUndefined(node2)) {
            done = true;
            if (node1 !== currentTarget && node1 !== body && node1 instanceof Element) {
                node1 = node1.parentNode;
                done = false;
            }
            if (node2 !== currentTarget && node2 !== body && node2 instanceof Element) {
                node2 = node2.parentNode;
                done = false;
            }
            // If both nodes converge while traversing, then they must share the same currentTarget,
            // so break now for efficiency's sake (this loop would still work without this check)
            if (node1 === node2) {
                done = true;
            }
        }
        return node1 === node2;
    };
    Object.defineProperty(NormalizedEvent, "AllHandledEvents", {
        get: function () {
            return _.map(NormalizedEventBuilder_1.NormalizedEventBuilder.HandledEvents, function (item, key) { return key; });
        },
        enumerable: true,
        configurable: true
    });
    // ===========================================================================================================
    // Methods
    // ===========================================================================================================
    NormalizedEvent.Create = function (evt, listeningNode, reactEvent) {
        if (reactEvent === void 0) { reactEvent = null; }
        return NormalizedEventBuilder_1.NormalizedEventBuilder.CreateNormalizedEvent(evt, listeningNode, reactEvent);
    };
    NormalizedEvent.prototype.RetrieveMouseButton = function () {
        // For mouse move events, we can't check the event for the move event
        // so we will rely on the last button clicked.
        //
        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
        return this.IsMoveEvent ? EventRecognizer_1.EventRecognizer.CurrentGlobalMouseButton : MouseEventUtil_1.MouseEventUtil.GetMouseButtonEnum(this.originalEvent);
    };
    /**
    * Determines what the selection mode is for a text area or a text box
    * based on the state of the keyboard keys.
    */
    NormalizedEvent.prototype.GetSelectAction = function () {
        var action = SelectAction_1.SelectAction.Simple;
        var toggle = this.IsCtrlKey;
        if (this.shiftKey) {
            action = SelectAction_1.SelectAction.Range;
        }
        if (toggle) {
            action = SelectAction_1.SelectAction.Toggle;
        }
        return action;
    };
    NormalizedEvent.prototype.preventDefault = function () {
        if (TypeUtil_1.TypeUtil.HasMethod(this.originalEvent, 'preventDefault')) {
            this.originalEvent.preventDefault();
        }
    };
    NormalizedEvent.prototype.stopPropagation = function () {
        if (TypeUtil_1.TypeUtil.HasMethod(this.originalEvent, 'stopPropagation')) {
            this.originalEvent.stopPropagation();
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.reactEvent)) {
            this.reactEvent.stopPropagation();
        }
    };
    // redirection for saltarelle generated javascript getters
    NormalizedEvent.prototype.get_IsRightMouseEvent = function () { return this.IsRightMouseEvent; };
    NormalizedEvent.prototype.get_GestureInfo = function () { return this.GestureInfo; };
    NormalizedEvent.prototype.get_IsMouseEvent = function () { return this.IsMouseEvent; };
    NormalizedEvent.prototype.get_IsTouchEvent = function () { return this.IsTouchEvent; };
    NormalizedEvent.prototype.get_IsStartEvent = function () { return this.IsStartEvent; };
    NormalizedEvent.prototype.get_IsMoveEvent = function () { return this.IsMoveEvent; };
    NormalizedEvent.prototype.get_IsOutEvent = function () { return this.IsOutEvent; };
    NormalizedEvent.prototype.get_IsEndEvent = function () { return this.IsEndEvent; };
    NormalizedEvent.prototype.get_IsScrollEvent = function () { return this.IsScrollEvent; };
    NormalizedEvent.prototype.get_IsRightClickEvent = function () { return this.IsRightClickEvent; };
    NormalizedEvent.prototype.get_IsLeftMouseEvent = function () { return this.IsLeftMouseEvent; };
    NormalizedEvent.prototype.get_IsCtrlKey = function () { return this.IsCtrlKey; };
    NormalizedEvent.MouseIdentifier = 0; // touches have unique identifier codes. Use this for a mouse event disguised as a touch
    return NormalizedEvent;
}());
exports.NormalizedEvent = NormalizedEvent;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var EventHandleSpec_1 = __webpack_require__(7);
var MiscUtil_1 = __webpack_require__(0);
var TableauEventHandler_1 = __webpack_require__(8);
var ZoomScaleUtil_1 = __webpack_require__(17);
/**
* Base class of gestures object
*/
var Gesture = /** @class */ (function () {
    /**
    * Initializes a new instance of the Gesture class
    *
    * @param {GestureEventHandleSpec} config - GestureEventHandleSpec object
    * @param {GestureType} type - name of the gesture
    * @param {boolean} hasSlop - Whether the gesture should tolerate some slow
    *  (such as touch and drag events) or if it should require exact behavior (such as hover)
    * @param {number} numTouches- # of touches
    */
    function Gesture(config, type, hasSlop, numTouches) {
        this.slop = 5;
        this.numTouches = 1;
        this.type = "gesture" /* Base */;
        // Note:
        // doubleTapTimer, potentialPressTimer, pressTimer get created/deleted as needed
        this.isPotentialPress = false;
        this.isActivePress = false;
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(type)) {
            this.type = type;
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(hasSlop)) {
            this.slop = hasSlop ? Gesture.DefaultSlop : 0;
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(numTouches)) {
            this.numTouches = numTouches;
        }
        this.Config = new EventHandleSpec_1.EventHandleSpec();
        this.Update(config);
    }
    Object.defineProperty(Gesture.prototype, "DataAttributeName", {
        get: function () {
            return Gesture.DataAttributePrefix + this.type.toString();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Gesture.prototype, "ZoomAdjustedSlop", {
        get: function () {
            var zoomScale = ZoomScaleUtil_1.ZoomScaleUtil.GetScaleSync();
            return Math.round(this.slop / zoomScale);
        },
        enumerable: true,
        configurable: true
    });
    Gesture.prototype.Update = function (config) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(config)) {
            $.extend(this.Config, config);
            $(this.Config.DomElement).data(this.DataAttributeName, this);
        }
    };
    Gesture.prototype.Fire = function (callbackName, evt, param) {
        if (this.Config.IsHandling(callbackName)) {
            var pseudoEvent = evt;
            $.extend(pseudoEvent, param);
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(pseudoEvent.reactEvent)) {
                $.extend(pseudoEvent.reactEvent, param);
            }
            pseudoEvent.gestureName = this.type.toString();
            pseudoEvent.callbackName = callbackName;
            var callback = TableauEventHandler_1.TableauEventHandler.GetHandler(this.Config, callbackName);
            callback(pseudoEvent);
        }
    };
    Gesture.prototype.dispose = function () {
        this.Cancel();
        $(this.Config.DomElement).removeData(this.DataAttributeName);
    };
    Gesture.FromHtml = function (domElement, type) {
        return $(domElement).data(Gesture.DataAttributePrefix + type.toString());
    };
    // The default minimum threshold, in pixels, for a gesture to move before no longer being considered a tap/press gesture.
    Gesture.DefaultSlop = 5;
    // The max time, in ms, allowed between two taps in order to recognize a double tap.
    Gesture.DoubleTapTime = 390;
    // The total time, in ms, for a PotentialPress event to be fired when holding a press down. The PotentialPress event is
    // signaled on our way to Press to allow "pre-press" animations.
    Gesture.PotentialPressTime = 500;
    // The total time, in ms, for a Press event to be fired when holding a press down.
    Gesture.PressTime = 750;
    Gesture.DataAttributePrefix = 'tab-';
    return Gesture;
}());
exports.Gesture = Gesture;
var GestureEventInfo = /** @class */ (function () {
    function GestureEventInfo() {
    }
    return GestureEventInfo;
}());
exports.GestureEventInfo = GestureEventInfo;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil_1 = __webpack_require__(0);
var TypeUtil_1 = __webpack_require__(2);
// ====================================================================================================================
//
// ****** Comprehensive Documentation for Event Handling System *******
//
// Create a new EventHandler to give a dom node gestures. The client should keep the handler and call its
// destroy() method when done with it. You can construct with only the callbacks you need -- you don't need to specify
// all of them. To preventDefault, you must call e.preventDefault() in the object returned to you in the callback.
// Propagation is stopped for you. Always. Always and forever.
//
// The event object passed to the callback should be treated like a real event object, though it isn't actually one.
// If there is any event property you need that the pseudo-event object does not have, please add it yourself
// in Gesture.js::fire. All event objects have {timestamp:number, gesture: string, callback: string}
// properties. Additional properties vary based on gesture type - see below.
//
// Copy and paste usage of EventHandler:
// var eventHandler = new tableau.base.EventHandler(domElement, {
//
//        // DISCRETE: e = touch event object augmented with pageX, pageY
//        'firstTouch':           function (e) {},
//        'lastTouch':            function (e) {},
//        'cancelPotentialDoubleTap:    function (e) {}, // fired when doubleTap is not fired after the first Tap.
//        'tap':                  function (e) {},
//        'doubleTap':            function (e) {},
//        'potentialPress':       function (e) {},
//        'cancelPotentialPress': function (e) {}, // fired when potentialPress is fired but press is not fired
//        'press':                function (e) {},
//        'tapAndHalf':           function (e) {},  //NOT YET IMPLEMENTED Probably use same callback as press
//
//        // SINGLE FINGER CONTINUOUS: e with {pageX, pageY, deltaX, deltaY (change in position from beginning
//        // of gesture), deltaXSinceLast, deltaYSinceLast (change since last callback)}
//        'dragStart':            function (e) {},
//        'dragMove':             function (e) {},
//        'dragEnd':              function (e) {},
//        'pressDragStart':       function (e) {},
//        'pressDragMove':        function (e) {},
//        'pressDragEnd':         function (e) {},
//
//        // TWO FINGER CONTINUOUS: e with {pageX, pageY, scale, deltaX, deltaY (change in center point between the
//        // two fingers since beginning of gesture), deltaXSinceLast, deltaYSinceLast (change in center point
//        // between the two fingers since last callback)},
//        'pinchStart':           function (e) {},
//        'pinchMove':            function (e) {},
//        'pinchEnd':             function (e) {},
//        'doublePressDragStart': function (e) {},
//        'doublePressDragMove':  function (e) {},
//        'doublePressDragEnd':   function (e) {},
//
//        // HYBRID MUTANT SAVAGES: Gets touch object of tap finger.
//        'HoldTapStart':         function (e) {},  //NOT YET IMPLEMENTED
//        'HoldTapTap':           function (e) {},  //NOT YET IMPLEMENTED
//        'HoldTapEnd':           function (e) {},  //NOT YET IMPLEMENTED
//
//        // CONFIGURATION OPTIONS
//        'debug':    true, // defaults false. Will leave feedback in a box on bottom right whenever event is fired
// });
// eventHandler.destroy(); //call before destroying your domElement.
//
//
// *********** Global Events **************
//
// There are global events fired just prior to Discrete's handling of certain events. This gives you a chance to do something
// prior to the event being handled, and also allows you to cancel the event. This allows things like tooltips, dialogs,
// type-in pill, etc. watch for and react to events external to themselves.
//
// Each of the events allows you to setup a handler where params are the NormalizedEvent and a callback.  If you invoke the
// the callback, the default Discrete behavior for the event will be canceled.  If you pass true to the callback, preventDefault
// will also be called on the event object.
//
// To handle to these global events:
//
//  public void Init() {
//      GlobalUIEvents.Press += this.OnGlobalPress;
//  }
//  public void Destroy() {
//      GlobalUIEvents.Press -= this.OnGlobalPress;
//  }
//  private void OnGlobalPress(NormalizedEvent e, Action<bool> cancelCallback)
//  {
//      if (!DomUtil.IsAncestorOf(this.domNode, e.target)) {
//          this.HideOrDoOtherStuff();
//          cancelCallback(true);
//      }
//  }
//
// <see cref="GlobalUIEvents"/>
// ====================================================================================================================
// TODO:
// - Potential bug: If both fingers hit perfectly simulataneously on two different dom elements,
//                  no firstTouch is fired. This shouldn't be a problem.
// - Improve: Dynamically add move and end event listeners for touch.
// - Improve: Pinch simulation in desktop. Shift click simulates center point? Implement in NormalizedEvent?
// - Right now we run all gestures no matter what the client cares about, but the event only gets fired if a
//   callback exists.
/** Config for the <see cref="TableauEventHandler"/>*/
/// <remarks>Ideally we'd derive from <see cref="Record"/> but currently we cannot since that will initialize
/// all fields to null.  This causes issues since we use <see cref="jQuery.Extend(object,object[])"/> to merge
/// instances of configs.  And even though the jQuery docs say otherwise null properties are copied over,
/// which causes issues for us.</remarks>
var EventHandleSpec = /** @class */ (function () {
    function EventHandleSpec() {
        // DISCRETE: e = touch event object augmented with pageX, pageY
        this.firstTouch = undefined;
        // this is just the touchMove event, and not mouse move or (mousedown + move) on web
        this.touchMove = undefined;
        this.lastTouch = undefined;
        // fired when doubleTap is not fired after the first Tap.
        this.cancelPotentialDoubleTap = undefined;
        this.tap = undefined;
        this.doubleTap = undefined;
        this.potentialPress = undefined;
        // fired when potentialPress is fired but press is not fired
        this.cancelPotentialPress = undefined;
        this.press = undefined;
        this.pressEnd = undefined;
        this.rightClick = undefined;
        // NOT YET IMPLEMENTED Probably use same callback as press
        this.tapAndHalf = undefined;
        // HOVER
        this.hover = undefined;
        // SINGLE FINGER CONTINUOUS: e with {pageX, pageY, deltaX, deltaY (change in position from beginning
        // of gesture), deltaXSinceLast, deltaYSinceLast (change since last callback)}
        this.dragStart = undefined;
        this.dragMove = undefined;
        this.dragEnd = undefined;
        this.pressDragStart = undefined;
        this.pressDragMove = undefined;
        this.pressDragEnd = undefined;
        // TWO FINGER CONTINUOUS: e with {pageX, pageY, scale, deltaX, deltaY (change in center point between the
        // two fingers since beginning of gesture), deltaXSinceLast, deltaYSinceLast (change in center point
        // between the two fingers since last callback)},
        this.pinchStart = undefined;
        this.pinchMove = undefined;
        this.pinchEnd = undefined;
        this.doublePressDragStart = undefined;
        this.doublePressDragMove = undefined;
        this.doublePressDragEnd = undefined;
        // HYBRID MUTANT SAVAGES: Gets touch object of tap finger.
        this.holdTapStart = undefined; // NOT YET IMPLEMENTED
        this.holdTapTap = undefined; // NOT YET IMPLEMENTED
        this.holdTapEnd = undefined; // NOT YET IMPLEMENTED
        this.domElem = undefined;
    }
    Object.defineProperty(EventHandleSpec.prototype, "DomElement", {
        get: function () {
            return this.domElem;
        },
        set: function (dom) {
            this.domElem = dom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventHandleSpec.prototype, "HoverDelay", {
        get: function () {
            return this.hoverDelay;
        },
        set: function (delay) {
            this.hoverDelay = delay;
        },
        enumerable: true,
        configurable: true
    });
    // Extension methods
    EventHandleSpec.prototype.IsHandling = function (evt) {
        var dict = this;
        var result = TypeUtil_1.TypeUtil.GetField(dict, evt);
        return !MiscUtil_1.MiscUtil.IsNullOrUndefined(result);
    };
    EventHandleSpec.prototype.IsUsingHover = function () {
        return this.IsHandling("hover" /* Hover */) ||
            this.IsHandling("moving" /* Moving */);
    };
    /**
    * Returns true if any pressDrag related callbacks are set
    */
    EventHandleSpec.prototype.UsingPressDrag = function () {
        return this.IsHandling("pressDragStart" /* PressDragStart */) ||
            this.IsHandling("pressDragMove" /* PressDragMove */) ||
            this.IsHandling("pressDragEnd" /* PressDragEnd */) ||
            this.IsHandling("doublePressDragStart" /* DoublePressDragStart */) ||
            this.IsHandling("doublePressDragMove" /* DoublePressDragMove */) ||
            this.IsHandling("doublePressDragEnd" /* DoublePressDragEnd */);
    };
    EventHandleSpec.prototype.SetHandler = function (evt, fn) {
        TypeUtil_1.TypeUtil.SetField(this, evt, fn);
    };
    EventHandleSpec.prototype.RemoveHandler = function (evt) {
        TypeUtil_1.TypeUtil.SetField(this, evt, null);
    };
    return EventHandleSpec;
}());
exports.EventHandleSpec = EventHandleSpec;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var browser_support_1 = __webpack_require__(4);
var Delegate_1 = __webpack_require__(9);
var DomSubscriptionHandle_1 = __webpack_require__(26);
var DomUtil_1 = __webpack_require__(13);
var EventHandleSpec_1 = __webpack_require__(7);
var EventRecognizer_1 = __webpack_require__(16);
var VizclientUtils_1 = __webpack_require__(1);
var MiscUtil_1 = __webpack_require__(0);
var NormalizedEvent_1 = __webpack_require__(5);
var PointerEventDetector_1 = __webpack_require__(27);
var TypeUtil_1 = __webpack_require__(2);
exports.OptOutAttributeName = 'data-eventutils-optout';
// tslint:disable:strict-boolean-expressions
/** Replacement for Element.closest -- can switch to Element.closest once we drop IE11 support */
function closest(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
    if (!matches) {
        return null;
    }
    var node = element;
    while (node) {
        if (matches.call(node, selector)) {
            return node;
        }
        node = node.parentElement;
    }
    return null;
}
// tslint:enable:strict-boolean-expressions
/**
* This class listens to all the mouse and touch events on a specific DOM element.
* It processes(with help of other classes) these events and manage invoking callbacks
* specified in EventHandlerSpec object it is initialized with.
*/
var TableauEventHandler = /** @class */ (function () {
    /**
    * Initializes a new instance of the TableauEventHandler class
    * Takes domElement and an object with callbacks - see documentation in EventHandlerSpec.cs
    * @param {HTMLElement} domElement - Element object
    * @param {EventHandleSpec} config - GestureEventHandleSpec object
    */
    function TableauEventHandler(domElement, config) {
        if (domElement === void 0) { domElement = null; }
        if (config === void 0) { config = null; }
        this.subscriptionHandle = null;
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(domElement) || MiscUtil_1.MiscUtil.IsNullOrUndefined(EventHandleSpec_1.EventHandleSpec)) {
            return;
        }
        // tslint:disable-next-line:strict-boolean-expressions
        this.config = config || new EventHandleSpec_1.EventHandleSpec();
        this.config.DomElement = domElement;
        if (VizclientUtils_1.FeatureFlag.IsEventHandlingReworkEnabled() && !PointerEventDetector_1.PointerEventDetector.initialized) {
            PointerEventDetector_1.PointerEventDetector.init();
        }
        this.ConfigureDomElem(domElement);
        this.SetupEventRecognizer(this.config);
        this.MakeConnections(domElement);
        // #if DEBUG
        TableauEventHandler.RaiseTableauEventHandlerCreated(this);
        // #endif
    }
    Object.defineProperty(TableauEventHandler.prototype, "DomElement", {
        get: function () {
            return this.config.DomElement;
        },
        enumerable: true,
        configurable: true
    });
    TableauEventHandler.prototype.SetupEventRecognizer = function (spec) {
        this.eventRecognizer = new EventRecognizer_1.EventRecognizer(spec);
        // If we have a press Drag, set up the callback modifications
        this.eventRecognizer.SetupPressDrag(spec);
    };
    TableauEventHandler.prototype.suppressHover = function () {
        if (this.config.IsUsingHover()) {
            this.eventRecognizer.suppressHover();
        }
    };
    TableauEventHandler.prototype.unsuppressHover = function () {
        if (this.config.IsUsingHover()) {
            this.eventRecognizer.unsuppressHover();
        }
    };
    TableauEventHandler.prototype.CancelHover = function () {
        if (this.config.IsUsingHover()) {
            this.eventRecognizer.CancelHover();
        }
    };
    TableauEventHandler.prototype.GetHandledEvents = function () {
        var handledEvents = new Array();
        var configMembers = this.config;
        for (var _i = 0, _a = Object.keys(configMembers); _i < _a.length; _i++) {
            var key = _a[_i];
            var curVal = TypeUtil_1.TypeUtil.GetField(configMembers, key);
            // TODO: - the original check is more stringent -- should we copy that?
            // configMembers[key].GetType() == typeof(Action<NormalizedEvent>))
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(curVal) && (typeof curVal === 'function')) {
                handledEvents.push(key);
            }
        }
        return handledEvents;
    };
    TableauEventHandler.prototype.Update = function (spec) {
        $.extend(this.config, spec);
        this.eventRecognizer.UpdateAllGestures(this.config);
        this.eventRecognizer.SetupPressDrag(this.config);
    };
    /**
     * Same as dispose. This only exists to make old javascript code happy :)
     */
    TableauEventHandler.prototype.destroy = function () {
        this.dispose();
    };
    // kill the listeners
    TableauEventHandler.prototype.dispose = function () {
        // #if DEBUG
        TableauEventHandler.RaiseTableauEventHandlerToBeDisposed(this);
        // #endif
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.subscriptionHandle)
            && !MiscUtil_1.MiscUtil.IsNullOrUndefined(this.subscriptionHandle.DomElement)
            && !MiscUtil_1.MiscUtil.IsNullOrUndefined(this.subscriptionHandle.EventHandler)) {
            for (var _i = 0, _a = NormalizedEvent_1.NormalizedEvent.AllHandledEvents; _i < _a.length; _i++) {
                var handledEvent = _a[_i];
                this.subscriptionHandle.DomElement.removeEventListener(handledEvent.toString(), this.subscriptionHandle.EventHandler);
            }
        }
        this.eventRecognizer.dispose();
    };
    TableauEventHandler.GetHandler = function (spec, evt) {
        return TypeUtil_1.TypeUtil.GetField(spec, evt);
    };
    TableauEventHandler.prototype.ConfigureDomElem = function (domElem) {
        // Add css for mobile to suppress various mobile feedback.  This originated with CL 119825.
        // TFS583075
        // If the dom element is an input, or defines user-select or -webkit-user-select then don't set it to none.
        // When setting it to none on text inputs it causes users to be unable to enter text on browsers using webkit.
        var userStyle = TypeUtil_1.TypeUtil.GetField(domElem.style, 'user-select');
        var webkitUserStyle = TypeUtil_1.TypeUtil.GetField(domElem.style, '-webkit-user-select');
        if (domElem.tagName.toLowerCase() !== 'input' &&
            (MiscUtil_1.MiscUtil.IsNullOrUndefined(userStyle) || userStyle === '') &&
            (MiscUtil_1.MiscUtil.IsNullOrUndefined(webkitUserStyle) || webkitUserStyle === '')) {
            TypeUtil_1.TypeUtil.SetField(domElem.style, '-webkit-user-select', 'none');
        }
        TypeUtil_1.TypeUtil.SetField(domElem.style, '-webkit-touch-callout', 'none');
        TypeUtil_1.TypeUtil.SetField(domElem.style, '-webkit-tap-highlight-color', 'transparent');
        // Add css to suppress default browser pan actions.  BUGZID 60153
        // NOTE-mroginski-2014-03-21: touch-action currently only works for IE10 and IE11, no way to suppress default
        // browser action on chrome yet.
        // NOTE-jrockwood-2014-12-09: BUGZID: 138891 - If we use touch-action: none it will disable scrolling and
        // panning and zooming. This is what we wanted since it can interfere with multi-select and can sometimes
        // behave in a quirky way. However, customers would rather have the pan/zoom and scrolling. We really need to
        // rework the way we handle touch in the browser, but that's a big work item and we can't do it now. Note that
        // IE behaves differently than the other browsers (are you surprised :) and we actually do need to have
        // touch-action set to none, but only for IE. As such, we're using the MS-specific CSS attribute. It's supported
        // in IE 10 and still works in IE 11, but it has been deprecated and may be removed in IE 12.
        TypeUtil_1.TypeUtil.SetField(domElem.style, '-ms-touch-action', 'none');
        // domElem.Style["touch-action"] = "none";                        // disable browser default actions in ie11 and forward
    };
    TableauEventHandler.prototype.MultiTouchWithDifferentTargetElement = function (e) {
        if (e.touches.length > 1 && !e.AllTouchesShareCurrentTarget()) {
            this.eventRecognizer.CancelAllGestures();
            return true;
        }
        return false;
    };
    // single entry point for all events. Preserve method name for testing.
    // [PreserveName]
    TableauEventHandler.prototype.handler = function (e) {
        // tslint:disable-next-line
        var optOut = e.target && !!closest(e.target, "[" + exports.OptOutAttributeName + "=\"true\"]");
        if (optOut) {
            return;
        }
        var isSecondaryMouseEvent = e.IsMouseEvent
            && browser_support_1.BrowserSupport.IsTouchEventSupported() // If touch events aren't supported then there can't be secondary mouse events
            && PointerEventDetector_1.PointerEventDetector.currentPointerType === 'touch';
        // Browser touch events generate mouse events. For example, touchstart generates mousedown, touchend
        // generates mouseup, and touchmove generates mousemove. In web, to support hybrid devices, we handle
        // touch and mouse events, ignoring secondary mouse events using PointerEventDetector or preventing the
        // browser from firing secondary mouse events using the legacy preventDefault method.
        // In mobile we don't listen to mouse events.
        if (!VizclientUtils_1.TsConfig.IsMobile()) {
            if (VizclientUtils_1.FeatureFlag.IsEventHandlingReworkEnabled() && isSecondaryMouseEvent) {
                // If we get here then we are handling a secondary mouse event that was triggered by the browser after a user touched
                // an element on a non-mobile device. We should have already handled the touch events so we return early to ignore
                // the secondary mouse event.
                return;
            }
            else if (!VizclientUtils_1.FeatureFlag.IsEventHandlingReworkEnabled() && e.IsTouchEvent) {
                if (DomUtil_1.DomUtil.CanCallPreventDefaultOnTouchEvent(e.target)) {
                    // If get here then we are handling a touch event on a non-mobile device so we call preventDefault (to prevent mouse events)
                    // then fall into the code below, which will handle the touch event.
                    e.preventDefault();
                }
                else {
                    return;
                }
            }
        }
        if (this.MultiTouchWithDifferentTargetElement(e)) {
            return;
        }
        this.eventRecognizer.HandleEvent(e);
    };
    TableauEventHandler.prototype.MakeConnections = function (domElem) {
        var _this = this;
        var handler = function (e) {
            var normalizedEvent = NormalizedEvent_1.NormalizedEvent.Create(e, _this.config.DomElement);
            _this.handler(normalizedEvent);
        };
        this.subscriptionHandle = new DomSubscriptionHandle_1.DomSubscriptionHandle(domElem, handler);
        for (var _i = 0, _a = NormalizedEvent_1.NormalizedEvent.AllHandledEvents; _i < _a.length; _i++) {
            var handledEvent = _a[_i];
            // IE11 currently does not support passive listeners: https://caniuse.com/#search=Passive%20event%20listeners
            if (browser_support_1.BrowserSupport.IsIE()) {
                domElem.addEventListener(handledEvent.toString(), handler, false);
            }
            else {
                domElem.addEventListener(handledEvent.toString(), handler, {
                    capture: false,
                    passive: false
                });
            }
        }
    };
    TableauEventHandler.add_TableauEventHandlerCreated = function (ev) {
        TableauEventHandler.TableauEventHandlerCreated.add(ev);
    };
    TableauEventHandler.remove_TableauEventHandlerCreated = function (ev) {
        TableauEventHandler.TableauEventHandlerCreated.remove(ev);
    };
    TableauEventHandler.add_TableauEventHandlerToBeDisposed = function (ev) {
        TableauEventHandler.TableauEventHandlerToBeDisposed.add(ev);
    };
    TableauEventHandler.remove_TableauEventHandlerToBeDisposed = function (ev) {
        TableauEventHandler.TableauEventHandlerToBeDisposed.remove(ev);
    };
    TableauEventHandler.RaiseTableauEventHandlerCreated = function (handler) {
        if (VizclientUtils_1.FeatureParam.DebugTools() && TableauEventHandler.TableauEventHandlerCreated !== null) {
            TableauEventHandler.TableauEventHandlerCreated.invoke(handler);
        }
    };
    TableauEventHandler.RaiseTableauEventHandlerToBeDisposed = function (handler) {
        if (VizclientUtils_1.FeatureParam.DebugTools() && TableauEventHandler.TableauEventHandlerToBeDisposed !== null) {
            TableauEventHandler.TableauEventHandlerToBeDisposed.invoke(handler);
        }
    };
    TableauEventHandler.TableauEventHandlerCreated = new Delegate_1.Delegate();
    TableauEventHandler.TableauEventHandlerToBeDisposed = new Delegate_1.Delegate();
    return TableauEventHandler;
}());
exports.TableauEventHandler = TableauEventHandler;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var _ = __webpack_require__(12);
var VizclientUtils_1 = __webpack_require__(1);
var MiscUtil_1 = __webpack_require__(0);
var Delegate = /** @class */ (function () {
    function Delegate() {
        this.delegate = [];
    }
    Delegate.prototype.invoke = function (arg1, arg2) {
        if (arg1 === void 0) { arg1 = undefined; }
        if (arg2 === void 0) { arg2 = undefined; }
        // Clone the delegates before calling them.
        // Delegates might remove themselves from the listener.
        var e = this.delegate.slice();
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(e)) {
            VizclientUtils_1.Logger.Debug('delegate type not supported');
            return;
        }
        e.forEach(function (callee) {
            callee(arg1, arg2);
        });
    };
    Delegate.prototype.add = function (callee) {
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(callee)) {
            VizclientUtils_1.Logger.Debug('delegate to add is not initialized (null)');
            return;
        }
        this.delegate.push(callee);
    };
    Delegate.prototype.remove = function (callee) {
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(callee)) {
            VizclientUtils_1.Logger.Debug('delegate to remove is not initialized (null)');
            return;
        }
        var index = this.find(callee);
        if (index >= 0) {
            this.delegate.splice(index, 1);
        }
        else {
            VizclientUtils_1.Logger.Debug('delegate to remove is not found');
        }
    };
    Delegate.prototype.find = function (callee) {
        var index = this.delegate.indexOf(callee);
        if (index < 0) {
            // Handle saltarelle generated delegates.
            // Saltarelle creates a delegates as a new object with
            // _target[0] = src and _target[1] = delegate function
            var o_1 = callee;
            if (o_1._targets !== undefined && o_1._targets.length === 2) {
                index = _.findIndex(this.delegate, function (saldel) {
                    return (saldel._targets !== undefined
                        && saldel._targets.length === 2
                        && saldel._targets[0] === o_1._targets[0]
                        && saldel._targets[1] === o_1._targets[1]);
                });
            }
        }
        return index;
    };
    return Delegate;
}());
exports.Delegate = Delegate;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil_1 = __webpack_require__(0);
// Same interface as CustomCursor.cs, but uses icons embedded inside the module
var EmbeddedCustomCursor = /** @class */ (function () {
    function EmbeddedCustomCursor(assetURL, fallback) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(assetURL)) {
            this.cssString = "url(" + assetURL + "), " + fallback;
        }
        else {
            this.cssString = fallback;
        }
    }
    Object.defineProperty(EmbeddedCustomCursor, "noOp", {
        get: function () {
            // tslint:disable-next-line:max-line-length no-bitwise
            return this.NoOp === undefined ? this.NoOp = new EmbeddedCustomCursor('data:text/plain;base64,AAACAAEAICAAAAQABACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAGb/////AAAAZv////8AAABm/////wAAAGb/////AAAAZv////8AAABm/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABm/////wAAAGb/////AAAAZv////8AAABm/////wAAAGb/////AAAAZv////8AAABmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAABmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZv////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZv////8AAAAAAAAAAP///wEAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBSdVVVX/DQ0N/A0NDfojIyPFBQUFJwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAZgAAAAD///8Z//////////////9l////GgAAAAAFBQUoEhIS9pOTk//t7e3/7u7u/7+/v/8CAgL/BQUFKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGb/////AAAAAP///1T/////T09P////////////AAAAACMjI8WSkpL////////////U1NT/AQEB/7+/v/8jIyPFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAGb///8Z/////3R0dP8AAAD/CgoK//////8AAAAADQ0N+e3t7f//////1NTU/wEBAf/U1NT/7e3t/wwMDPoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8G////AQAAAAAAAABm/////4mJiZf/////CQkJ/wAAAP98fHz//////wAAAGYTExP/7e3t/9TU1P8BAQH/1NTU///////t7e3/DAwM+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////91////Af////82NjZ1/////4CAgP8AAAD/BgYG///////AwMC7/////x8fH9y+vr7/AQEB/9TU1P///////////5GRkf8jIyPFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////////9w////Af///03/////DAwM/wAAAP93d3f//////////xoAAAAABQUFJwICAv+/v7//7e3t/+3t7f+Tk5P/EhIS9gUFBScAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////Li4u//////////9w/////4mJif8AAAD/BQUF//////////+YAAAAAAAAAAAAAAAABQUFJSMjI8UNDQ35DQ0N+SMjI8UFBQUlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/IiIi////////////ExMT/wAAAP9wcHD//////////yIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/2JiYv8AAAD/AAAA//////////+kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD///////////////////////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0JCQv/////+////eQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9GRkb//////v///3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/QkJC//////7///92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/wAAAP8AAAD/AAAA/0NDQ//////+////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/wAAAP9FRUX//////v///3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/RkZG//////7///92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/0ZGRv//////////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP9HR0f//////////3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////SEhI//////////92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////////////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA///////////////////////////9VV///qq///3/3//+/4f//c8D//7CAf/9ggH//gIB/+0AAf/nBwP/4geH/+AP///gD///4AH//+AD///gB///4A///+Af///gP///4H///+D////h////4////+f///////////////////8=', 'auto') : this.NoOp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbeddedCustomCursor, "delete", {
        get: function () {
            // tslint:disable-next-line:max-line-length no-bitwise
            return this.Delete === undefined ? this.Delete = new EmbeddedCustomCursor('data:text/plain;base64,AAACAAEAICAAAAQABACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP//////AAAA//////8AAAD//////wAAAP//////AAAA//////8AAAD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////wAAAP//////AAAA//////8AAAD//////wAAAP//////AAAA//////8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////8AAAAAAAAAAP///wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAAD///8Z//////////////9l////GgAAAAA1U7P/NVOz/zVTs0//////AAAAADVTs081U7P/NVOz/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////AAAAAP///1T/////T09P////////////AAAAADVTs1o1U7P/NVOz/zVTs081U7NNNVOz/zVTs/81U7NaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP////8Z/////3R0dP8AAAD/CgoK//////8AAAAAAAAAADVTs1o1U7P/NlOz/zVTs/41U7P/NVOzWgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8G////AQAAAAAAAAD//////1FRUf//////CQkJ/wAAAP98fHz//////wAAAP//////AAAAPx0tYv81U7P/NVOz/zVTs4sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////91////Af////8ZGRn//////4CAgP8AAAD/BgYG//////+NjY3//////wAAAP/Fzun/NVOy/zVTs/81U7P/NVOz/jVTs0gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////////9w////Af///03/////DAwM/wAAAP93d3f//////////xoAAAAANVOzRDVTs/41U7P/NVOzXTVTs1s1U7P/NVOz/jVTs0QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////Li4u//////////9w/////4mJif8AAAD/BQUF//////////+YAAAAAAAAAAA1U7P+NVOz/zVTs10AAAAAAAAAADVTs101U7P/NVOz/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/IiIi////////////ExMT/wAAAP9wcHD//////////yIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/2JiYv8AAAD/AAAA//////////+kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD///////////////////////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0JCQv/////+////eQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9GRkb//////v///3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/QkJC//////7///92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/wAAAP8AAAD/AAAA/0NDQ//////+////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/wAAAP9FRUX//////v///3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/RkZG//////7///92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/0ZGRv//////////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP9HR0f//////////3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////SEhI//////////92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////////////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA///////////////////////////8AB///AAf//z/n//8/5///M5Z//zDM//8g4f//ACH/+wAB//nBzP/4gZ5/+AP///gD///4AH//+AD///gB///4A///+Af///gP///4H///+D////h////4////+f///////////////////8=', 'auto') : this.Delete;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbeddedCustomCursor, "copy", {
        get: function () {
            // tslint:disable-next-line:max-line-length no-bitwise
            return this.Copy === undefined ? this.Copy = new EmbeddedCustomCursor('data:text/plain;base64,AAACAAEAICAAAAMAAwCoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP//////AAAA//////8AAAD//////wAAAP//////AAAA//////8AAAD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////wAAAP//////AAAA//////8AAAD//////wAAAP//////AAAA//////8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////8AAAAAAAAAAP///wEAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAAD///8Z//////////////9l////GgAAAAAAAAD//////////////////////////////////////wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////AAAAAP///1T/////T09P////////////AAAAAAAAAP////////////////8AAAD/////////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP////8Z/////3R0dP8AAAD/CgoK//////8AAAAAAAAA/////////////////wAAAP////////////////8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8G////AQAAAAAAAAD//////1FRUf//////CQkJ/wAAAP98fHz//////wAAAH8AAAD//////wAAAP8AAAD/AAAA/wAAAP8AAAD//////wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////91////Af////8ZGRn//////4CAgP8AAAD/BgYG//////+NjY3//////wAAAP////////////////8AAAD/////////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////////////9w////Af///03/////DAwM/wAAAP93d3f//////////xoAAAAAAAAA/////////////////wAAAP////////////////8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////Li4u//////////9w/////4mJif8AAAD/BQUF//////////+YAAAAAAAAAAAAAAD//////////////////////////////////////wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/IiIi////////////ExMT/wAAAP9wcHD//////////yIAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/2JiYv8AAAD/AAAA//////////+kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD///////////////////////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0JCQv/////+////eQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9GRkb//////v///3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/QkJC//////7///92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/wAAAP8AAAD/AAAA/0NDQ//////+////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP8AAAD/AAAA/wAAAP9FRUX//////v///3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAA/wAAAP8AAAD/RkZG//////7///92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAD/AAAA/0ZGRv//////////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAP9HR0f//////////3b///8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////SEhI//////////92////BgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////////////dv///wYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA///////////////////////////8AB///AAf//z/3//8/gD//M4A//zCAP/8ggD//AIA/+wAAP/nBgD/4gYA/+AOAP/gD///4AH//+AD///gB///4A///+Af///gP///4H///+D////h////4////+f///////////////////8=', 'auto') : this.Copy;
        },
        enumerable: true,
        configurable: true
    });
    EmbeddedCustomCursor.prototype.setCursor = function (element) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(element)) {
            element.css('cursor', this.cssString);
        }
    };
    EmbeddedCustomCursor.copyFromElement = function (element) {
        var cursor = !MiscUtil_1.MiscUtil.IsNullOrUndefined(element) ? element.css('cursor') : '';
        return new EmbeddedCustomCursor(null, cursor);
    };
    return EmbeddedCustomCursor;
}());
exports.EmbeddedCustomCursor = EmbeddedCustomCursor;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var VizclientUtils_1 = __webpack_require__(1);
var FeatureFlagUtils = /** @class */ (function () {
    function FeatureFlagUtils() {
    }
    // Pass the EventUtilsEventHandlingRework feature flag to the module here
    FeatureFlagUtils.SetFeatureFlagIsEventHandlingReworkEnabled = function (shim) {
        VizclientUtils_1.FeatureFlag.IsEventHandlingReworkEnabled = shim;
    };
    // Pass the feature param to the module here
    FeatureFlagUtils.SetFeatureParamDebugTools = function (shim) {
        VizclientUtils_1.FeatureParam.DebugTools = shim;
    };
    // Pass the tsconfig to the module here
    FeatureFlagUtils.SetTsConfigIsMobile = function (shim) {
        VizclientUtils_1.TsConfig.IsMobile = shim;
    };
    // Pass the bootstraputil to the module here
    FeatureFlagUtils.SetBootStrapUtilIsEmbedded = function (shim) {
        VizclientUtils_1.BootstrapUtility.IsEmbedded = shim;
    };
    FeatureFlagUtils.SetLoggerDebug = function (shim) {
        VizclientUtils_1.Logger.Debug = shim;
    };
    FeatureFlagUtils.SetAllShimsToFallback = function () {
        var fallbackShim = function () { return false; };
        FeatureFlagUtils.SetFeatureFlagIsEventHandlingReworkEnabled(fallbackShim);
        FeatureFlagUtils.SetFeatureParamDebugTools(fallbackShim);
        FeatureFlagUtils.SetTsConfigIsMobile(fallbackShim);
        FeatureFlagUtils.SetBootStrapUtilIsEmbedded(fallbackShim);
    };
    return FeatureFlagUtils;
}());
exports.FeatureFlagUtils = FeatureFlagUtils;
var NormalizedEvent_1 = __webpack_require__(5);
exports.NormalizedEvent = NormalizedEvent_1.NormalizedEvent;
var MouseEventUtil_1 = __webpack_require__(15);
exports.MouseEventUtil = MouseEventUtil_1.MouseEventUtil;
var EventHandleSpec_1 = __webpack_require__(7);
exports.EventHandleSpec = EventHandleSpec_1.EventHandleSpec;
var EventForwarder_1 = __webpack_require__(34);
exports.EventForwarder = EventForwarder_1.EventForwarder;
var TableauEventHandler_1 = __webpack_require__(8);
exports.TableauEventHandler = TableauEventHandler_1.TableauEventHandler;
var TableauEventHandlerForReact_1 = __webpack_require__(20);
exports.TableauEventHandlerForReact = TableauEventHandlerForReact_1.TableauEventHandlerForReact;
var Gesture_1 = __webpack_require__(6);
exports.Gesture = Gesture_1.Gesture;
var Drag_1 = __webpack_require__(18);
exports.Drag = Drag_1.Drag;
var GlobalUIEvents_1 = __webpack_require__(14);
exports.GlobalUIEvents = GlobalUIEvents_1.GlobalUIEvents;
var Hover_1 = __webpack_require__(19);
exports.Hover = Hover_1.Hover;
var MiscUtil_1 = __webpack_require__(0);
exports.MiscUtil = MiscUtil_1.MiscUtil;
var ZoomScaleUtil_1 = __webpack_require__(17);
exports.ZoomScaleUtil = ZoomScaleUtil_1.ZoomScaleUtil;
var DragDropManager_1 = __webpack_require__(21);
exports.DragDropManager = DragDropManager_1.DragDropManager;
var SimpleAvatar_1 = __webpack_require__(40);
exports.SimpleAvatar = SimpleAvatar_1.SimpleAvatar;
var DragInstance_1 = __webpack_require__(41);
exports.DragInstance = DragInstance_1.DragInstance;
var DelegateDropTarget_1 = __webpack_require__(42);
exports.DelegateDropTarget = DelegateDropTarget_1.DelegateDropTarget;
var DropResult_1 = __webpack_require__(22);
exports.DropResult = DropResult_1.DropResult;
var EmbeddedCustomCursor_1 = __webpack_require__(10);
exports.EmbeddedCustomCursor = EmbeddedCustomCursor_1.EmbeddedCustomCursor;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.9.0
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.0';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because were not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functions
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return obj != null && hasOwnProperty.call(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that objects
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23), __webpack_require__(24)(module)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var MiscUtil_1 = __webpack_require__(0);
var DomUtil = /** @class */ (function () {
    function DomUtil() {
    }
    DomUtil.CanCallPreventDefaultOnTouchEvent = function (domElement) {
        // If target is a checkbox, return false because checkboxes do not record the check/uncheck on
        // touchend if PreventDefault() is called. So when the target of an input event is a checkbox,
        // we must let mouse events fire in order for the check/uncheck to take effect.
        // Note: other inputs (input/textarea/select) seem unaffected by PreventDefault() being called.
        // Also, oddly, with mouse events, preventDefault() does not keep a checkbox from getting checked.
        if (DomUtil.IsCheckboxElement(domElement)) {
            return false;
        }
        // If target is a focusable text element, return false because we need to avoid calling PreventDefault()
        // in order to let them have focus when we click or tap on them.
        if (DomUtil.IsFocusableTextElement(domElement)) {
            return false;
        }
        // If we get to here, ok to call prevent default.
        return true;
    };
    /**
     * Returns true if domElement is a checkbox, else false.
     * @param {HTMLElement} domElement - the dom element
     * @returns whether or not we're dealing with a checkbawks
     */
    DomUtil.IsCheckboxElement = function (domElement) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(domElement) && !MiscUtil_1.MiscUtil.IsNullOrUndefined(domElement.tagName)) {
            var targetTagName = domElement.tagName.toLowerCase();
            var typeAttributeValue = $(domElement).attr('type');
            if (targetTagName === 'input' && typeAttributeValue === 'checkbox') {
                return true;
            }
        }
        return false;
    };
    /**
     * Returns true if domElement is a focusable input element
     *  @param {HTMLElement} domElement - the dom element
     *  @returns true or false
     *  NOTE: DOM ELEMENT USED TO BE XMLELEMENT IN C#
     */
    DomUtil.IsFocusableTextElement = function (domElement) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(domElement) && !MiscUtil_1.MiscUtil.IsNullOrUndefined(domElement.tagName)) {
            var targetTagName = domElement.tagName.toLowerCase();
            if ((targetTagName === 'textarea') || (targetTagName === 'input') || (targetTagName === 'select')) {
                return true;
            }
        }
        return false;
    };
    DomUtil.IsAncestorOf = function (ancestor, child) {
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(ancestor) || MiscUtil_1.MiscUtil.IsNullOrUndefined(child)) {
            return false;
        }
        return $(child).parents().index(ancestor) >= 0;
    };
    return DomUtil;
}());
exports.DomUtil = DomUtil;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Delegate_1 = __webpack_require__(9);
var MiscUtil_1 = __webpack_require__(0);
/// <summary>
/// Global dispatcher of UI events such as FirstTouch, Press, Tap, LastTouch, including programmatically fired ones
/// like DismissTemporaryElements.
/// This is only a dispatcher - the event will not be canceled by this class
/// </summary>
var GlobalUIEvents = /** @class */ (function () {
    function GlobalUIEvents() {
    }
    GlobalUIEvents.add_FirstTouch = function (ev) {
        this.FirstTouch.add(ev);
    };
    GlobalUIEvents.remove_FirstTouch = function (ev) {
        this.FirstTouch.remove(ev);
    };
    GlobalUIEvents.add_Press = function (ev) {
        this.Press.add(ev);
    };
    GlobalUIEvents.remove_Press = function (ev) {
        this.Press.remove(ev);
    };
    GlobalUIEvents.add_Tap = function (ev) {
        this.Tap.add(ev);
    };
    GlobalUIEvents.remove_Tap = function (ev) {
        this.Tap.remove(ev);
    };
    GlobalUIEvents.add_LastTouch = function (ev) {
        this.LastTouch.add(ev);
    };
    GlobalUIEvents.remove_LastTouch = function (ev) {
        this.LastTouch.remove(ev);
    };
    GlobalUIEvents.add_RightClick = function (ev) {
        this.RightClick.add(ev);
    };
    GlobalUIEvents.remove_RightClick = function (ev) {
        this.RightClick.remove(ev);
    };
    GlobalUIEvents.add_DragEnd = function (ev) {
        this.DragEnd.add(ev);
    };
    GlobalUIEvents.remove_DragEnd = function (ev) {
        this.DragEnd.remove(ev);
    };
    GlobalUIEvents.add_DismissTemporaryElements = function (ev) {
        this.DismissTemporaryElements.add(ev);
    };
    GlobalUIEvents.remove_DismissTemporaryElements = function (ev) {
        this.DismissTemporaryElements.remove(ev);
    };
    //// ===========================================================================================================
    //// Methods
    //// ===========================================================================================================
    /// <summary>
    /// Fires <c>FirstTouch</c> event. As a side-effect, this also fires <c>DismissTemporaryElements</c> events
    /// </summary>
    GlobalUIEvents.FireFirstTouch = function (e, cancelCallback) {
        GlobalUIEvents.FireEvent(GlobalUIEvents.FirstTouch, e, cancelCallback);
    };
    /// <summary>
    /// Fires <c>Press</c> event
    /// </summary>
    GlobalUIEvents.FirePress = function (e, cancelCallback) {
        GlobalUIEvents.FireEvent(GlobalUIEvents.Press, e, cancelCallback);
    };
    /// <summary>
    /// Fires <c>Tap</c> event
    /// </summary>
    GlobalUIEvents.FireTap = function (e, cancelCallback) {
        GlobalUIEvents.FireEvent(GlobalUIEvents.Tap, e, cancelCallback);
    };
    /// <summary>
    /// Fires <c>LastTouch</c> event
    /// </summary>
    GlobalUIEvents.FireLastTouch = function (e, cancelCallback) {
        GlobalUIEvents.FireEvent(GlobalUIEvents.LastTouch, e, cancelCallback);
    };
    /// <summary>
    /// Fires <c>RightClick</c> event
    /// </summary>
    GlobalUIEvents.FireRightClick = function (e, cancelCallback) {
        GlobalUIEvents.FireEvent(GlobalUIEvents.RightClick, e, cancelCallback);
    };
    /// <summary>
    /// Fires <c>DragEnd</c> event
    /// </summary>
    GlobalUIEvents.FireDragEnd = function (e, cancelCallback) {
        GlobalUIEvents.FireEvent(GlobalUIEvents.DragEnd, e, cancelCallback);
    };
    /// <summary>
    /// Fires <c>DismissTemporaryElements</c> event
    /// </summary>
    GlobalUIEvents.FireDismissTemporaryElements = function () {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(GlobalUIEvents.DismissTemporaryElements)) {
            GlobalUIEvents.DismissTemporaryElements.invoke(null);
        }
    };
    /// <summary>
    /// Helper function to fire event.
    /// </summary>
    GlobalUIEvents.FireEvent = function (ev, eventArgument, cancelCallback) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(ev)) {
            ev.invoke(eventArgument, cancelCallback);
        }
    };
    //// ===========================================================================================================
    //// Events
    //// ===========================================================================================================
    /// <summary>
    /// The Action is a callback you can use to cancel the event.  Pass true to preventDefault on the event when you
    /// invoke the callback.  Note that the callback must be synchronous.
    /// </summary>
    GlobalUIEvents.FirstTouch = new Delegate_1.Delegate();
    GlobalUIEvents.Press = new Delegate_1.Delegate();
    GlobalUIEvents.Tap = new Delegate_1.Delegate();
    GlobalUIEvents.LastTouch = new Delegate_1.Delegate();
    GlobalUIEvents.RightClick = new Delegate_1.Delegate();
    GlobalUIEvents.DragEnd = new Delegate_1.Delegate();
    /// <summary>
    /// Fired when some UI element has programmatically taken focus (in a conceptual sense, not necessarily becoming
    /// the active element). For example, this could be fired when a dialog appears via the JSAPI.
    /// Any UI element that is temporary and normally dismisses when the user touches outside of it (e.g. a tooltip)
    /// should usually listen for this event in addition to <see cref="FirstTouch"/>.
    /// </summary>
    GlobalUIEvents.DismissTemporaryElements = new Delegate_1.Delegate();
    return GlobalUIEvents;
}());
exports.GlobalUIEvents = GlobalUIEvents;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil_1 = __webpack_require__(0);
var TypeUtil_1 = __webpack_require__(2);
/**
* Contains utility methods for mouse events
*/
var MouseEventUtil = /** @class */ (function () {
    function MouseEventUtil() {
    }
    // init mappings
    MouseEventUtil.InitMouseButtonMappings = function () {
        if (!MouseEventUtil.areMappingsInstantiated) {
            MouseEventUtil.mouseButtonMappingsIE[1] = "left" /* Left */;
            MouseEventUtil.mouseButtonMappingsIE[4] = "middle" /* Middle */;
            MouseEventUtil.mouseButtonMappingsIE[2] = "right" /* Right */;
            MouseEventUtil.mouseWhichMappings[1] = "left" /* Left */;
            MouseEventUtil.mouseWhichMappings[2] = "middle" /* Middle */;
            MouseEventUtil.mouseWhichMappings[3] = "right" /* Right */;
            MouseEventUtil.areMappingsInstantiated = true;
        }
    };
    /**
    * Interpret which mouse button was pressed from the raw event object.
    * Browsers have different specs mouse button representations. The basic
    * strategy that's used here is to isolate IE9 from the others.
    *
    * While most browsers support event.button, IE9 values means different
    * from the rest of the browser. Where left, mid, right usually maps to
    * 0, 1, 2, IE maps them to 1, 4, 2.
    *
    * This is where we'll use feature detection to separate IE9. We'll try
    * look for the event.which property which also tells us which button
    * was pressed (the values don't match with event.button though). Since
    * IE9 doesn't support this, we can easily special case event.button
    * only for IE9.
    *
    * Check:
    * http://mytableau/display/DevServFront/Mouse+Events+Madness
    * for related mouse event differences between browsers.
    *
    * @returns Returns MouseButtonEnum
    */
    MouseEventUtil.GetMouseButtonEnum = function (e) {
        // lazy instantiation of mappings
        MouseEventUtil.InitMouseButtonMappings();
        // default output
        var output = "none" /* None */;
        // event.which did not get defined in the metadata, we'll
        // have to extract it manually..
        var whichObj = TypeUtil_1.TypeUtil.GetField(e, 'which');
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(whichObj)) {
            // for chrome, firefox, and safari
            var which = whichObj;
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(MouseEventUtil.mouseWhichMappings[which])) {
                output = MouseEventUtil.mouseWhichMappings[which];
            }
        }
        else {
            var field = TypeUtil_1.TypeUtil.GetField(e, 'button');
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(field)) {
                // for IE9
                var button = field;
                if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(MouseEventUtil.mouseButtonMappingsIE[button])) {
                    output = MouseEventUtil.mouseButtonMappingsIE[button];
                }
            }
        }
        return output;
    };
    MouseEventUtil.areMappingsInstantiated = false;
    // button mapping for IE 9 - lazily instantiated
    MouseEventUtil.mouseButtonMappingsIE = {};
    // doesn't apply for IE 9 - lazily instantiated
    MouseEventUtil.mouseWhichMappings = {};
    return MouseEventUtil;
}());
exports.MouseEventUtil = MouseEventUtil;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var browser_support_1 = __webpack_require__(4);
var Discrete_1 = __webpack_require__(25);
var DomUtil_1 = __webpack_require__(13);
var Drag_1 = __webpack_require__(18);
var EventHandleSpec_1 = __webpack_require__(7);
var Hover_1 = __webpack_require__(19);
var VizclientUtils_1 = __webpack_require__(1);
var MiscUtil_1 = __webpack_require__(0);
var MouseEventUtil_1 = __webpack_require__(15);
var NormalizedEvent_1 = __webpack_require__(5);
var Pinch_1 = __webpack_require__(31);
var TableauEventHandler_1 = __webpack_require__(8);
/**
* The responsibility of this class is to inspect browser events and forward them to the gesture instances (that this class manages).
*/
var EventRecognizer = /** @class */ (function () {
    function EventRecognizer(config) {
        // TODO: Move the mouse behavior handling into a separate class.
        // All the variables that represent mouse state should then move to this new class.
        this.mousedown = false;
        this.handlingContextMenu = false;
        this.usingHover = config.IsUsingHover();
        this.domElement = config.DomElement;
        // these Recognizers are used by all
        this.drag = new Drag_1.Drag(config, this);
        this.discrete = new Discrete_1.Discrete(config);
        this.pinch = new Pinch_1.Pinch(config);
        if (this.usingHover) {
            this.hover = new Hover_1.Hover(config);
        }
    }
    Object.defineProperty(EventRecognizer, "CurrentGlobalMouseButton", {
        /**
         * Gets or sets globally tracked mouse button state, this is useful for knowing when there was a left mouse button
         *    up somewhere else.
         * Note: The property name implies and the implementation is capable of tracking left/middle/right buttons.
         * However, the way the mouseup (startEvent) is implemented below only the left mouse button is tracked. This is
         * because it seems the intent here is to ignore non-left-mouse clicks.
        */
        get: function () {
            return EventRecognizer.globalMouseButton;
        },
        set: function (value) {
            if (EventRecognizer.globalMouseButton !== value) {
                EventRecognizer.globalMouseButton = value;
                VizclientUtils_1.Logger.Debug('GlobalMouseButton=' + EventRecognizer.globalMouseButton);
            }
        },
        enumerable: true,
        configurable: true
    });
    EventRecognizer.prototype.suppressHover = function () {
        this.hover.suppressHover();
    };
    EventRecognizer.prototype.unsuppressHover = function () {
        this.hover.unsuppressHover();
    };
    EventRecognizer.prototype.CancelHover = function () {
        this.hover.Cancel();
    };
    EventRecognizer.prototype.HandleEvent = function (e) {
        // if there was a left mouse down in this handler but the mouse was moved and the mouse
        // up wasn't recorded our local mousedown state will be incorrect. We need to know
        // if that mouseup occurred so we know whether to enable hovering.
        if (this.mousedown
            && (EventRecognizer.CurrentGlobalMouseButton !== "left" /* Left */
                && EventRecognizer.CurrentGlobalMouseButton !== "right" /* Right */)) {
            this.mousedown = false;
        }
        if (e.IsScrollEvent) {
            // noop
        }
        else if (e.IsOutEvent) {
            if (this.usingHover) {
                this.hover.Out(e);
            }
        }
        else if (e.IsStartEvent) {
            this.HandleStartEvent(e);
        }
        else if (e.IsMoveEvent) {
            this.HandleMoveEvent(e);
        }
        else {
            this.HandleEndCancelEvent(e);
        }
    };
    EventRecognizer.prototype.HandleStartEvent = function (e) {
        this.handlingContextMenu = false;
        this.lastMouseButtonPressed = MouseEventUtil_1.MouseEventUtil.GetMouseButtonEnum(e.originalEvent);
        if (e.IsMouseEvent) {
            this.mousedown = true;
            // globally maintain the state of the mouse buttons
            // when in mouse mode startEvent corresponds to a mousedown
            EventRecognizer.CurrentGlobalMouseButton = this.lastMouseButtonPressed;
        }
        // Though no hover with touch, a touch start event should have same effect as a mouse start event
        this.HandleStart(e);
    };
    EventRecognizer.prototype.HandleMoveEvent = function (e) {
        if (this.usingHover) {
            this.hover.Move(e);
        }
        if (e.IsMouseEvent) {
            // bugzid: 39261
            if (!this.mousedown) {
                return;
            }
        }
        // order shouldn't matter
        this.discrete.Move(e);
        this.drag.Move(e);
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.pinch)) {
            this.pinch.Move(e);
        }
    };
    EventRecognizer.prototype.HandleEndCancelEvent = function (e) {
        // globally maintain the state of the mouse buttons
        // when in mouse mode endEvent corresponds to a mouseup
        EventRecognizer.CurrentGlobalMouseButton = "none" /* None */;
        // Though no hover with touch, a touch end event should have same effect as a mouse end event
        if (this.usingHover) {
            this.hover.End(e);
        }
        // order matters
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.pinch)) {
            this.pinch.End(e);
        }
        this.drag.End(e);
        // track whether we are handling a right-click event sequence
        if (e.IsMouseEvent) {
            this.mousedown = false;
            // Special handling for contextmenu (right-click and/or ctrl+left-click on Mac) event:
            // on Mac we get contextmenu before the mouseup event, so we ignore the trailing mouseup event
            if (e.IsRightClickEvent || this.lastMouseButtonPressed === "right" /* Right */) {
                this.handlingContextMenu = true;
            }
            // on Windows we get mouseup event before the contextmenu event, so we ignore mouse events until we get contextmenu event.
            if ((browser_support_1.BrowserSupport.IsMac() && this.handlingContextMenu &&
                e.type === "mouseup" /* MouseUp */) || (this.handlingContextMenu && !e.IsRightClickEvent)) {
                return;
            }
        }
        this.discrete.End(e);
    };
    EventRecognizer.prototype.CancelAllGestures = function () {
        // cancel all current gestures
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.drag)) {
            this.drag.Cancel();
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.discrete)) {
            this.discrete.Cancel();
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.pinch)) {
            this.pinch.Cancel();
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.hover)) {
            this.hover.Cancel();
        }
    };
    EventRecognizer.prototype.UpdateAllGestures = function (newConfig) {
        // cancel all current gestures
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.drag)) {
            this.drag.Update(newConfig);
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.discrete)) {
            this.discrete.Update(newConfig);
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.pinch)) {
            this.pinch.Update(newConfig);
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.hover)) {
            this.hover.Update(newConfig);
        }
    };
    // press drag is a modal gesture. Once press happens, then the callbacks to drag become
    // pressDrag callbacks, and pinch become doublePressDrag callbacks. Callbacks revert to
    // originals when the gesture ends
    EventRecognizer.prototype.SetupPressDrag = function (oldConfig) {
        var _this = this;
        var usingPressDrag = oldConfig.UsingPressDrag();
        if (!usingPressDrag) {
            return;
        }
        var press = function (e) {
            if (oldConfig.IsHandling("press" /* Press */)) {
                var callback = TableauEventHandler_1.TableauEventHandler.GetHandler(oldConfig, "press" /* Press */);
                callback(e);
            }
            var newConfig = new EventHandleSpec_1.EventHandleSpec();
            newConfig.SetHandler("dragStart" /* DragStart */, 
            // tslint:disable-next-line:align
            TableauEventHandler_1.TableauEventHandler.GetHandler(oldConfig, "pressDragStart" /* PressDragStart */));
            newConfig.SetHandler("dragMove" /* DragMove */, 
            // tslint:disable-next-line:align
            TableauEventHandler_1.TableauEventHandler.GetHandler(oldConfig, "pressDragMove" /* PressDragMove */));
            newConfig.SetHandler("dragEnd" /* DragEnd */, 
            // tslint:disable-next-line:align
            TableauEventHandler_1.TableauEventHandler.GetHandler(oldConfig, "pressDragEnd" /* PressDragEnd */));
            newConfig.SetHandler("pinchStart" /* PinchStart */, 
            // tslint:disable-next-line:align
            TableauEventHandler_1.TableauEventHandler.GetHandler(oldConfig, "doublePressDragStart" /* DoublePressDragStart */));
            newConfig.SetHandler("pinchMove" /* PinchMove */, 
            // tslint:disable-next-line:align
            TableauEventHandler_1.TableauEventHandler.GetHandler(oldConfig, "doublePressDragMove" /* DoublePressDragMove */));
            newConfig.SetHandler("pinchEnd" /* PinchEnd */, 
            // tslint:disable-next-line:align
            TableauEventHandler_1.TableauEventHandler.GetHandler(oldConfig, "doublePressDragEnd" /* DoublePressDragEnd */));
            _this.drag.Update(newConfig);
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(_this.pinch)) {
                _this.pinch.Update(newConfig);
            }
        };
        var lastTouch = function (e) {
            if (oldConfig.IsHandling("lastTouch" /* LastTouch */)) {
                var callback = TableauEventHandler_1.TableauEventHandler.GetHandler(oldConfig, "lastTouch" /* LastTouch */);
                callback(e);
            }
            _this.drag.Update(oldConfig);
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(_this.pinch)) {
                _this.pinch.Update(oldConfig);
            }
        };
        var pressConfig = new EventHandleSpec_1.EventHandleSpec();
        pressConfig.SetHandler("press" /* Press */, press);
        pressConfig.SetHandler("lastTouch" /* LastTouch */, lastTouch);
        this.discrete.Update(pressConfig);
    };
    EventRecognizer.prototype.HandleStart = function (e) {
        if (this.usingHover) {
            this.hover.Start(e);
        }
        // order matters
        this.discrete.Start(e);
        this.drag.Start(e);
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.pinch)) {
            this.pinch.Start(e);
        }
    };
    EventRecognizer.prototype.dispose = function () {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.discrete)) {
            this.discrete.dispose();
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.drag)) {
            this.drag.dispose();
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.hover)) {
            this.hover.dispose();
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.pinch)) {
            this.pinch.dispose();
        }
    };
    /**
     * Called when the mouse is moved while mouse events are being captured
     */
    EventRecognizer.prototype.HandleCapturedMouseMove = function (e) {
        if (this.IsCapturedEventOutsideOfTarget(e)) {
            var normalizedEvent = NormalizedEvent_1.NormalizedEvent.Create(e, this.domElement);
            this.HandleMoveEvent(normalizedEvent);
        }
    };
    /**
     * Called when mouseup occurs or on mouseout if we're in an iFrame and don't support setCapture
     */
    EventRecognizer.prototype.HandleCapturedMouseComplete = function (e) {
        // Always handle captured mouseout events as end events, regardless of whether the event will naturally bubble up
        // to the target. We don't normally handle mouseout events as end events, however when MouseCapture sends them it
        // indicates that the gesture needs to be ended prematurely because we don't expect to receive any further events
        // due to the gesture leaving frame context.
        var isMouseOut = e.type === "mouseout" /* MouseOut */;
        if (this.IsCapturedEventOutsideOfTarget(e) || isMouseOut) {
            var normalizedEvent = NormalizedEvent_1.NormalizedEvent.Create(e, this.domElement);
            this.HandleEndCancelEvent(normalizedEvent);
        }
    };
    /**
     * Returns true if the event will not naturally bubble to the capturing element via normal browser event propagation.
     */
    EventRecognizer.prototype.IsCapturedEventOutsideOfTarget = function (e) {
        return this.domElement !== e.target
            && !DomUtil_1.DomUtil.IsAncestorOf(this.domElement, e.target);
    };
    EventRecognizer.globalMouseButton = "none" /* None */; // the current state of the mouse buttons
    return EventRecognizer;
}());
exports.EventRecognizer = EventRecognizer;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil_1 = __webpack_require__(0);
var NonApiCommand_1 = __webpack_require__(28);
var VizclientUtils_1 = __webpack_require__(1);
var ZoomScaleUtil = /** @class */ (function () {
    function ZoomScaleUtil() {
    }
    ZoomScaleUtil.initialize = function () {
        window.addEventListener('message', function (evt) { return ZoomScaleUtil.OnMessage(window, evt); }, false);
    };
    Object.defineProperty(ZoomScaleUtil, "ZoomScaleForLocalWindow", {
        /**
        * Returns the zoom scale factor for the local window.
        * This will be a value ranging from (0, inf), where a value larger than 1 means you are zoomed in.
        * Note that the scale factor may be slightly inaccurate for desktop browsers, so use at your own peril.
        */
        get: function () {
            // TFSID: 567082 - Use the document's clientWidth instead of screen.width for
            // the unzoomed width, because when we are in an iframe embedded in another
            // page we want our unzoomed width to reflect the size of the iframe.
            var width = document.documentElement.clientWidth;
            var zoomedWidth = window.innerWidth;
            if (!VizclientUtils_1.TsConfig.IsMobile()) {
                zoomedWidth -= 17;
            }
            return width / zoomedWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZoomScaleUtil, "IsScaleFactorCommunicationAvailable", {
        get: function () {
            return !MiscUtil_1.MiscUtil.IsNullOrUndefined(ZoomScaleUtil.outerMessageSource);
        },
        enumerable: true,
        configurable: true
    });
    ZoomScaleUtil.OnMessage = function (target, e) {
        var messageEvent = e;
        // TFS 389713: Make sure our type is correct before parsing
        if (typeof messageEvent.data !== 'string') {
            return;
        }
        var command = NonApiCommand_1.NonApiCommand.Parse(messageEvent.data.toString());
        if (command.Name === NonApiCommand_1.NonApiCommandName.ScaleFactorResponse) {
            var id = command.Parameters[0];
            // Save the scale factor so that it can be retrieved synchronously later
            ZoomScaleUtil.lastScaleFactor = Number(command.Parameters[1]);
            var scrollX_1 = Number(command.Parameters[2]);
            var scrollY_1 = Number(command.Parameters[3]);
            var cb = ZoomScaleUtil.PendingCallbacks[id];
            delete ZoomScaleUtil.PendingCallbacks.id;
            ZoomScaleUtil.outerMessageSource = messageEvent.source;
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(cb)) {
                cb(ZoomScaleUtil.lastScaleFactor, scrollX_1, scrollY_1);
            }
        }
    };
    ZoomScaleUtil.RequestScaleFactor = function (callback) {
        if (callback === void 0) { callback = null; }
        var id = (++ZoomScaleUtil.nextId).toString();
        ZoomScaleUtil.PendingCallbacks[id] = callback;
        var command = new NonApiCommand_1.NonApiCommand(NonApiCommand_1.NonApiCommandName.ScaleFactorRequest, [id]);
        ZoomScaleUtil.outerMessageSource.postMessage(command.Serialize(), '*');
    };
    /**
    * Invokes the callback with the current browser viewport scale factor.
    * Consumers that cannot handle asynchronous behavior should use <see cref="GetScaleSync"/> instead.
    */
    ZoomScaleUtil.GetScaleAsync = function (callback) {
        if (ZoomScaleUtil.IsScaleFactorCommunicationAvailable) {
            ZoomScaleUtil.RequestScaleFactor(callback);
        }
        else if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(callback)) {
            callback(ZoomScaleUtil.ZoomScaleForLocalWindow, 0, 0);
        }
    };
    /**
    * Returns the last known browser viewport scale factor. Note that this scale factor may be stale when we are embedded.
    * Consumers that require the zoom scale to always be accurate and can tolerate asynchronous behavior should use
    * <see cref="GetScaleAsync"/> instead.
    */
    ZoomScaleUtil.GetScaleSync = function () {
        if (ZoomScaleUtil.IsScaleFactorCommunicationAvailable) {
            ZoomScaleUtil.RequestScaleFactor();
            return ZoomScaleUtil.lastScaleFactor;
        }
        else {
            return ZoomScaleUtil.ZoomScaleForLocalWindow;
        }
    };
    ZoomScaleUtil.PendingCallbacks = {};
    ZoomScaleUtil.nextId = 1;
    ZoomScaleUtil.lastScaleFactor = 1;
    return ZoomScaleUtil;
}());
exports.ZoomScaleUtil = ZoomScaleUtil;
ZoomScaleUtil.initialize();


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var browser_support_1 = __webpack_require__(4);
var EventUtils_1 = __webpack_require__(11);
var Gesture_1 = __webpack_require__(6);
var GlobalUIEvents_1 = __webpack_require__(14);
var VizclientUtils_1 = __webpack_require__(1);
var MiscUtil_1 = __webpack_require__(0);
var MouseCapture_1 = __webpack_require__(29);
/**
* Drag gesture implementation. Inherits Gesture
*/
var Drag = /** @class */ (function (_super) {
    __extends(Drag, _super);
    /**
    * Initializes a new instance of the Drag class
    * @param {GestureEventHandleSpec} config - object
    */
    function Drag(config, mouseCaptureHandler) {
        var _this = _super.call(this, config, "drag" /* Drag */, /* hasSlop */ true) || this;
        _this.canceled = false; // has the gesture been canceled?
        _this.dragging = false;
        _this.mouseCaptureHandler = mouseCaptureHandler;
        return _this;
    }
    Drag.prototype.Start = function (e) {
        VizclientUtils_1.Logger.Debug('start');
        var touch = e.touches[0];
        // Bug 123836, 121420: Don't allow default behavior of copying images when dragging an image
        // Bug 152286: Touch scrolling on vizzes broken in mobile
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(e.target) && e.target.tagName.toUpperCase() === 'IMG' && !VizclientUtils_1.TsConfig.IsMobile()) {
            e.preventDefault();
        }
        // right number of touches (i.e., fingers)?
        if (e.touches.length !== this.numTouches) {
            // Nope. Cancel anything in progress
            if (this.dragging) {
                this.Fire("dragEnd" /* DragEnd */, e, this.lastInfo);
            }
            this.ResetGestureState();
            this.canceled = true;
            return;
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.startInfo) && !browser_support_1.BrowserSupport.IsTouch()) {
            // We're getting multiple starts in a row. Must be we got a mousedown and no mouseup.
            // I bet you $100 we're using Chrome and you clicked on a scroll bar.
            // For touch we don't do this as multitouch can trigger this easily.
            // http://code.google.com/p/chromium/issues/detail?id=14204
            VizclientUtils_1.Logger.Debug('multiple starts in a row, ending old one first');
            this.End(e);
        }
        this.canceled = false;
        this.startInfo = this.BuildStartInfo(touch);
        this.lastInfo = this.startInfo;
        this.isPotentialPress = false;
        if (this.Config.IsHandling("potentialPress" /* PotentialPress */)) {
            this.StartPotentialPressDetection();
        }
    };
    Drag.prototype.Move = function (e) {
        if (this.canceled) {
            return;
        }
        // Bug 581838: In order to prevent scrolling and selecting at the same time, track when the
        // user is triggering a potential press and call preventDefault() on any subsequent event.
        // If the user is not scrolling, this will prevent them from starting.
        if (this.isPotentialPress && e.touches.length === this.numTouches) {
            e.preventDefault();
        }
        this.lastInfo = this.GetParams(e);
        if (this.dragging) {
            this.Fire("dragMove" /* DragMove */, e, this.lastInfo);
        }
        else if (this.PastSlop(e)) {
            this.dragging = true;
            this.Fire("dragStart" /* DragStart */, e, this.lastInfo);
            this.Fire("dragMove" /* DragMove */, e, this.lastInfo);
            // if this config also handles dragEnd, capture events while the mouse is down so we can detect
            // mouseup/mousemove outside the document
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.Config.dragEnd)) {
                MouseCapture_1.MouseCapture.SetCapture(this.mouseCaptureHandler);
            }
        }
    };
    Drag.prototype.End = function (e) {
        var param;
        if (!this.dragging) {
            var shouldBeginRecognizingDrag = e.touches.length === this.numTouches && // Only fire DragStart if we have the correct number of touches
                (!MiscUtil_1.MiscUtil.IsNullOrUndefined(e.touches[0].identifier)) && // Avoid false-positives when handling right clicks
                this.PastSlop(e); // Only fire DragStart if we have moved past the allowed slop.
            if (!shouldBeginRecognizingDrag) {
                // TFSID: 624101 - Make sure we reset the gesture state when no drag occurred, otherwise
                // a tap or click will leave us in a bad state when we begin recognizing the next gestures.
                this.ResetGestureState();
                return;
            }
            this.startInfo = this.BuildStartInfo(e.touches[0]);
            this.lastInfo = this.startInfo;
            param = this.GetParams(e);
            this.canceled = false;
            this.dragging = true;
            this.Fire("dragStart" /* DragStart */, e, param);
            return;
        }
        VizclientUtils_1.Logger.Debug('end');
        // stop capturing mouse events since we're done dragging
        MouseCapture_1.MouseCapture.ReleaseCapture();
        param = this.GetParams(e);
        this.ResetGestureState();
        // fire global drag end event before drag drop manager performs the drag end
        if (this.Config.IsHandling("dragEnd" /* DragEnd */)) {
            // make a new temp event to protect the original, and add in my lastInfo because it
            // holds important gesture info that is missing from OriginalEvent on iPad.
            var tempEvt = EventUtils_1.NormalizedEvent.Create(e.originalEvent, null);
            $.extend(tempEvt, this.lastInfo);
            GlobalUIEvents_1.GlobalUIEvents.FireDragEnd(tempEvt, null /*DragEnd is not cancellable*/);
        }
        this.Fire("dragEnd" /* DragEnd */, e, param);
    };
    Drag.prototype.Cancel = function () {
        this.canceled = true;
    };
    /**
    * Given a touch object representing the beginning of the drag gesture, returns a GestureEventInfo that captures
    * the necessary information about the gesture's starting location.
    */
    Drag.prototype.BuildStartInfo = function (touch) {
        var param = new Gesture_1.GestureEventInfo();
        param.pageX = touch.pageX;
        param.pageY = touch.pageY;
        return param;
    };
    /**
    * Given a "move" event, returns additional information that gives context about the event relative to the entire
    * drag gesture.
    */
    Drag.prototype.GetParams = function (evt) {
        var touch = evt.changedTouches[0];
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(this.startInfo)) {
            this.startInfo = this.BuildStartInfo(touch);
        }
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(this.lastInfo)) {
            this.lastInfo = this.startInfo;
        }
        var param = new Gesture_1.GestureEventInfo();
        param.clientX = touch.clientX;
        param.clientY = touch.clientY;
        param.pageX = touch.pageX;
        param.pageY = touch.pageY;
        param.startX = this.startInfo.pageX;
        param.startY = this.startInfo.pageY;
        param.deltaX = param.pageX - this.startInfo.pageX;
        param.deltaY = param.pageY - this.startInfo.pageY;
        param.deltaXSinceLast = param.pageX - this.lastInfo.pageX;
        param.deltaYSinceLast = param.pageY - this.lastInfo.pageY;
        param.scale = 1;
        return param;
    };
    Drag.prototype.PastSlop = function (evt) {
        var touch = evt.touches[0];
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(this.startInfo)) {
            return false; // we haven't even started yet
        }
        var zoomAdjustedSlop = this.ZoomAdjustedSlop;
        return Math.abs(touch.pageX - this.startInfo.pageX) > zoomAdjustedSlop ||
            Math.abs(touch.pageY - this.startInfo.pageY) > zoomAdjustedSlop;
    };
    /**
     * Reset the gesture state so that no gesture is in the process of being recognized.
     */
    Drag.prototype.ResetGestureState = function () {
        this.startInfo = null;
        this.dragging = false;
        this.isPotentialPress = false;
        this.potentialPressTimer = MiscUtil_1.MiscUtil.ClearTimeout(this.potentialPressTimer);
    };
    Drag.prototype.StartPotentialPressDetection = function () {
        var _this = this;
        this.potentialPressTimer = window.setTimeout(function () {
            // TFSID 625762 - Fail the potential press detection if we have already started dragging by the time
            // this callback is invoked.
            // This stops us from accidentally killing some native browser interactions. As of 2017-03-29, I am
            // aware of two specific situations situations where this is relevant:
            // (1) scrolling via dragging on a touch-enabled device
            // (2) dragging an HTML5 slider
            if (!_this.dragging) {
                _this.isPotentialPress = true;
            }
            // tslint:disable-next-line:align
        }, Gesture_1.Gesture.PotentialPressTime);
    };
    return Drag;
}(Gesture_1.Gesture));
exports.Drag = Drag;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DomUtil_1 = __webpack_require__(13);
var Gesture_1 = __webpack_require__(6);
var VizclientUtils_1 = __webpack_require__(1);
var MiscUtil_1 = __webpack_require__(0);
var TypeUtil_1 = __webpack_require__(2);
var Hover = /** @class */ (function (_super) {
    __extends(Hover, _super);
    /**
     * Initializes a new instance of the Hover class
     * @param {EventHandleSpec} config - GestureEventHandleSpec object
     */
    function Hover(config) {
        var _this = _super.call(this, config, "hover" /* Hover */, /*hasSlop*/ false) || this;
        _this.startX = 0;
        _this.startY = 0;
        _this.possible = true;
        _this.hoverTime = (MiscUtil_1.MiscUtil.IsNullOrUndefined(config.HoverDelay)) ? Hover.HoverTime : config.HoverDelay;
        return _this;
    }
    Hover.prototype.Start = function (e) {
        VizclientUtils_1.Logger.Debug('Start');
        this.Cancel();
        this.possible = false;
    };
    Hover.prototype.Move = function (e) {
        var _this = this;
        VizclientUtils_1.Logger.Debug("Move: " + e);
        var moveEvent = e.touches[0];
        if (!this.possible) {
            return; // mouse down => not possible
        }
        if (!this.PastSlop(e)) {
            return; // either before or after hover fires, do nothing within slop
        }
        var param = this.GetParam(e);
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.hoverTimeout)) {
            this.Cancel();
        }
        this.Fire("moving" /* Moving */, e, param);
        this.startX = moveEvent.pageX;
        this.startY = moveEvent.pageY;
        this.hoverTimeout = window.setTimeout(function () {
            VizclientUtils_1.Logger.Debug('Hover');
            if (!_this.isSuppressed) {
                _this.Fire("hover" /* Hover */, e, param);
            }
            _this.ClearTimeout();
        }, 
        // tslint:disable-next-line:align
        this.hoverTime);
    };
    Hover.prototype.End = function (e) {
        VizclientUtils_1.Logger.Debug('end');
        if (e.touches.length === 0) {
            this.possible = true;
        }
    };
    Hover.prototype.Out = function (e) {
        // http://www.quirksmode.org/js/events_mouse.html#relatedtarget (dojo normalizes IE for us)
        // in case of mouseout, relatedTarget is the element the mouse is going to.
        // We stop the hover if we are going to an element that is neither the originator of the hover,
        // nor a child of the originator.
        var relatedTarget = TypeUtil_1.TypeUtil.GetField(e.originalEvent, 'relatedTarget');
        if (this.Config.DomElement !== relatedTarget && !DomUtil_1.DomUtil.IsAncestorOf(this.Config.DomElement, relatedTarget)) {
            VizclientUtils_1.Logger.Debug('Out.');
            this.Cancel();
            this.Fire("mouseleave" /* MouseLeave */, e, this.GetParam(e));
        }
    };
    Hover.prototype.suppressHover = function () {
        if (!this.isSuppressed) {
            VizclientUtils_1.Logger.Debug('SuppressHover.');
        }
        this.isSuppressed = true;
    };
    Hover.prototype.unsuppressHover = function () {
        if (this.isSuppressed) {
            VizclientUtils_1.Logger.Debug('UnsuppressHover.');
        }
        // TODO - old code had a "trigger hover if we haven't moved from the suppress point"
        this.isSuppressed = false;
        // Depending on where/when mouse events occured our state may no longer be valid.
        // Reset that state when this method is called, assuming that it will be called
        // at appropriate times.
        this.possible = true;
    };
    Hover.prototype.Cancel = function () {
        this.ClearTimeout();
        this.startX = 0;
        this.startY = 0;
        this.possible = true;
    };
    Hover.prototype.ClearTimeout = function () {
        this.hoverTimeout = MiscUtil_1.MiscUtil.ClearTimeout(this.hoverTimeout);
    };
    Hover.prototype.PastSlop = function (e) {
        var touch = e.touches[0];
        var diffX = Math.abs(touch.pageX - this.startX);
        var diffY = Math.abs(touch.pageY - this.startY);
        return (diffX + diffY) > this.ZoomAdjustedSlop;
    };
    Hover.prototype.GetParam = function (e) {
        var param = new Gesture_1.GestureEventInfo();
        param.pageX = e.changedTouches[0].pageX;
        param.pageY = e.changedTouches[0].pageY;
        param.clientX = e.changedTouches[0].clientX;
        param.clientY = e.changedTouches[0].clientY;
        return param;
    };
    Hover.HoverTime = 150;
    Hover.FastHoverTime = 120;
    return Hover;
}(Gesture_1.Gesture));
exports.Hover = Hover;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventHandleSpec_1 = __webpack_require__(7);
var VizclientUtils_1 = __webpack_require__(1);
var MiscUtil_1 = __webpack_require__(0);
var NormalizedEvent_1 = __webpack_require__(5);
var TableauEventHandler_1 = __webpack_require__(8);
var TypeUtil_1 = __webpack_require__(2);
/**
 *
 * This subclass adds additional hooks to TableauEventHandler for React to use.
 * With react, the actual DOM element won't be available right away (React uses virtual DOM), therefore
 * operation involving the actual DOM element will need to be handled on some later time (or simply on demand).
 *
 */
var TableauEventHandlerForReact = /** @class */ (function (_super) {
    __extends(TableauEventHandlerForReact, _super);
    function TableauEventHandlerForReact() {
        var _this = _super.call(this) || this;
        _this.eventHandlingAttributesForReact = _this.GetEventHandlingAttributesForReact();
        return _this;
    }
    Object.defineProperty(TableauEventHandlerForReact.prototype, "EventHandlingAttributesForReact", {
        get: function () {
            return this.eventHandlingAttributesForReact;
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Factory function for when the caller could not provide the DOM element and the event handling
    * specs at the same time. This allows the caller to call UpdateEventHandleSpec at some later time.
    * React uses this so it can update the spec once it actually has a DOM element that is rendered.
    */
    TableauEventHandlerForReact.CreateEmpty = function () {
        return new TableauEventHandlerForReact();
    };
    /**
    * Useful when creating the TableauEventHandler and specifying the domElement + specs needs
    * to be separate. React components can call this once its dom element is actually rendered.
    * @param {HTMLElement} domElement - Element on which the event handler should be attached upon.
    * @param {EventHandleSpec} config - Event handling specification.
    */
    TableauEventHandlerForReact.prototype.UpdateEventHandleSpec = function (domElement, config) {
        this.config = !MiscUtil_1.MiscUtil.IsNullOrUndefined(config) ? config : new EventHandleSpec_1.EventHandleSpec();
        this.config.DomElement = domElement;
        this.ConfigureDomElem(domElement);
        // If we have a press Drag, set up the callback modifications
        this.SetupEventRecognizer(this.config);
    };
    /**
    * A mapping between the standard browser event names and event names recognized by React.
    * We need to know this to forward the correct event names from react components to the TableauEventHandler.
    */
    TableauEventHandlerForReact.LookupReactEventName = function (browserEventName) {
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(TableauEventHandlerForReact.browserEventToReactEvent)) {
            TableauEventHandlerForReact.browserEventToReactEvent = {};
            TableauEventHandlerForReact.browserEventToReactEvent["touchstart" /* TouchStart */] = "onTouchStart" /* onTouchStart */;
            TableauEventHandlerForReact.browserEventToReactEvent["touchmove" /* TouchMove */] = "onTouchMove" /* onTouchMove */;
            TableauEventHandlerForReact.browserEventToReactEvent["touchend" /* TouchEnd */] = "onTouchEnd" /* onTouchEnd */;
            TableauEventHandlerForReact.browserEventToReactEvent["touchcancel" /* TouchCancel */] = "onTouchCancel" /* onTouchCancel */;
            TableauEventHandlerForReact.browserEventToReactEvent["mousedown" /* MouseDown */] = "onMouseDown" /* onMouseDown */;
            TableauEventHandlerForReact.browserEventToReactEvent["mousemove" /* MouseMove */] = "onMouseMove" /* onMouseMove */;
            TableauEventHandlerForReact.browserEventToReactEvent["mouseup" /* MouseUp */] = "onMouseUp" /* onMouseUp */;
            TableauEventHandlerForReact.browserEventToReactEvent["mouseout" /* MouseOut */] = "onMouseOut" /* onMouseOut */;
            TableauEventHandlerForReact.browserEventToReactEvent["scroll" /* Scroll */] = "onScroll" /* onScroll */;
            TableauEventHandlerForReact.browserEventToReactEvent["contextmenu" /* ContextMenu */] = "onContextMenu" /* onContextMenu */;
        }
        return TableauEventHandlerForReact.browserEventToReactEvent[browserEventName];
    };
    /**
    * Get attributes containing event handlers that will forward events which TableauEventHandler cares about.
    * @returns Base HTMLAttributes object that will contain event handlers that forward react events to TableauEventHandler.
    */
    TableauEventHandlerForReact.prototype.GetEventHandlingAttributesForReact = function () {
        var _this = this;
        var attrs = {};
        var handler = function (evt) {
            var e = NormalizedEvent_1.NormalizedEvent.Create(evt.nativeEvent, _this.config.DomElement, evt);
            _this.handler(e);
        };
        NormalizedEvent_1.NormalizedEvent.AllHandledEvents.forEach(function (handledEvent) {
            var reactEvent = TableauEventHandlerForReact.LookupReactEventName(handledEvent);
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(reactEvent)) {
                TypeUtil_1.TypeUtil.SetField(attrs, reactEvent.toString(), handler);
            }
            else {
                VizclientUtils_1.Logger.Debug("Can't find a matching React.js event name for " + handledEvent);
            }
        });
        return attrs;
    };
    TableauEventHandlerForReact.browserEventToReactEvent = null;
    return TableauEventHandlerForReact;
}(TableauEventHandler_1.TableauEventHandler));
exports.TableauEventHandlerForReact = TableauEventHandlerForReact;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var browser_support_1 = __webpack_require__(4);
var DisposableHolder_1 = __webpack_require__(37);
var Delegate_1 = __webpack_require__(9);
var DropResult_1 = __webpack_require__(22);
var EmbeddedCustomCursor_1 = __webpack_require__(10);
var EventUtils_1 = __webpack_require__(11);
var SimplifiedDragSafeGlass_1 = __webpack_require__(38);
var VizclientUtils_1 = __webpack_require__(1);
var MiscUtil_1 = __webpack_require__(0);
var TableauEventHandler_1 = __webpack_require__(8);
var TypeUtil_1 = __webpack_require__(2);
var WindowHelper_1 = __webpack_require__(39);
// Helper functions ---------------------------
function IsNullOrEmpty(s) {
    return MiscUtil_1.MiscUtil.IsNullOrUndefined(s) || s.length === 0;
}
// tslint:disable-next-line:no-any
function StopEvent(e) {
    e.stopPropagation();
    e.preventDefault();
}
// This enum should match draginstancetype enum
var DragInstanceType;
(function (DragInstanceType) {
    DragInstanceType["Unknown"] = "unknown";
})(DragInstanceType || (DragInstanceType = {}));
// -------------------------
/// <summary>
/// Global manager of drag/drop process.  Responsible for recognizing drag events and working with instances of
/// <see cref="IDragSource"/> and <see cref="IDropTarget"/> to perform drag/drop operations.
/// </summary>
var DragDropManager = /** @class */ (function () {
    function DragDropManager() {
        // note: Application will call DragDropManager.Init() during startup to attach an event handler to Body
    }
    DragDropManager.initialize = function () {
        DragDropManager.dragSpec = new EventUtils_1.EventHandleSpec();
        DragDropManager.dragSpec.dragStart = DragDropManager.dragStart;
        DragDropManager.dragSpec.dragMove = DragDropManager.dragMove;
        DragDropManager.dragSpec.dragEnd = DragDropManager.dragEnd;
        DragDropManager.dragSpec.pressEnd = DragDropManager.dragEnd;
        DragDropManager.dragSpec.firstTouch = DragDropManager.firstTouch;
        DragDropManager.dragDisposables = new DisposableHolder_1.DisposableHolder();
    };
    DragDropManager.add_dragStarted = function (ev) {
        DragDropManager.dragStarted.add(ev);
    };
    DragDropManager.remove_dragStarted = function (ev) {
        DragDropManager.dragStarted.remove(ev);
    };
    DragDropManager.add_dragMoved = function (ev) {
        DragDropManager.dragMoved.add(ev);
    };
    DragDropManager.remove_dragMoved = function (ev) {
        DragDropManager.dragMoved.remove(ev);
    };
    DragDropManager.add_dragEnded = function (ev) {
        DragDropManager.dragEnded.add(ev);
    };
    DragDropManager.remove_dragEnded = function (ev) {
        DragDropManager.dragEnded.remove(ev);
    };
    DragDropManager.add_currentTargetChanged = function (ev) {
        DragDropManager.currentTargetChanged.add(ev);
    };
    DragDropManager.remove_currentTargetChanged = function (ev) {
        DragDropManager.currentTargetChanged.remove(ev);
    };
    DragDropManager.setStartDragHandler = function (takeOver) {
        if (DragDropManager.dragTakeOver === undefined) {
            DragDropManager.dragTakeOver = takeOver;
            return function () { return DragDropManager.unsetStartDragHandler(); };
        }
        // drag already taken over
        return null;
    };
    DragDropManager.unsetStartDragHandler = function () {
        DragDropManager.dragTakeOver = undefined;
    };
    Object.defineProperty(DragDropManager, "isDragging", {
        get: function () {
            return !MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.CurrentDrag);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragDropManager, "LastDragEvent", {
        get: function () {
            return DragDropManager.get_lastDragEvent();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragDropManager, "CurrentDrag", {
        get: function () {
            return DragDropManager.get_currentDrag();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragDropManager, "CurrentTarget", {
        get: function () {
            return DragDropManager.get_currentTarget();
        },
        set: function (value) {
            var changed = DragDropManager.currentTarget !== value;
            DragDropManager.currentTarget = value;
            if (changed && !MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.currentTargetChanged)) {
                DragDropManager.currentTargetChanged.invoke(DragDropManager.currentTarget);
            }
        },
        enumerable: true,
        configurable: true
    });
    /// <summary>
    /// Called from the Application when it's safe to acess the Document body
    /// </summary>
    DragDropManager.init = function () {
        if (DragDropManager.dragDropEventHandler === undefined) {
            DragDropManager.dragDropEventHandler = new TableauEventHandler_1.TableauEventHandler(document.body, DragDropManager.dragSpec);
        }
    };
    DragDropManager.addClassSVGCompatible = function (targetElement, className) {
        var element = targetElement[0];
        var classNamesString = element.getAttribute('class');
        if (IsNullOrEmpty(classNamesString)) {
            element.setAttribute('class', className);
            return;
        }
        var classNamesArray = classNamesString.split(' ');
        if (classNamesArray.indexOf(className) === -1) {
            element.setAttribute('class', classNamesArray.concat(className).join(' '));
        }
    };
    DragDropManager.removeClassSVGCompatible = function (targetElement, className) {
        var element = targetElement[0];
        var classNamesString = element.getAttribute('class');
        if (IsNullOrEmpty(classNamesString)) {
            return;
        }
        var classNamesArray = classNamesString.split(' ');
        var classNameIndex = classNamesArray.indexOf(className);
        if (classNameIndex >= 0) {
            classNamesArray.splice(classNameIndex, 1);
            element.setAttribute('class', classNamesArray.join(' '));
        }
    };
    DragDropManager.attachDropTarget = function (targetElement, dropTarget) {
        targetElement.attr(DragDropManager.DropTargetAttr, '1');
        DragDropManager.addClassSVGCompatible(targetElement, DragDropManager.DropTargetClass);
        targetElement.data(DragDropManager.DropTargetDataKey, dropTarget);
    };
    DragDropManager.detachDropTarget = function (targetElement) {
        targetElement.removeAttr(DragDropManager.DropTargetAttr);
        targetElement.removeData(DragDropManager.DropTargetDataKey);
        DragDropManager.removeClassSVGCompatible(targetElement, DragDropManager.DropTargetClass);
    };
    DragDropManager.isDropTarget = function (targetElement) {
        return !MiscUtil_1.MiscUtil.IsNullOrUndefined(targetElement.attr(DragDropManager.DropTargetAttr));
    };
    DragDropManager.attachDragSource = function (sourceElement, dragSource) {
        sourceElement.attr(DragDropManager.DragSourceAttr, '1');
        sourceElement.data(DragDropManager.DragSourceDataKey, dragSource);
    };
    DragDropManager.removeDragSource = function (sourceElement) {
        sourceElement.removeData(DragDropManager.DragSourceDataKey);
        sourceElement.removeAttr(DragDropManager.DragSourceAttr);
    };
    DragDropManager.isDragSource = function (sourceElement) {
        return !MiscUtil_1.MiscUtil.IsNullOrUndefined(sourceElement.attr(DragDropManager.DragSourceAttr));
    };
    DragDropManager.createDragGlass = function () {
        DragDropManager.dragGlass = new SimplifiedDragSafeGlass_1.SimplifiedDragSafeGlass();
        DragDropManager.dragGlass.show();
        if (DragDropManager.CurrentDrag.get_hasPayload()
            && DragDropManager.CurrentDrag.get_dragType() === "dragmove" /* dragmove */) {
            DragDropManager.setDragCursor(EmbeddedCustomCursor_1.EmbeddedCustomCursor.copyFromElement(DragDropManager.firstTouchDragElement));
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragGlass.Element)) {
            DragDropManager.dragGlassEventHandler =
                new TableauEventHandler_1.TableauEventHandler(DragDropManager.dragGlass.Element[0], DragDropManager.dragSpec);
            DragDropManager.dragDisposables = new DisposableHolder_1.DisposableHolder();
            DragDropManager.dragDisposables.add(DragDropManager.dragGlass);
            DragDropManager.dragDisposables.add(DragDropManager.dragGlassEventHandler);
            DragDropManager.dragDisposables.add(DragDropManager.BindWithDispose($(document.body), "keydown" /* KeyDown */, DragDropManager.handleKeyDown));
            DragDropManager.dragDisposables.add(DragDropManager.BindWithDispose($(document.body), "keyup" /* KeyUp */, DragDropManager.handleKeyUp));
        }
    };
    DragDropManager.destroyDragGlass = function () {
        DragDropManager.dragDisposables.dispose();
        DragDropManager.dragDisposables = new DisposableHolder_1.DisposableHolder();
    };
    DragDropManager.startDrag = function (draggedObject, e, optionalDragElement) {
        if (optionalDragElement === void 0) { optionalDragElement = null; }
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(draggedObject) || MiscUtil_1.MiscUtil.IsNullOrUndefined(e) || !draggedObject.get_hasPayload()) {
            return;
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(optionalDragElement)) {
            DragDropManager.firstTouchDragElement = optionalDragElement;
        }
        DragDropManager.lastDragEvent = e;
        DragDropManager.cancelDrag();
        DragDropManager.currentDrag = draggedObject;
        DragDropManager.setDragAvatar(DragDropManager.CurrentDrag.get_dragAvatar());
        DragDropManager.updateAvatarPosition();
        DragDropManager.avatarUpdateInterval = WindowHelper_1.WindowHelper.RequestAnimationFrame(DragDropManager.updateAvatarPosition);
        DragDropManager.createDragGlass();
        DragDropManager.setDragTarget(e);
        // check if somebody wants to take over the drag process (dragdrop contract on desktop for example)
        if (DragDropManager.dragTakeOver !== undefined) {
            if (DragDropManager.dragTakeOver(draggedObject, e)) {
                VizclientUtils_1.Logger.Debug('Drag started but taken over');
                DragDropManager.cancelDrag();
                return;
            }
        }
        VizclientUtils_1.Logger.Debug("Drag started " + DragDropManager.CurrentDrag);
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragStarted)) {
            DragDropManager.dragStarted.invoke(DragDropManager.CurrentDrag);
        }
    };
    DragDropManager.cancelDrag = function (drag) {
        if (drag === void 0) { drag = null; }
        if (!DragDropManager.isDragging) {
            return;
        }
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(drag) || drag === DragDropManager.CurrentDrag) {
            VizclientUtils_1.Logger.Debug('Drag cancelled');
            DragDropManager.CurrentDrag.cancelDrag();
            DragDropManager.endDrag(null /*target:*/, true /*cancelled:*/, false /*ctrlKeyPressed:*/, function () { return $.Deferred().resolve(false); } /*dropAction:*/);
        }
    };
    DragDropManager.drop = function (target, isCopyDrop, isShiftDrop, isRightDrop) {
        if (isCopyDrop === void 0) { isCopyDrop = false; }
        if (isShiftDrop === void 0) { isShiftDrop = false; }
        if (isRightDrop === void 0) { isRightDrop = false; }
        DragDropManager.currentDrag.isCopyDrag = isCopyDrop;
        DragDropManager.currentDrag.isShiftDrag = isShiftDrop;
        DragDropManager.currentDrag.isRightDrag = isRightDrop;
        DragDropManager.endDrag(target, false /*cancelled:*/, DragDropManager.CurrentDrag.isCopyDrag /*ctrlKeyPressed:*/, function () {
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(target)) {
                return target.acceptDrop(DragDropManager.CurrentDrag).always(function (success) {
                    VizclientUtils_1.Logger.Debug("Drop: " + success + " " + target);
                });
            }
            else {
                VizclientUtils_1.Logger.Debug('Drop with no target');
                DragDropManager.CurrentDrag.dropToNowhereAction();
                return $.Deferred().resolve(true);
            }
        });
    };
    DragDropManager.firstTouch = function (e) {
        var src = $(e.target).closest(DragDropManager.DragSourceSelector);
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(src) || src.length === 0) {
            DragDropManager.firstTouchDragSource = null;
            DragDropManager.firstTouchDragElement = null;
            return;
        }
        DragDropManager.firstTouchDragSource = src.data(DragDropManager.DragSourceDataKey);
        DragDropManager.firstTouchDragElement = src;
    };
    DragDropManager.dragEnd = function (e) {
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.CurrentDrag)) {
            return;
        }
        switch (DragDropManager.CurrentDrag.get_dragType()) {
            case "dragmove" /* dragmove */:
                DragDropManager.endDrag(null /*target:*/, false /*cancelled:*/, false /*ctrlKeyPressed:*/, function () {
                    DragDropManager.CurrentDrag.endDragAt(e);
                    return $.Deferred().resolve(true);
                });
                break;
            case "dragmovedrop" /* dragmovedrop */:
            case "dragdrop" /* dragdrop */:
                DragDropManager.drop(DragDropManager.CurrentTarget, e.IsCtrlKey, e.shiftKey, e.IsRightMouseEvent);
                break;
            default:
                break;
        }
    };
    DragDropManager.dragMove = function (e) {
        if (!DragDropManager.isDragging) {
            return;
        }
        StopEvent(e);
        DragDropManager.lastDragEvent = e;
        DragDropManager.currentDrag.isCopyDrag = e.IsCtrlKey;
        DragDropManager.currentDrag.isShiftDrag = e.shiftKey;
        WindowHelper_1.WindowHelper.ClearSelection();
        var now = Date.now();
        if ((now - DragDropManager.lastAvatarUpdate) > 75) {
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.avatarUpdateInterval)) {
                WindowHelper_1.WindowHelper.CancelAnimationFrame(DragDropManager.avatarUpdateInterval);
            }
            DragDropManager.updateAvatarPosition();
        }
        DragDropManager.setDragTarget(e);
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragMoved)) {
            DragDropManager.dragMoved.invoke(DragDropManager.CurrentDrag);
        }
    };
    DragDropManager.handleKeyDown = function (e) {
        if (!DragDropManager.isDragging) {
            return;
        }
        StopEvent(e);
        switch (e.which) {
            case 16 /* Shift */:
                DragDropManager.lastDragEvent.shiftKey = true;
                DragDropManager.dragMove(DragDropManager.LastDragEvent);
                break;
            default:
                break;
        }
    };
    DragDropManager.handleKeyUp = function (e) {
        if (!DragDropManager.isDragging) {
            return;
        }
        StopEvent(e);
        switch (e.which) {
            case 16 /* Shift */:
                DragDropManager.lastDragEvent.shiftKey = false;
                DragDropManager.dragMove(DragDropManager.LastDragEvent);
                break;
            case 27 /* Escape */:
                DragDropManager.cancelDrag(DragDropManager.CurrentDrag);
                break;
            default:
                break;
        }
    };
    DragDropManager.setDragTarget = function (e) {
        switch (DragDropManager.CurrentDrag.get_dragType()) {
            case "dragmove" /* dragmove */:
                DragDropManager.CurrentDrag.moveTo(e);
                break;
            case "dragdrop" /* dragdrop */:
                DragDropManager.setTargetForDrop(e);
                break;
            case "dragmovedrop" /* dragmovedrop */:
                DragDropManager.CurrentDrag.moveTo(e);
                DragDropManager.setTargetForDrop(e);
                break;
            default:
                break;
        }
    };
    DragDropManager.setTargetForDrop = function (e) {
        var target = DragDropManager.findDropTarget(e);
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.CurrentTarget)) {
            if (DragDropManager.CurrentTarget !== target) {
                DragDropManager.CurrentTarget.dragExit(DragDropManager.CurrentDrag);
            }
            else if (DragDropManager.CurrentTarget.get_feedbackType() === "dropfeedbackuponentry" /* dropfeedbackuponentry */) {
                VizclientUtils_1.Logger.Debug("Drag move: target=" + DragDropManager.CurrentTarget);
                return;
            }
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(target)) {
            var newTarget = target.dragOver(DragDropManager.CurrentDrag);
            while (!MiscUtil_1.MiscUtil.IsNullOrUndefined(newTarget) && newTarget !== target) {
                target = newTarget;
                newTarget = target.dragOver(DragDropManager.CurrentDrag);
            }
            target = newTarget;
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(target)) {
            DragDropManager.setDragCursor(target.getDropCursor(DragDropManager.CurrentDrag));
        }
        else {
            VizclientUtils_1.Logger.Debug('No target');
            DragDropManager.setDragCursor(DragDropManager.CurrentDrag.get_defaultDropCursor());
        }
        DragDropManager.CurrentTarget = target;
    };
    DragDropManager.setDragCursor = function (c) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragGlass)
            && !MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragGlass.Element)) {
            c.setCursor(DragDropManager.dragGlass.Element);
        }
    };
    DragDropManager.dragStart = function (e) {
        if (DragDropManager.isDragging) {
            return;
        }
        var ds = DragDropManager.firstTouchDragSource;
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(ds)) {
            var src = $(e.target).closest(DragDropManager.DragSourceSelector);
            ds = src.data(DragDropManager.DragSourceDataKey);
        }
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(ds)) {
            return;
        }
        // Make sure the drag source can accept this drag type.
        if (ds.acceptsDragType() === 1 /* LeftMouse */ && e.IsMouseEvent && !e.IsLeftMouseEvent) {
            return;
        }
        var drag = ds.startDrag(e);
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(drag)) {
            return;
        }
        DragDropManager.startDrag(drag, e);
    };
    DragDropManager.endDrag = function (target, cancelled, ctrlKeyPressed, dropAction) {
        DragDropManager.setDragAvatar(null);
        DragDropManager.destroyDragGlass();
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.avatarUpdateInterval)) {
            WindowHelper_1.WindowHelper.CancelAnimationFrame(DragDropManager.avatarUpdateInterval);
            DragDropManager.avatarUpdateInterval = null;
        }
        dropAction().always(function (success) {
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragEnded)) {
                DragDropManager.dragEnded.invoke(new DropResult_1.DropResult(DragDropManager.CurrentDrag, target, success, cancelled, ctrlKeyPressed));
            }
            DragDropManager.currentDrag = null;
            DragDropManager.CurrentTarget = null;
        });
    };
    DragDropManager.setDragAvatar = function (newAvatar) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragAvatar)) {
            DragDropManager.dragAvatar.get_rootElement().detach();
            var d = DragDropManager.dragAvatar;
            d.dispose();
            DragDropManager.dragAvatar = null;
        }
        DragDropManager.dragAvatar = newAvatar;
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragAvatar)) {
            DragDropManager.dragAvatar.get_rootElement().addClass('dragAvatar').css('position', 'absolute').css('pointer-events', 'none');
            DragDropManager.dragAvatar.addToDom($('body'));
        }
    };
    DragDropManager.updateAvatarPosition = function () {
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(DragDropManager.dragAvatar)) {
            return;
        }
        var computeCoord = function (totalDimension, dragEventPos, avatarDimension) {
            if (dragEventPos < (avatarDimension / 2)) {
                return 0;
            }
            else if (dragEventPos > (totalDimension - (avatarDimension / 2))) {
                return totalDimension - avatarDimension;
            }
            else {
                return dragEventPos - (avatarDimension / 2);
            }
        };
        var body = DragDropManager.documentBodyOverride === undefined ? document.body : DragDropManager.documentBodyOverride();
        DragDropManager.setElementPosition(DragDropManager.dragAvatar.get_rootElement(), computeCoord(body.scrollWidth, DragDropManager.LastDragEvent.pageX, Math.round(DragDropManager.dragAvatar.get_rootElement().outerWidth())), computeCoord(body.scrollHeight, DragDropManager.LastDragEvent.pageY, Math.round(DragDropManager.dragAvatar.get_rootElement().outerHeight())));
        DragDropManager.lastAvatarUpdate = Date.now();
        DragDropManager.avatarUpdateInterval = WindowHelper_1.WindowHelper.RequestAnimationFrame(DragDropManager.updateAvatarPosition);
    };
    DragDropManager.getElementFromPointInternal = function (e) {
        DragDropManager.disableHitTestsOnDragGlass();
        var x = e.clientX;
        var y = e.clientY;
        if (browser_support_1.BrowserSupport.UseAlternateHitStrategy()) {
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(e.touches) && e.touches.length > 0 && !MiscUtil_1.MiscUtil.IsNullOrUndefined(e.touches[0].screenX)) {
                x = e.touches[0].screenX;
                y = e.touches[0].screenY;
            }
            else {
                x = TypeUtil_1.TypeUtil.GetField(e.originalEvent, 'screenX');
                y = TypeUtil_1.TypeUtil.GetField(e.originalEvent, 'screenY');
            }
        }
        var overNode = $(null);
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(x) && !MiscUtil_1.MiscUtil.IsNullOrUndefined(y)) {
            overNode = $(document.elementFromPoint(x, y));
        }
        DragDropManager.enableHitTestsOnDragGlass();
        return overNode;
    };
    DragDropManager.getElementFromPoint = function (e) {
        return DragDropManager.getElementFromPointInternal(e);
    };
    DragDropManager.disableHitTestsOnDragGlass = function () {
        DragDropManager.registeredDragGlass.forEach(function (g) {
            g.disableHitTests();
        });
    };
    DragDropManager.enableHitTestsOnDragGlass = function () {
        DragDropManager.registeredDragGlass.forEach(function (g) {
            g.enableHitTests();
        });
    };
    DragDropManager.findDropTarget = function (e) {
        if (!DragDropManager.isDragging) {
            return null;
        }
        var dragInstance = DragDropManager.CurrentDrag;
        var targets = DragDropManager.getPotentialDropTargets(e);
        for (var i = 0; i < targets.length; i++) {
            var hit = targets[i];
            var hitTarget = hit.data(DragDropManager.DropTargetDataKey);
            if (DragDropManager.canAccept(hitTarget, dragInstance)) {
                return hitTarget.getDropTarget(hit);
            }
        }
        return null;
    };
    DragDropManager.getPotentialDropTargets = function (e) {
        var targets = [];
        var dropTarget = DragDropManager.getElementFromPoint(e).closest(DragDropManager.DropTargetSelector);
        // In order to handle edge cases, search the next pixel to the left if no drop targets are found. This helps mitigate issues where
        // Document.ElementFromPoint() has an off-by-1 error resulting in an element farther up the DOM hierarchy being chosen, which will
        // not find the right drop target.
        if (dropTarget.length === 0) {
            --e.clientX;
            dropTarget = DragDropManager.getElementFromPoint(e).closest(DragDropManager.DropTargetSelector);
        }
        if (dropTarget.length > 0) {
            targets.push(dropTarget);
            dropTarget.parents(DragDropManager.DropTargetSelector).each(function (unusedindex, element) {
                targets.push($(element));
            });
        }
        return targets;
    };
    DragDropManager.canAccept = function (dropTarget, dragInstance) {
        return !MiscUtil_1.MiscUtil.IsNullOrUndefined(dropTarget)
            && !MiscUtil_1.MiscUtil.IsNullOrUndefined(dragInstance)
            && !MiscUtil_1.MiscUtil.IsNullOrUndefined(dropTarget.dragOver(dragInstance));
    };
    DragDropManager.registerDragGlass = function (g) {
        DragDropManager.registeredDragGlass.push(g);
    };
    DragDropManager.unregisterDragGlass = function (g) {
        DragDropManager.registeredDragGlass = DragDropManager.registeredDragGlass.filter(function (glass) { return glass !== g; });
    };
    // <summary>
    /// Binds an event handler to a jQuery object and returns a disposable for unbinding the same event.
    /// </summary>
    /// <see cref="jQueryObject.On(string,jQueryApi.jQueryEventHandler)"/>
    /// <param name="element">The element(s) to bind to</param>
    /// <param name="eventName">The event name</param>
    /// <param name="handler">The event handler</param>
    /// <returns>A disposable that when called will unbind bound event handler</returns>
    // tslint:disable-next-line:no-any
    DragDropManager.BindWithDispose = function (element, eventName, handler) {
        var eventId = eventName + "." + ++DragDropManager.eventCounter;
        element.on(eventId, handler);
        return new DisposableHolder_1.CallOnDispose(function () { element.off(eventId); });
    };
    /// <summary>
    /// Sets an elements position using either CSS transform or absolute positioning, depending on what
    /// is supported.  Assumes element is added to body.
    /// </summary>
    DragDropManager.setElementPosition = function (e, pageX, pageY, duration, useTransform) {
        if (duration === void 0) { duration = null; }
        if (useTransform === void 0) { useTransform = true; }
        if (useTransform) {
            var styling = {
                top: '0px',
                left: '0px'
            };
            var transformVal = "translate3d(" + pageX + "px, " + pageY + "px, 0px)";
            styling[browser_support_1.BrowserSupport.CssTransformName()] = transformVal;
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(duration)) {
                styling[browser_support_1.BrowserSupport.CssTransitionName() + '-duration'] = duration;
            }
            e.css(styling);
        }
        else {
            var css = {
                position: 'absolute',
                top: pageY + "px",
                left: pageX + "px"
            };
            css[browser_support_1.BrowserSupport.CssTransformName()] = '';
            e.css(css);
        }
    };
    // Redirection for saltarelle generated javascript getters.
    // Stringly typed jasmine unittests spy on these functions with the specific names.
    // TODO: These could be removed once the saltarelle unittests do not depend on them.
    DragDropManager.get_isDragging = function () { return DragDropManager.isDragging; };
    DragDropManager.get_lastDragEvent = function () { return DragDropManager.lastDragEvent; };
    DragDropManager.get_currentTarget = function () { return DragDropManager.currentTarget; };
    DragDropManager.get_currentDrag = function () { return DragDropManager.currentDrag; };
    // These are shortcuts for jasmine unittests to trigger the events directly.
    DragDropManager.triggerEventCurrentTargetChanged = function (d) {
        DragDropManager.currentTargetChanged.invoke(d);
    };
    DragDropManager.triggerEventDragEnded = function (d) {
        DragDropManager.dragEnded.invoke(d);
    };
    DragDropManager.isPresModelDragInstance = function (d) {
        return !MiscUtil_1.MiscUtil.IsNullOrUndefined(d)
            && d.get_hasPayload()
            && d.presmodelType !== undefined
            && d.presmodelType !== ''
            && d.presmodelType !== DragInstanceType.Unknown;
    };
    /// <summary>
    /// Attribute applied to elements to mark them as drag sources.
    /// </summary>
    DragDropManager.DragSourceAttr = 'data-tab-drag-source';
    DragDropManager.DragSourceSelector = '[data-tab-drag-source]';
    DragDropManager.DragSourceDataKey = 'tabDragSource';
    DragDropManager.DropTargetAttr = 'data-tab-drop-target';
    /// <summary>
    /// DEPRECATED: TFSID:679837 - here for backwards compat with automation.  To be removed once
    /// automation has been updated to use the ATTR instead.
    /// </summary>
    DragDropManager.DropTargetClass = 'tabDropTarget';
    DragDropManager.DropTargetSelector = '[data-tab-drop-target]';
    DragDropManager.DropTargetDataKey = 'tabDropTarget';
    DragDropManager.registeredDragGlass = [];
    DragDropManager.dragStarted = new Delegate_1.Delegate();
    DragDropManager.dragMoved = new Delegate_1.Delegate();
    DragDropManager.dragEnded = new Delegate_1.Delegate();
    DragDropManager.currentTargetChanged = new Delegate_1.Delegate();
    DragDropManager.dragTakeOver = undefined;
    DragDropManager.eventCounter = 0;
    // Redirect helper functions for unittests ----------------------------------------------
    // Test hook
    DragDropManager.documentBodyOverride = undefined;
    return DragDropManager;
}());
exports.DragDropManager = DragDropManager;
// call static initializer
DragDropManager.initialize();


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DropResult = /** @class */ (function () {
    function DropResult(drag, target, dropAccepted, canceled, isCopyDrop) {
        this.drag = drag;
        this.target = target;
        this.dropAccepted = dropAccepted;
        this.canceled = canceled;
        this.isCopyDrop = isCopyDrop;
    }
    return DropResult;
}());
exports.DropResult = DropResult;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Gesture_1 = __webpack_require__(6);
var GlobalUIEvents_1 = __webpack_require__(14);
var MiscUtil_1 = __webpack_require__(0);
/**
 * Implements the tap, press, and double tap discrete gestures
 */
var Discrete = /** @class */ (function (_super) {
    __extends(Discrete, _super);
    /**
     * Initializes a new instance of the Discrete class
     * @param {EventHandleSpec} config - GestureHandleHandleSpec object
     */
    function Discrete(config) {
        var _this = _super.call(this, config, "discrete" /* Discrete */, /*hasSlop*/ true) || this;
        _this.doneFirstTap = null;
        _this.startX = 0;
        _this.startY = 0;
        _this.possible = false;
        _this.startTime = 0;
        return _this;
    }
    Discrete.prototype.Start = function (e) {
        var _this = this;
        var touch = e.touches[0];
        if (e.touches.length !== this.numTouches) {
            this.Reset();
            return;
        }
        var param = this.GetParams(e);
        if (!this.ProcessGlobalEvent(GlobalUIEvents_1.GlobalUIEvents.FireFirstTouch, e)) {
            return;
        }
        // regular firstTouch happens only if not canceled elsewhere
        this.Fire("firstTouch" /* FirstTouch */, e, param);
        this.startX = touch.pageX;
        this.startY = touch.pageY;
        this.possible = true;
        this.pressTimer = MiscUtil_1.MiscUtil.ClearTimeout(this.pressTimer);
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(this.doneFirstTap)) {
            this.startTime = new Date().getTime();
            this.potentialPressTimer = window.setTimeout(function () { return _this.DoPotentialPress(e, param); }, Gesture_1.Gesture.PotentialPressTime);
            this.pressTimer = window.setTimeout(function () { return _this.DoPress(e, param); }, Gesture_1.Gesture.PressTime);
        }
    };
    Discrete.prototype.Move = function (e) {
        if (this.PastSlop(e)) {
            this.Reset();
        }
        if (e.type === "touchmove" /* TouchMove */) {
            this.Fire("touchMove" /* TouchMove */, e, this.GetParams(e));
        }
    };
    Discrete.prototype.End = function (e) {
        var param = this.GetParams(e);
        if (this.isActivePress) {
            this.DoPressEnd(e, param);
        }
        this.CancelPress();
        // bugzid 39261: we only want to recognize left clicks for mouse events
        if (this.possible && (!e.IsMouseEvent || e.IsLeftMouseEvent)) {
            // first tap = potential tap, second tap = double tap
            if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.doneFirstTap) && this.doneFirstTap) {
                this.DoDoubleTap(e, param);
            }
            else {
                this.DoTap(e, param);
            }
        }
        // if we get a ContextMenu event, it means right-mouse was used and mouse up has
        // already been processed (ignored), so this.possible is going to be false
        if (e.type === "contextmenu" /* ContextMenu */) {
            if (!this.ProcessGlobalEvent(GlobalUIEvents_1.GlobalUIEvents.FireRightClick, e)) {
                return;
            }
            // TFSID888067 - When right click dragging for Aggregation pill, releasing triggers the right click on the
            // target pill, which shouldn't happen and doesn't happen on Desktop.
            // If coming out of a drag, we do not trigger the rightclick event and prevents the native contextmenu from
            // showing up.
            if (this.PastSlop(e)) {
                e.preventDefault();
            }
            else {
                this.DoRightClick(e, param);
            }
        }
        if (e.touches.length === 0) {
            if (!this.ProcessGlobalEvent(GlobalUIEvents_1.GlobalUIEvents.FireLastTouch, e)) {
                return;
            }
            this.Fire("lastTouch" /* LastTouch */, e, param);
        }
    };
    Discrete.prototype.Cancel = function () {
        this.Reset();
    };
    Discrete.prototype.Reset = function () {
        this.CancelPress();
        this.possible = false;
        this.doneFirstTap = null;
        this.isPotentialPress = false;
        this.isActivePress = false;
        this.doubleTapTimer = MiscUtil_1.MiscUtil.ClearTimeout(this.doubleTapTimer);
    };
    Discrete.prototype.DoEvent = function (eventName, e, param, options) {
        this.Fire(eventName, e, param);
        // tslint:disable-next-line:no-string-literal no-any whitespace strict-boolean-expressions
        if (options && options['reset']) {
            this.Reset();
        }
    };
    Discrete.prototype.DoDoubleTap = function (e, param) {
        this.doubleTapTimer = MiscUtil_1.MiscUtil.ClearTimeout(this.doubleTapTimer);
        this.DoEvent("doubleTap" /* DoubleTap */, e, param, { reset: true });
    };
    Discrete.prototype.DoPress = function (e, param) {
        this.isPotentialPress = false;
        if (!this.ProcessGlobalEvent(GlobalUIEvents_1.GlobalUIEvents.FirePress, e)) {
            return;
        }
        this.DoEvent("press" /* Press */, e, param, { reset: true });
        this.isActivePress = true;
    };
    Discrete.prototype.DoPotentialPress = function (e, param) {
        this.isPotentialPress = true;
        this.DoEvent("potentialPress" /* PotentialPress */, e, param);
    };
    Discrete.prototype.DoPressEnd = function (e, param) {
        this.DoEvent("pressEnd" /* PressEnd */, e, param);
        this.isActivePress = false;
    };
    Discrete.prototype.CancelPress = function () {
        this.potentialPressTimer = MiscUtil_1.MiscUtil.ClearTimeout(this.potentialPressTimer);
        this.pressTimer = MiscUtil_1.MiscUtil.ClearTimeout(this.pressTimer);
        if (this.isPotentialPress) {
            this.DoEvent("cancelPotentialPress" /* CancelPotentialPress */, {}, null);
        }
    };
    Discrete.prototype.DoTap = function (e, param) {
        var _this = this;
        // this is called on finger-up, so it's still just a potential tap
        this.doneFirstTap = true;
        if (!this.ProcessGlobalEvent(GlobalUIEvents_1.GlobalUIEvents.FireTap, e)) {
            return;
        }
        // only set the double tap timer if the config says we are looking for double taps
        if (this.Config.IsHandling("doubleTap" /* DoubleTap */)) {
            this.doubleTapTimer = window.setTimeout(function () {
                _this.Reset();
                _this.Fire("cancelPotentialDoubleTap" /* CancelPotentialDoubleTap */, e, param);
            }, 
            // tslint:disable-next-line:align
            Gesture_1.Gesture.DoubleTapTime - this.GetElapsedTime());
        }
        else {
            this.Reset();
        }
        // B38851 LOGIC CHANGE: fire tap immediately, without waiting to decide double-tap-ness
        this.Fire("tap" /* Tap */, e, param);
    };
    Discrete.prototype.DoRightClick = function (e, param) {
        this.Fire("rightClick" /* RightClick */, e, param);
    };
    /**
    * Publishes the global event and waits for handlers to handle the event before returning
    * @param {*} eventInvoker - Action that will fire appropriate event
    * @param {NormalizedEvent} e - the event to sent to the handlers
    * @returns true if the event was not canceled
    */
    Discrete.prototype.ProcessGlobalEvent = function (eventInvoker, e) {
        var _this = this;
        var canceled = false;
        var cancelCallback = function (preventDefault) {
            _this.Reset();
            if (preventDefault) {
                // Copied from EventUtil.StopEvent
                e.stopPropagation();
                e.preventDefault();
            }
            canceled = true;
        };
        eventInvoker(e, cancelCallback);
        return !canceled;
    };
    Discrete.prototype.GetElapsedTime = function () {
        return new Date().getTime() - this.startTime;
    };
    Discrete.prototype.PastSlop = function (e) {
        var touch = e.changedTouches[0];
        var zoomAdjustedSlop = this.ZoomAdjustedSlop;
        return Math.abs(touch.pageX - this.startX) > zoomAdjustedSlop || Math.abs(touch.pageY - this.startY) > zoomAdjustedSlop;
    };
    Discrete.prototype.GetParams = function (e) {
        var param = new Gesture_1.GestureEventInfo();
        param.pageX = e.changedTouches[0].pageX;
        param.pageY = e.changedTouches[0].pageY;
        param.clientX = e.changedTouches[0].clientX;
        param.clientY = e.changedTouches[0].clientY;
        // For discrete gestures, (PageX, PageY) is also the start of the gesture.
        param.startX = e.changedTouches[0].pageX;
        param.startY = e.changedTouches[0].pageY;
        return param;
    };
    return Discrete;
}(Gesture_1.Gesture));
exports.Discrete = Discrete;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
* Tableau Event handler needs this data to properly remove event listeners.
*/
var DomSubscriptionHandle = /** @class */ (function () {
    function DomSubscriptionHandle(domElement, eventHandler) {
        this.DomElement = domElement;
        this.EventHandler = eventHandler;
    }
    return DomSubscriptionHandle;
}());
exports.DomSubscriptionHandle = DomSubscriptionHandle;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
* This class listens to pointer events to determine which input device (mouse, pen, touch, etc.) is being used.
*/
var PointerEventDetector = /** @class */ (function () {
    function PointerEventDetector() {
    }
    PointerEventDetector.handlePointerEvent = function (event) {
        PointerEventDetector._currentPointerType = event.pointerType;
    };
    PointerEventDetector.init = function () {
        if (!PointerEventDetector._initialized) {
            document.body.addEventListener('pointerdown', PointerEventDetector.handlePointerEvent, { capture: true });
            document.body.addEventListener('pointermove', PointerEventDetector.handlePointerEvent, { capture: true });
            PointerEventDetector._initialized = true;
        }
    };
    PointerEventDetector.remove = function () {
        document.body.removeEventListener('pointerdown', PointerEventDetector.handlePointerEvent, { capture: true });
        document.body.removeEventListener('pointermove', PointerEventDetector.handlePointerEvent, { capture: true });
        PointerEventDetector._currentPointerType = '';
        PointerEventDetector._initialized = false;
    };
    Object.defineProperty(PointerEventDetector, "initialized", {
        get: function () {
            return PointerEventDetector._initialized;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PointerEventDetector, "currentPointerType", {
        get: function () {
            return PointerEventDetector._currentPointerType;
        },
        enumerable: true,
        configurable: true
    });
    PointerEventDetector._initialized = false;
    PointerEventDetector._currentPointerType = '';
    return PointerEventDetector;
}());
exports.PointerEventDetector = PointerEventDetector;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// NOTE: See ApiCommand.cs for an explanation on why we need to fiddle with the namespaces
// #if BOOTSTRAP
// namespace Tableau.JavaScript.Vql.Bootstrap
// #else
// namespace Tableau.JavaScript.Vql.ApiShared
// #endif
var NonApiCommandName;
(function (NonApiCommandName) {
    NonApiCommandName["Bootstrap"] = "tableau.bootstrap";
    NonApiCommandName["Completed"] = "completed";
    NonApiCommandName["VisibleRectRequest"] = "layoutInfoReq";
    NonApiCommandName["VisibleRectResponse"] = "layoutInfoResp";
    NonApiCommandName["LegacyVizOffsetResp"] = "vizOffsetResp";
    NonApiCommandName["EnableVisibleRectCommunication"] = "tableau.enableVisibleRectCommunication";
    NonApiCommandName["TableauCompleted"] = "tableau.completed";
    NonApiCommandName["UnhandledException"] = "tableau.unhandledException";
    NonApiCommandName["Listening"] = "tableau.listening";
    NonApiCommandName["Responsive"] = "tableau.responsive";
    NonApiCommandName["ScaleFactorRequest"] = "sf?";
    NonApiCommandName["ScaleFactorResponse"] = "sf";
})(NonApiCommandName || (NonApiCommandName = {}));
exports.NonApiCommandName = NonApiCommandName;
/**
* Represents a legacy command that is sent across the iframe boundary.
* If you're making a new command, please use <see cref="ApiCommand"/> instead. This version is only intended to
* wrap legacy commands from viz_v1.
*/
/*[ScriptNamespace("tab")]*/
var NonApiCommand = /** @class */ (function () {
    // NOTE: this used to be a variadic param: parameters: (typescript ...string[]) (c# params string[] parameters)
    function NonApiCommand(name, parameters) {
        this.Name = name;
        this.parameters = parameters;
    }
    Object.defineProperty(NonApiCommand.prototype, "Parameters", {
        get: function () {
            return this.parameters;
        },
        enumerable: true,
        configurable: true
    });
    NonApiCommand.Parse = function (serialized) {
        var args = serialized.split(',');
        var name = args[0];
        var parameters = args.slice(1);
        return new NonApiCommand(name, parameters);
    };
    NonApiCommand.prototype.Serialize = function () {
        var message = new Array();
        message.push(this.Name.toString());
        message = message.concat(this.parameters);
        return message.join(',');
    };
    return NonApiCommand;
}());
exports.NonApiCommand = NonApiCommand;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var VizclientUtils_1 = __webpack_require__(1);
var browser_support_1 = __webpack_require__(4);
var MiscUtil_1 = __webpack_require__(0);
var Param_1 = __webpack_require__(30);
/**
* A utility class that uses event capture to detect the mouse leaving the document.
*/
var MouseCapture = /** @class */ (function () {
    function MouseCapture() {
    }
    Object.defineProperty(MouseCapture, "ManuallyCaptureMouseEvents", {
        /**
        * returns true if we can use event listeners on the document in order to watch mouse events
        * during the capture phase.
        */
        get: function () {
            // Not on mobile - capture is done natively on mobile, so we don't want to override that implementation,
            // and only if browser supports AddEventListener on the Document (IE 7/8 does not)
            return !VizclientUtils_1.TsConfig.IsMobile() && browser_support_1.BrowserSupport.AddEventListener();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseCapture, "ForceDragStopOnIFrameMouseOut", {
        /**
        * Tells us whether it's ok to force a drag stop event when the mouse leaves the document and we're in
        * an iFrame.  This prevents the situation where mouse is released outside the document and when mouse reenters
        * the document, we're still dragging even though the mouse is up.
        */
        get: function () {
            // We only need to force a stop drag on mouse leaving the window in IE - other browsers work fine without it,
            // and only if we're in an iFrame
            return browser_support_1.BrowserSupport.IsIE() && VizclientUtils_1.BootstrapUtility.IsEmbedded();
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Normal case is to call this in response to a mousedown event where dragging/tracking will occur until mouseup.
    *
    * Both IE and Firefox have built-in support for setCapture.
    * https://developer.mozilla.org/en-US/docs/Web/API/Element.setCapture
    *
    * Chrome(WebKit) doesn't have setCapture so we're going to use the mouse capture phase
    * to steal any mousemove/up/out events so that we can be sure no one is stopping them.
    * When we can't use setCapture and we are in an iFrame, it's not possible to receive mouse events once
    * the mouse has left the document, so in this case we complete the capture as soon as the mouse leaves the document.
    *
    * @param {IMouseCaptureEventHandler} handler - The event handler used to receive events in the case we handle mouse
    * events manually.
    */
    MouseCapture.SetCapture = function (handler) {
        Param_1.Param.VerifyValue(handler, 'handler');
        if (MouseCapture.ManuallyCaptureMouseEvents) {
            MouseCapture.eventHandlers.push(handler);
            if (!MouseCapture.areMouseListenersAttached) {
                // listen for the mouse events during the capture phase (pass true for useCapture)
                document.addEventListener("mousemove" /* MouseMove */, this.HandleMouseMove, true);
                document.addEventListener("mouseup" /* MouseUp */, this.HandleMouseUp, true);
                document.addEventListener("mouseout" /* MouseOut */, this.HandleMouseOut, true);
                MouseCapture.areMouseListenersAttached = true;
            }
        }
    };
    /**
    * Ends mouse event capture for all previously set handlers.
    */
    MouseCapture.ReleaseCapture = function () {
        if (MouseCapture.ManuallyCaptureMouseEvents) {
            MouseCapture.eventHandlers = [];
            document.removeEventListener("mousemove" /* MouseMove */, this.HandleMouseMove, true);
            document.removeEventListener("mouseup" /* MouseUp */, this.HandleMouseUp, true);
            document.removeEventListener("mouseout" /* MouseOut */, this.HandleMouseOut, true);
            MouseCapture.areMouseListenersAttached = false;
        }
    };
    MouseCapture.HandleMouseMove = function (e) {
        MouseCapture.eventHandlers.forEach(function (handler) { return handler.HandleCapturedMouseMove(e); });
    };
    MouseCapture.HandleMouseUp = function (e) {
        MouseCapture.HandleComplete(e);
        VizclientUtils_1.Logger.Debug('Mouse has been released, calling HandleCaptureComplete on the handler');
    };
    MouseCapture.HandleMouseOut = function (e) {
        // test to see if the mouse has left the document
        if (MouseCapture.ForceDragStopOnIFrameMouseOut && MouseCapture.EventIsOutsideDocument(e)) {
            MouseCapture.HandleComplete(e);
            VizclientUtils_1.Logger.Debug('Mouse is Exiting document and document is in an iFrame - calling HandleCapturedMouseComplete on the handler');
        }
    };
    MouseCapture.HandleComplete = function (e) {
        MouseCapture.eventHandlers.forEach(function (handler) { return handler.HandleCapturedMouseComplete(e); });
    };
    MouseCapture.EventIsOutsideDocument = function (e) {
        // tslint:disable-next-line:no-any whitespace
        var toElement = e.toElement;
        // Below from http://stackoverflow.com/questions/923299/how-can-i-detect-when-the-mouse-leaves-the-window
        return (MiscUtil_1.MiscUtil.IsNullOrUndefined(toElement) || toElement.NodeName === 'HTML');
    };
    MouseCapture.eventHandlers = [];
    MouseCapture.areMouseListenersAttached = false;
    return MouseCapture;
}());
exports.MouseCapture = MouseCapture;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil_1 = __webpack_require__(0);
var TypeUtil_1 = __webpack_require__(2);
var Param = /** @class */ (function () {
    function Param() {
    }
    Param.VerifyValue = function (param, paramName) {
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(param)) {
            var ex = Param.CreateArgumentNullOrUndefinedException(paramName);
            Param.ShowParameterAlert(ex);
            throw ex;
        }
    };
    Param.CreateArgumentNullOrUndefinedException = function (paramName) {
        var ex = new DOMException("{paramName} is null or undefined");
        TypeUtil_1.TypeUtil.SetField(ex, paramName, paramName);
        return ex;
    };
    Param.ShowParameterAlert = function (ex) {
        if (this.SuppressAlerts) {
            return;
        }
        // this try/catch block is so we can get the stack trace to display in the alert dialog
        try {
            throw ex;
        }
        catch (exceptionWithStack) {
            window.alert(Param.FormatExceptionMessage(exceptionWithStack));
        }
    };
    Param.FormatExceptionMessage = function (ex) {
        var message = '';
        // tslint:disable-next-line:no-any whitespace
        var stack = ex.stack;
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(stack)) {
            message = stack;
        }
        else {
            message = ex.message;
        }
        return message;
    };
    Param.SuppressAlerts = false;
    return Param;
}());
exports.Param = Param;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Gesture_1 = __webpack_require__(6);
/**
 * This class implements the pinch gesture
 */
var Pinch = /** @class */ (function (_super) {
    __extends(Pinch, _super);
    /**
     * Initializes a new instance of the Pinch class
     * @param {EventHandleSpec} config - GestureEventHandleSpec object
     */
    function Pinch(config) {
        var _this = _super.call(this, config, "pinch" /* Pinch */, /*hasSlop:*/ true, /*numTouches:*/ 2) || this;
        _this.pinching = false;
        return _this;
    }
    Pinch.prototype.Start = function (e) {
        if (e.touches.length < this.numTouches) {
            return;
        }
        if (this.pinching) {
            return;
        }
        this.touch1 = e.touches[0];
        this.touch2 = e.touches[1];
        this.startParams = this.GetStartParams();
        this.lastParams = this.startParams;
        var param = this.GetParams();
        this.Fire("pinchStart" /* PinchStart */, e, param);
        this.pinching = true;
    };
    Pinch.prototype.Move = function (e) {
        if (!this.pinching) {
            return;
        }
        if (e.touches.length < 2) {
            this.End(e); // Let's end the pinch
            return;
        }
        this.touch1 = e.touches[0];
        this.touch2 = e.touches[1];
        this.lastParams = this.GetParams();
        this.Fire("pinchMove" /* PinchMove */, e, this.lastParams);
    };
    Pinch.prototype.End = function (e) {
        if (e.touches.length > this.numTouches) {
            return;
        }
        if (this.pinching) {
            this.pinching = false;
            var param = this.GetParams();
            this.Fire("pinchEnd" /* PinchEnd */, e, param);
        }
    };
    Pinch.prototype.Cancel = function () {
        // Do nothing
    };
    Pinch.prototype.GetStartParams = function () {
        var t1 = this.touch1;
        var t2 = this.touch2;
        var distX = t2.pageX - t1.pageX;
        var distY = t2.pageY - t1.pageY;
        var distance = Math.sqrt((distX * distX) + (distY * distY));
        var centerX = (distX / 2) + t1.pageX;
        var centerY = (distY / 2) + t1.pageY;
        var params = new Gesture_1.GestureEventInfo();
        params.pageX = centerX;
        params.pageY = centerY;
        params.distance = distance;
        return params;
    };
    Pinch.prototype.GetParams = function () {
        var t1 = this.touch1;
        var t2 = this.touch2;
        var distX = t2.pageX - t1.pageX;
        var distY = t2.pageY - t1.pageY;
        var distance = Math.sqrt((distX * distX) + (distY * distY));
        var centerX = (distX / 2) + t1.pageX;
        var centerY = (distY / 2) + t1.pageY;
        var params = new Gesture_1.GestureEventInfo();
        params.pageX = centerX;
        params.pageY = centerY;
        params.scale = distance / this.startParams.distance;
        params.deltaX = centerX - this.startParams.pageX;
        params.deltaY = centerY - this.startParams.pageY;
        params.startX = this.startParams.pageX;
        params.startY = this.startParams.pageY;
        params.deltaXSinceLast = centerX - this.lastParams.pageX;
        params.deltaYSinceLast = centerY - this.lastParams.pageY;
        return params;
    };
    return Pinch;
}(Gesture_1.Gesture));
exports.Pinch = Pinch;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var browser_support_1 = __webpack_require__(4);
var MiscUtil_1 = __webpack_require__(0);
var NormalizedEvent_1 = __webpack_require__(5);
var VizclientUtils_1 = __webpack_require__(1);
/**
* Create and set <see cref="EventHandleSpec"/> object's properties with appropriate values.
*/
var NormalizedEventBuilder = /** @class */ (function () {
    function NormalizedEventBuilder() {
    }
    Object.defineProperty(NormalizedEventBuilder, "HandledEvents", {
        get: function () {
            NormalizedEventBuilder.SetupEventNames();
            return NormalizedEventBuilder.handledEvents;
        },
        enumerable: true,
        configurable: true
    });
    NormalizedEventBuilder.CreateNormalizedEvent = function (evt, listeningNode, reactEvent) {
        if (reactEvent === void 0) { reactEvent = null; }
        NormalizedEventBuilder.SetupEventNames();
        var normalizedEvent = new NormalizedEvent_1.NormalizedEvent(evt, listeningNode, reactEvent);
        normalizedEvent.source = NormalizedEventBuilder.HandledEvents[normalizedEvent.type];
        normalizedEvent.inputType = NormalizedEventBuilder.GetEventInputType(normalizedEvent.type);
        return normalizedEvent;
    };
    NormalizedEventBuilder.GetEventInputType = function (eventName) {
        NormalizedEventBuilder.SetupEventNames();
        var inputType = 6 /* UnSupported */;
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(NormalizedEventBuilder.startEvents[eventName])) {
            inputType = 0 /* Start */;
        }
        else if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(NormalizedEventBuilder.moveEvents[eventName])) {
            inputType = 1 /* Move */;
        }
        else if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(NormalizedEventBuilder.endEvents[eventName])) {
            inputType = 2 /* End */;
        }
        else if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(NormalizedEventBuilder.outEvents[eventName])) {
            inputType = 3 /* Out */;
        }
        else if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(NormalizedEventBuilder.cancelEvents[eventName])) {
            inputType = 5 /* Cancel */;
        }
        else if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(NormalizedEventBuilder.scrollEvents[eventName])) {
            inputType = 4 /* Scroll */;
        }
        return inputType;
    };
    NormalizedEventBuilder.Reset = function () {
        NormalizedEventBuilder.handledEvents = {};
        NormalizedEventBuilder.startEvents = {};
        NormalizedEventBuilder.moveEvents = {};
        NormalizedEventBuilder.endEvents = {};
        NormalizedEventBuilder.outEvents = {};
        NormalizedEventBuilder.scrollEvents = {};
        NormalizedEventBuilder.cancelEvents = {};
        NormalizedEventBuilder.initialized = false;
    };
    NormalizedEventBuilder.SetupEventNames = function () {
        if (NormalizedEventBuilder.initialized) {
            return;
        }
        // Always watch for touch events, whether web or mobile
        NormalizedEventBuilder.startEvents["touchstart" /* TouchStart */] = 2 /* Touch */;
        NormalizedEventBuilder.moveEvents["touchmove" /* TouchMove */] = 2 /* Touch */;
        NormalizedEventBuilder.endEvents["touchend" /* TouchEnd */] = 2 /* Touch */;
        NormalizedEventBuilder.cancelEvents["touchcancel" /* TouchCancel */] = 2 /* Touch */;
        // if doing development with ?:mobile=true, mouse masquerades as touch so watch for subset
        // of mouse events that masquerade as touch. BUGZID 98802
        if (VizclientUtils_1.TsConfig.IsMobile()) {
            if (!browser_support_1.BrowserSupport.IsTouch()) {
                NormalizedEventBuilder.startEvents["mousedown" /* MouseDown */] = 1 /* Mouse */;
                NormalizedEventBuilder.moveEvents["mousemove" /* MouseMove */] = 1 /* Mouse */;
                NormalizedEventBuilder.endEvents["mouseup" /* MouseUp */] = 1 /* Mouse */;
                NormalizedEventBuilder.outEvents["mouseout" /* MouseOut */] = 1 /* Mouse */;
            }
            // else if in normal mobile environment, ignore mouse events. BUGZID 97746
        }
        else {
            // else if web, watch for mouse events
            NormalizedEventBuilder.startEvents["mousedown" /* MouseDown */] = 1 /* Mouse */;
            NormalizedEventBuilder.moveEvents["mousemove" /* MouseMove */] = 1 /* Mouse */;
            NormalizedEventBuilder.endEvents["mouseup" /* MouseUp */] = 1 /* Mouse */;
            NormalizedEventBuilder.outEvents["mouseout" /* MouseOut */] = 1 /* Mouse */;
            NormalizedEventBuilder.scrollEvents["scroll" /* Scroll */] = 1 /* Mouse */;
            NormalizedEventBuilder.endEvents["contextmenu" /* ContextMenu */] = 1 /* Mouse */;
        }
        $.extend(NormalizedEventBuilder.handledEvents, NormalizedEventBuilder.startEvents, NormalizedEventBuilder.moveEvents, NormalizedEventBuilder.endEvents, NormalizedEventBuilder.outEvents, NormalizedEventBuilder.scrollEvents, NormalizedEventBuilder.cancelEvents);
        NormalizedEventBuilder.initialized = true;
    };
    // All events that we listen to
    NormalizedEventBuilder.handledEvents = {};
    // string names of events that we listen to
    NormalizedEventBuilder.startEvents = {};
    NormalizedEventBuilder.moveEvents = {};
    NormalizedEventBuilder.endEvents = {};
    NormalizedEventBuilder.outEvents = {};
    NormalizedEventBuilder.scrollEvents = {};
    NormalizedEventBuilder.cancelEvents = {};
    NormalizedEventBuilder.initialized = false;
    return NormalizedEventBuilder;
}());
exports.NormalizedEventBuilder = NormalizedEventBuilder;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: move these to generated enums
Object.defineProperty(exports, "__esModule", { value: true });
var SelectAction;
(function (SelectAction) {
    SelectAction["Simple"] = "simple";
    SelectAction["Toggle"] = "toggle";
    SelectAction["Range"] = "range";
    SelectAction["Menu"] = "menu";
})(SelectAction || (SelectAction = {}));
exports.SelectAction = SelectAction;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _ = __webpack_require__(12);
var $ = __webpack_require__(3);
var React = __webpack_require__(35);
var ReactDOM = __webpack_require__(36);
var MiscUtil_1 = __webpack_require__(0);
var TableauEventHandlerForReact_1 = __webpack_require__(20);
// ------------------------------------
/**
* A component that handles Tableau Events by forwarding raw React events to TableauEventHandler.
* Wrap your components under this to provide hooks to Tableau Events.
*/
var EventForwarder = /** @class */ (function (_super) {
    __extends(EventForwarder, _super);
    function EventForwarder(props) {
        var _this = _super.call(this, props, null) || this;
        _this.eventHandler = null;
        // EventForwarder maintains a reference to the current element and spec objects for equality comparison
        // when updates to the component occur. The should be used for no other purpose.
        _this.element = null;
        _this.spec = null;
        _this.eventHandler = TableauEventHandlerForReact_1.TableauEventHandlerForReact.CreateEmpty();
        return _this;
    }
    /**
    * Shorthand for creating an EventForward component.
    */
    EventForwarder.createElement = function (tagName, spec, attrs) {
        var children = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            children[_i - 3] = arguments[_i];
        }
        var evtFwdrProps = {
            TagName: tagName,
            HtmlAttributes: attrs,
            Spec: spec,
            key: attrs.key
        };
        // move ref to the wrapper level so lookup through ref on event forwarder wrapper object works.
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(attrs.ref)) {
            evtFwdrProps.ref = attrs.ref;
            delete attrs.ref;
        }
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(children) && children.length === 1) {
            // TFSID 479359 if only one child, don't pass an array so React doesn't complain about it needing a key
            return React.createElement(EventForwarder, evtFwdrProps, children[0]);
        }
        return React.createElement(EventForwarder, evtFwdrProps, children);
    };
    EventForwarder.div = function (spec, attrs) {
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        return EventForwarder.createElement('div', spec, attrs, children);
    };
    EventForwarder.span = function (spec, attrs) {
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        return EventForwarder.createElement('span', spec, attrs, children);
    };
    EventForwarder.prototype.render = function () {
        return React.createElement(this.props.TagName, 
        // tslint:disable-next-line:align
        $.extend({}, this.eventHandler.EventHandlingAttributesForReact, this.props.HtmlAttributes), this.props.children);
    };
    EventForwarder.prototype.componentDidMount = function () {
        this.UpdateElementSpec();
    };
    EventForwarder.prototype.componentDidUpdate = function () {
        this.UpdateElementSpec();
    };
    EventForwarder.prototype.componentWillUnmount = function () {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.eventHandler)) {
            this.eventHandler.dispose();
        }
    };
    EventForwarder.prototype.UpdateElementSpec = function () {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.props.Spec)) {
            var newElement = ReactDOM.findDOMNode(this);
            // If either the DOM element associated with this React component OR the spec object has changed,
            // the eventHandler needs to be updated so it is working with the new objects in play. Without this
            // update to the eventHandler, this EventForwarder may stop working since it may still be listening
            // to events on a discarded DOM element or it may be triggering calls to handlers on an old spec.
            if (newElement instanceof HTMLElement) {
                if (this.element !== newElement || EventForwarder.HasEventHandleSpecChanged(this.spec, this.props.Spec)) {
                    this.eventHandler.UpdateEventHandleSpec(newElement, this.props.Spec);
                    this.element = newElement;
                    this.spec = this.props.Spec;
                }
            }
        }
    };
    /**
    * Returns whether the event handle spec for the react element has changed. Make sure all event handlers
    * defined on the new spec are defined in the existing spec and they are structurally equal.
    * @param {EventHandleSpec} curSpec - current spec from
    * @param {EventHandleSpec} newSpec- new event spec from the props
    * @returns {boolean} if the spec is listening to new events
    */
    EventForwarder.HasEventHandleSpecChanged = function (curSpec, newSpec) {
        // this check is to prevent reloading the spec when it hasn't changed meaningfully,
        // so that single click events that casue the component to update do not prevent double-click events from being recognized
        // (TFSID: 404282, TFSID:415028, TFSID:423538)
        // Right now, it only recognizes adding event handlers as changes that require updates - in future, we might want to expand that
        return !_.every(Object.keys(newSpec), function (key) { return Object.keys(curSpec).indexOf(key) !== -1; });
    };
    return EventForwarder;
}(React.Component));
exports.EventForwarder = EventForwarder;


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_35__;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_36__;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil_1 = __webpack_require__(0);
var CallOnDispose = /** @class */ (function () {
    function CallOnDispose(callOnDispose) {
        this.callOnDispose = callOnDispose;
    }
    CallOnDispose.prototype.dispose = function () {
        if (MiscUtil_1.MiscUtil.IsNullOrUndefined(this.callOnDispose)) {
            return;
        }
        this.callOnDispose();
        this.callOnDispose = null;
    };
    return CallOnDispose;
}());
exports.CallOnDispose = CallOnDispose;
var DisposableHolder = /** @class */ (function () {
    function DisposableHolder() {
        this.disposables = [];
    }
    DisposableHolder.prototype.add = function (ds) {
        var _this = this;
        if (typeof ds === 'function') {
            this.disposables.push(new CallOnDispose(ds));
        }
        else if (ds.dispose !== undefined) {
            this.disposables.push(ds);
        }
        else if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(ds)) {
            ds.forEach(function (disposable) {
                _this.disposables.push(disposable);
            });
        }
    };
    DisposableHolder.prototype.dispose = function () {
        this.disposables.forEach(function (disposable) {
            disposable.dispose();
        });
        this.disposables = [];
    };
    return DisposableHolder;
}());
exports.DisposableHolder = DisposableHolder;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var DragDropManager_1 = __webpack_require__(21);
var SimplifiedDragSafeGlass = /** @class */ (function () {
    function SimplifiedDragSafeGlass() {
        this.parentElement = null;
        this.Element = $(SimplifiedDragSafeGlass.HtmlTemplate);
        this.parentElement = document.body;
        DragDropManager_1.DragDropManager.registerDragGlass(this);
    }
    SimplifiedDragSafeGlass.prototype.dispose = function () {
        DragDropManager_1.DragDropManager.unregisterDragGlass(this);
        this.Element.remove();
    };
    SimplifiedDragSafeGlass.prototype.disableHitTests = function () {
        this.Element.css('pointer-events', 'none');
    };
    SimplifiedDragSafeGlass.prototype.enableHitTests = function () {
        this.Element.css('pointer-events', 'auto');
    };
    SimplifiedDragSafeGlass.prototype.show = function () {
        if (this.Element.parent()[0] !== this.parentElement) {
            this.Element.appendTo(this.parentElement);
        }
        if (this.opaque) {
            this.Element.toggleClass('glass-fade-in-immediate', true);
        }
        this.Element.show();
    };
    Object.defineProperty(SimplifiedDragSafeGlass.prototype, "opaque", {
        get: function () {
            return this.Element.hasClass(SimplifiedDragSafeGlass.OpaqueGlassClass);
        },
        set: function (value) {
            this.Element.toggleClass(SimplifiedDragSafeGlass.ClearGlassClass, !value);
            this.Element.toggleClass(SimplifiedDragSafeGlass.OpaqueGlassClass, value);
        },
        enumerable: true,
        configurable: true
    });
    SimplifiedDragSafeGlass.GlassClass = 'tab-glass';
    SimplifiedDragSafeGlass.ClearGlassClass = 'clear-glass';
    SimplifiedDragSafeGlass.OpaqueGlassClass = 'opaque-glass';
    SimplifiedDragSafeGlass.HtmlTemplate = "<div class='" + SimplifiedDragSafeGlass.GlassClass + " " + SimplifiedDragSafeGlass.ClearGlassClass + "'/>";
    return SimplifiedDragSafeGlass;
}());
exports.SimplifiedDragSafeGlass = SimplifiedDragSafeGlass;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MiscUtil_1 = __webpack_require__(0);
var TypeUtil_1 = __webpack_require__(2);
var WindowHelper = /** @class */ (function () {
    function WindowHelper() {
    }
    Object.defineProperty(WindowHelper, "Selection", {
        get: function () {
            if (TypeUtil_1.TypeUtil.HasMethod(/*typeof*/ window, 'getSelection')) {
                return window.getSelection();
            }
            if (TypeUtil_1.TypeUtil.HasMethod(/*typeof*/ document, 'getSelection')) {
                return document.getSelection();
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    /// <summary>
    /// Clears the selection object at the window/document level
    /// </summary>
    WindowHelper.ClearSelection = function () {
        var selection = this.Selection;
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(selection)) {
            if (TypeUtil_1.TypeUtil.HasMethod(selection, 'removeAllRanges')) {
                selection.removeAllRanges();
            }
            else if (TypeUtil_1.TypeUtil.HasMethod(selection, 'empty')) {
                selection.empty();
            }
        }
    };
    /// <summary>
    /// Requests an animation frame
    /// Falls back to using Window.SetTimeout if the browser does not support RequestAnimationFrame
    /// </summary>
    /// <param name="action">Action to execute</param>
    /// <returns>animation id used to cancel the animation</returns>
    WindowHelper.RequestAnimationFrame = function (action) {
        return WindowHelper.requestAnimationFrameFunc(action);
    };
    /// <summary>
    /// Cancels an animation
    /// </summary>
    /// <param name="animationId">id of animation to cancel</param>
    WindowHelper.CancelAnimationFrame = function (animationId) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(animationId)) {
            WindowHelper.cancelAnimationFrameFunc(animationId);
        }
    };
    WindowHelper.SetDefaultRequestAnimationFrameImpl = function () {
        var lastTime = 0;
        WindowHelper.requestAnimationFrameFunc = function (callback) {
            var curTime = Date.now();
            var timeToCall = Math.max(0, 16 - (curTime - lastTime));
            lastTime = curTime + timeToCall;
            var id = window.setTimeout(callback, timeToCall);
            return id;
        };
    };
    WindowHelper.PolyFillRequestAnimationFrame = function () {
        // Polyfill for RequestAnimationFrame - http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        var DefaultRequestName = 'requestAnimationFrame';
        var DefaultCancelName = 'cancelAnimationFrame';
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        var requestFuncName = null;
        var cancelFuncName = null;
        if (TypeUtil_1.TypeUtil.HasMethod(window, DefaultRequestName)) {
            requestFuncName = DefaultRequestName;
        }
        if (TypeUtil_1.TypeUtil.HasMethod(window, DefaultCancelName)) {
            cancelFuncName = DefaultCancelName;
        }
        for (var ii = 0; ii < vendors.length && (requestFuncName === null || cancelFuncName === null); ++ii) {
            var vendor = vendors[ii];
            var funcName = vendor + 'RequestAnimationFrame';
            if (requestFuncName === null && TypeUtil_1.TypeUtil.HasMethod(window, funcName)) {
                requestFuncName = funcName;
            }
            if (cancelFuncName === null) {
                funcName = vendor + 'CancelAnimationFrame';
                if (TypeUtil_1.TypeUtil.HasMethod(window, funcName)) {
                    cancelFuncName = funcName;
                }
                funcName = vendor + 'CancelRequestAnimationFrame';
                if (TypeUtil_1.TypeUtil.HasMethod(window, funcName)) {
                    cancelFuncName = funcName;
                }
            }
        }
        if (requestFuncName !== null) {
            WindowHelper.requestAnimationFrameFunc
                = function (callback) { return TypeUtil_1.TypeUtil.GetField(window, requestFuncName)(callback); };
        }
        else {
            this.SetDefaultRequestAnimationFrameImpl();
        }
        if (cancelFuncName !== null) {
            WindowHelper.cancelAnimationFrameFunc
                = function (animationId) { return TypeUtil_1.TypeUtil.GetField(window, cancelFuncName)(animationId); };
        }
        else {
            WindowHelper.cancelAnimationFrameFunc = window.clearTimeout;
        }
    };
    WindowHelper.requestAnimationFrameFunc = undefined;
    WindowHelper.cancelAnimationFrameFunc = undefined;
    return WindowHelper;
}());
exports.WindowHelper = WindowHelper;
// initialize
WindowHelper.PolyFillRequestAnimationFrame();


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var SimpleAvatar = /** @class */ (function () {
    function SimpleAvatar(innerHtml, delta, source) {
        this.avatarDelta = delta;
        this.avatarSource = source;
        this.Element = $("<span>" + innerHtml + "</span>");
    }
    SimpleAvatar.prototype.get_rootElement = function () {
        return this.Element;
    };
    SimpleAvatar.prototype.addToDom = function (parent) {
        parent.append(this.Element);
    };
    SimpleAvatar.prototype.dispose = function () {
        /** */
    };
    return SimpleAvatar;
}());
exports.SimpleAvatar = SimpleAvatar;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Delegate_1 = __webpack_require__(9);
var EmbeddedCustomCursor_1 = __webpack_require__(10);
var MiscUtil_1 = __webpack_require__(0);
var TypeUtil_1 = __webpack_require__(2);
var DragInstance = /** @class */ (function () {
    function DragInstance(dragged, dragAvatar) {
        this.shiftStateChanged = new Delegate_1.Delegate();
        this.draggedObject = dragged;
        this.DragAvatar = dragAvatar;
        this.isCopyDrag = false;
        this.IsShiftDrag = false;
        this.isRightDrag = false;
        // Check if the payload contains a dragpresmodel
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(dragged) && TypeUtil_1.TypeUtil.HasField(dragged, 'dragInstanceType')) {
            this.presmodelType = dragged.dragInstanceType;
        }
    }
    DragInstance.prototype.add_shiftStateChanged = function (ev) {
        this.shiftStateChanged.add(ev);
    };
    DragInstance.prototype.remove_shiftStateChanged = function (ev) {
        this.shiftStateChanged.remove(ev);
    };
    Object.defineProperty(DragInstance.prototype, "payload", {
        get: function () {
            return this.draggedObject;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragInstance.prototype, "hasPayload", {
        get: function () {
            return !MiscUtil_1.MiscUtil.IsNullOrUndefined(this.draggedObject);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragInstance.prototype, "isShiftDrag", {
        get: function () {
            return this.IsShiftDrag;
        },
        set: function (value) {
            if (this.IsShiftDrag !== value) {
                this.IsShiftDrag = value;
                if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.shiftStateChanged)) {
                    this.shiftStateChanged.invoke();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragInstance.prototype, "dragAvatar", {
        get: function () {
            return this.DragAvatar;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragInstance.prototype, "dragType", {
        get: function () {
            return "dragdrop" /* dragdrop */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragInstance.prototype, "readyToDrop", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragInstance.prototype, "defaultDropCursor", {
        get: function () {
            return EmbeddedCustomCursor_1.EmbeddedCustomCursor.noOp;
        },
        enumerable: true,
        configurable: true
    });
    /*virtual*/ DragInstance.prototype.moveTo = function (e) { };
    /*virtual*/ DragInstance.prototype.endDragAt = function (e) { };
    /*virtual*/ DragInstance.prototype.cancelDrag = function () { };
    /// <summary>
    /// Checks the payload to see if the object being dragged is the given object.
    /// </summary>
    /// <returns>true if testObject is the draggedObject or draggedObject is an array of one item, and
    /// that item is testObject</returns>
    DragInstance.prototype.payloadEquals = function (value) {
        if (this.draggedObject === value) {
            return true;
        }
        if (Array.isArray(this.draggedObject)) {
            var draggedObjects = this.draggedObject;
            if (draggedObjects.length === 1
                && draggedObjects[0] === value) {
                return true;
            }
        }
        return false;
    };
    /// <summary>
    /// Action that will be executed if the drag instance is not dropped on a drop target
    /// or is dropped on a drop target that refuses the drop
    /// </summary>
    /*virtual*/ DragInstance.prototype.dropToNowhereAction = function () { };
    // redirection for saltarelle generated javascript getters
    /*virtual*/ DragInstance.prototype.get_payload = function () { return this.payload; };
    /*virtual*/ DragInstance.prototype.get_hasPayload = function () { return this.hasPayload; };
    /*virtual*/ DragInstance.prototype.get_dragAvatar = function () { return this.dragAvatar; };
    /*virtual*/ DragInstance.prototype.get_dragType = function () { return this.dragType; };
    /*virtual*/ DragInstance.prototype.get_readyToDrop = function () { return this.readyToDrop; };
    /*virtual*/ DragInstance.prototype.get_defaultDropCursor = function () { return this.defaultDropCursor; };
    return DragInstance;
}());
exports.DragInstance = DragInstance;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var EmbeddedCustomCursor_1 = __webpack_require__(10);
var MiscUtil_1 = __webpack_require__(0);
/// <summary>
/// A drop target which uses delegates to replace inheritance.
///
/// Each implementation has a default behavior so you can specify just the minimum
/// set of properties to customize your behavior.  This makes it simpler to add new
/// custom drag handling to elements without having to define a new DropTarget class.
///
/// Example:
/// <![CDATA[
///   var dropTarget = new DelegateDropTarget
///   {
///       CanAccept = dragInstance => dragInstance is MyCustomDragInstance,
///       OnAcceptDrop = dragInstance =>
///       {
///           this.DoSomethingWithDroppedObject(dragInstance);
///           return jQuery.DeferredData<bool>().Resolve(true);
///       },
///       OnGetDropCursor = dragInstance => CustomCursor.Copy
///   };
///   DragDropManager.AttachDropTarget(element, dropTarget);
/// ]]>
///
/// Note: For interface methods which return IDropTarget, an additional
/// 'self' parameter is passed to make it easier to use anonymous functions in
/// the object initializer list.
///
///  Example:
///
///  var dropTarget = new DelegateDropTarget
///  {
///      OnDragOver = (dragInstance, self) => self
///  };
///
/// </summary>
var DelegateDropTarget = /** @class */ (function () {
    function DelegateDropTarget() {
    }
    DelegateDropTarget.prototype.get_feedbackType = function () {
        return (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.onFeedbackType)) ? this.onFeedbackType() : "dropfeedbackuponentry" /* dropfeedbackuponentry */;
    };
    DelegateDropTarget.prototype.dragOver = function (d) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.canAccept) && !this.canAccept(d)) {
            return null;
        }
        return (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.onDragOver)) ? this.onDragOver(d, this) : this;
    };
    DelegateDropTarget.prototype.dragExit = function (d) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.onDragExit)) {
            this.onDragExit(d);
        }
    };
    DelegateDropTarget.prototype.acceptDrop = function (d) {
        if (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.canAccept) && !this.canAccept(d)) {
            return $.Deferred().resolve(false);
        }
        return (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.onAcceptDrop)) ? this.onAcceptDrop(d) : $.Deferred().resolve(false);
    };
    DelegateDropTarget.prototype.getDropTarget = function (hit) {
        return (!MiscUtil_1.MiscUtil.IsNullOrUndefined(this.onGetDropTarget)) ? this.onGetDropTarget(hit, this) : this;
    };
    DelegateDropTarget.prototype.getDropCursor = function (currentDrag) {
        return (this.onGetDropCursor !== null) ? this.onGetDropCursor(currentDrag) : EmbeddedCustomCursor_1.EmbeddedCustomCursor.noOp;
    };
    return DelegateDropTarget;
}());
exports.DelegateDropTarget = DelegateDropTarget;


/***/ })
/******/ ]);
});
//# sourceMappingURL=eventutils.js.map